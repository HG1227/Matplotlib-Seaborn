{"./":{"url":"./","title":"Introduction","keywords":"","body":" 主要记录一些可视化的工具 [x] matplotlib [x] seaborn [x] pyeachart Update time： 2020-06-12 "},"Chapter1/":{"url":"Chapter1/","title":"图形基础设置","keywords":"","body":"图形基础设置 Update time： 2020-05-23 "},"Chapter1/figure设置.html":{"url":"Chapter1/figure设置.html","title":"figure设置","keywords":"","body":"figure设置 matplotlib.pyplot.figure(num=None, figsize=None, dpi=None, facecolor=None, edgecolor=None, frameon=True, FigureClass=, clear=False, **kwargs) 创建一个新的画布( figure )。 输入参数： num ：整型或者字符串，可选参数，默认：None。 如果不提供该参数，一个新的画布(figure)将被创建而且画布数量将会增加。 如果提供该参数，带有id的画布是已经存在的，激活该画布并返回该画布的引用。 如果这个画布不存在，创建并返回画布实例。 如果 num 是字符串，窗口标题将被设置为该图的数字。 figsize ：整型元组，可选参数 ，默认：None。 每英寸的宽度和高度。如果不提供，默认值是figure.figsize。 dpi ：整型，可选参数，默认：None。每英寸像素点。如果不提供，默认是figure.dpi。 facecolor ：背景色。如果不提供，默认值：figure.facecolor。 edgecolor ：边界颜色。如果不提供，默认值：figure.edgecolor。 framemon ：布尔类型，可选参数，默认值：True。如果是False，禁止绘制画图框。 FigureClass ：源于matplotlib.figure.Figure的类。（可选）使用自定义图实例。 clear ：布尔类型，可选参数，默认值：False。如果为True和figure已经存在时，这是清理掉改图。 返回值： figure ：Figure。返回的Figure实例也将被传递给后端的new_figure_manager，这允许将自定义的图类挂接到pylab接口中。 import numpy as np import matplotlib.pyplot as plt #创建一个数组0-100，数据间隔是0.1 x=np.arange(0,100,0.1) y=x**2 #调用subplots函数 #指定图像分辨率、大小和长宽比例 #创建一个800*600像素、100dpi(每英寸100点)分辨率的图形 #返回一个画布对象和一个轴数组 fig,axe=plt.subplots(figsize=(4,3),dpi=100) #在axe上绘制一条抛物线，红色 点 axe.plot(x,y,\"r:\") #设置y轴标记为X axe.set_xlabel(\"X\") #设置x轴标记为Y axe.set_ylabel(\"Y\") #设置图标题 axe.set_title(\"y=x**2\") #显示绘制的图片 plt.show() Update time： 2020-05-23 "},"Chapter1/中文显示问题.html":{"url":"Chapter1/中文显示问题.html","title":"中文显示问题","keywords":"","body":"中文显示问题 动态设置参数 在python脚本中动态设置 matplotlibrc，这样就避免了更改配置文件的麻烦，方便灵活，例如: from pylab import mpl mpl.rcParams[‘font.sans-serif] = [‘SimHei’] 由于更改了字体导致显示不出负号，将配署文件中axes.unicode minus : True 修改为 False 就可以了，当然这而可以用代码来完成。 from pylab import mpl mpl.rcParams['font.sans-serif'] = ['FangSong'] # 指定默认字体 mpl.rcParams['axes.unicode_minus'] = False # 解决保存图像是负号'-'显示为方块的问题 Update time： 2020-05-23 "},"Chapter1/Matplotlib刻度线的开启和关闭.html":{"url":"Chapter1/Matplotlib刻度线的开启和关闭.html","title":"Matplotlib：刻度线的开启和关闭","keywords":"","body":"Matplotlib：刻度线的开启和关闭 ﻿在matplotlib中，刻度线叫tick，刻度值叫tick_label 注意这幅图片中就包含了关于刻度线的一些信息。比方，不仅有主刻度线(Major tick)，还有次刻度线(Minor tick)。并且我们看到刻度线都是朝着图的外侧。图中，上边的和右边的坐标轴(Spine)并没有刻度线。 是否显示次刻度线 在pylab中内置了两个函数minorticks_on()和minorticks_off()用来确定是否显示次刻度线。 如下代码实现在左侧图中显示次刻度线，在右侧不显示次刻度线。在默认的情况下，不显示次刻度线。 plt.subplot(121) plt.minorticks_on() plt.subplot(122) plt.minorticks_off() plt.show() 刻度线的朝向 一般而言，我们希望刻度线朝外分布，这样避免影响图中的曲线和说明。但是有时候刻度线朝内分布，可以让图之间更加紧凑。在pylab中，利用tick_params控制刻度线的朝向，是朝图里，图外，还是都有。下面代码产生的图从左往右，分别显示朝里，朝外，两边都有的情况。 plt.subplot(131) plt.tick_params(direction='in') plt.subplot(132) plt.tick_params(direction=\"out\") plt.subplot(133) plt.tick_params(direction='inout') plt.show() 选择修改主刻度线还是次刻度线 通过上面的例子可以看出，修改刻度线的主要函数就是tick_params。那么每次调用这个函数，是修改主刻度线、次刻度线，还是都改呢？这个由参数which控制。比方下面这段代码，分别让主刻度线朝里、次刻度线朝里、主次均朝里。最后一个图说明默认情况下，主次刻度线均朝外。 plt.subplot(141) plt.minorticks_on() plt.tick_params(which='magor',direction='in') plt.subplot(142) plt.minorticks_on() plt.tick_params(which='minor',direction='in') plt.subplot(143) plt.minorticks_on() plt.tick_params(which='both',direction='in') plt.subplot(144) plt.minorticks_on() plt.text(0.5,0.5,'default') plt.show() 修改刻度线的长度和宽度 如上图，如果觉得刻度线太短，太细，不太显眼，我们可以修改其长短、粗细。依然使用函数tick_params，通过参数width和length控制。下面代码让左图的主刻度线粗一些，右图的次刻度线长一些。 plt.subplot(121) plt.minorticks_on() plt.tick_params(which='major',width=4) plt.subplot(122) plt.minorticks_on() plt.tick_params(which='minor',length=10) plt.show() 在哪些轴上显示刻度线 我们来看怎么控制刻度线出现在哪些轴上。这里用参数left，right,bottom,top`来控制，下面代码画出的图片，依次显示上下左右轴上的刻度线。(自己实验的，默认左边和下边是开启的 ) plt.subplot(1,4,1) plt.tick_params(top=True,bottom=False,left=False,right=False) plt.subplot(1,4,2) plt.tick_params(top=False,bottom=True,left=False,right=False) plt.subplot(1,4,3) plt.tick_params(top=False,bottom=False,left=True,right=False) plt.subplot(1,4,4) plt.tick_params(top=False,bottom=False,left=False,right=True) plt.show() 在哪些轴上显示刻度值 注意上面的图，刻度线分别出现在我们控制的坐标轴上，但是刻度值在默认情况下还是出现在左下两个轴上。这里仅说明如何让刻度值出现在相应刻度线的位置。比方，我们仅让上面的轴显示刻度线，也仅在该轴上显示刻度值，利用labelbottom, labeltop, labelleft, labelright四个参数控制，代码和图如下所示。 plt.tick_params(top=True,bottom=False,left=False,right=False) plt.tick_params(labeltop=True,labelleft=False,labelright=False,labelbottom=False) Update time： 2020-05-23 "},"Chapter1/MatplotlibMatplotlib 刻度线密度设置.html":{"url":"Chapter1/MatplotlibMatplotlib 刻度线密度设置.html","title":"Matplotlib：刻度线密度设置","keywords":"","body":"Matplotlib：刻度线密度设置 需要导入：from matplotlib.ticker import MultipleLocator, FormatStrFormatter模块 MultipleLocator 设置刻度的密度 FormatStrFormatter 设置刻度标签的格式 主刻度:（y轴同理） 倍数：ax.xaxis.set_major_locator(MultipleLocator(倍数)) 文本格式：ax.xaxis.set_major_formatter(FormatStrFormatter(’%占位数.小数点数f’)) 副刻度：（将\"major\"改为\"minor\"即可） 倍数：ax.xaxis.set_minor_locator(MultipleLocator(倍数)) 文本格式：ax.xaxis.set_minor_formatter(FormatStrFormatter(’%占位数.小数点数f’)) # 导入模块 import matplotlib.pyplot as plt from matplotlib.ticker import MultipleLocator, FormatStrFormatter import numpy as np # 数据 x = np.linspace(-30, 30, 100) y = x**2 # 绘图 plt.plot(x, y) ax = plt.gca() # 设置轴的主刻度 # x轴 ax.xaxis.set_major_locator(MultipleLocator(20)) # 设置20倍数 ax.xaxis.set_major_formatter(FormatStrFormatter('%5.3f')) # 设置文本格式 # y轴 ax.yaxis.set_major_locator(MultipleLocator(100)) # 设置100倍数 ax.yaxis.set_major_formatter(FormatStrFormatter('%1.2f')) # 设置文本格式 # 设置轴的副刻度 # x轴 ax.xaxis.set_minor_locator(MultipleLocator(5)) # 设置10倍数 # ax.xaxis.set_minor_formatter(FormatStrFormatter('%2.1f')) # 设置文本格式 # y轴 ax.yaxis.set_minor_locator(MultipleLocator(50)) # 设置50倍数 # ax.yaxis.set_minor_formatter(FormatStrFormatter('%1.0f')) # 设置文本格式 # 设置网格 ax.xaxis.grid(True, which='major') # x坐标轴的网格使用主刻度 ax.yaxis.grid(True, which='minor') # y坐标轴的网格使用次刻度 # 展示 plt.savefig('11.png') Update time： 2020-05-23 "},"Chapter1/Matplotlib：tick_params.html":{"url":"Chapter1/Matplotlib：tick_params.html","title":"Matplotlib：tick_params","keywords":"","body":"Matplotlib：tick_params tick_params 语法 Axes.tick_params(axis=‘both’, **kwargs) 参数： axis : {‘x’, ‘y’, ‘both’} Axis on which to operate; default is ‘both’. reset : bool If True, set all parameters to defaults before processing other keyword arguments. Default is False. which : {‘major’, ‘minor’, ‘both’} Default is ‘major’; apply arguments to which ticks. direction : {‘in’, ‘out’, ‘inout’} Puts ticks inside the axes, outside the axes, or both. length : float Tick length in points. width : float Tick width in points. color : color Tick color; accepts any mpl color spec. pad : float Distance in points between tick and label. labelsize : float or str Tick label font size in points or as a string (e.g., ‘large’). labelcolor : color Tick label color; mpl color spec. colors : color Changes the tick color and the label color to the same value: mpl color spec. zorder: float Tick and label zorder. bottom, top, left, right : bool or {‘on’, ‘off’} controls whether to draw the respective ticks. labelbottom, labeltop, labelleft, labelright : bool or {‘on’, ‘off’} controls whether to draw the respective tick labels. labelrotation : float Tick label rotation 参数axis 参数axis的值为 ’ x’、‘y’、‘both’，分别代表设置X轴、Y轴以及同时设置，默认值为’both’。 import numpy as np import matplotlib.pyplot as plt plt.subplot(131) plt.tick_params(axis='x',width=4,colors='red') plt.subplot(132) plt.tick_params(axis='y',width=4,colors='red') plt.subplot(133) plt.tick_params(axis='both',width=4,colors='red') plt.show() 参数 which 参数which的值为 'major'、'minor'、'both'，分别代表设置主刻度线、副刻度线以及同时设置，默认值为'major' 首先开启副刻度线`plt.minorticks_on()` plt.subplot(131) plt.minorticks_on() plt.tick_params(which='major',width=2,colors='r') plt.subplot(132) plt.minorticks_on() plt.tick_params(which='minor',width=2,colors='r') plt.subplot(133) plt.minorticks_on() plt.tick_params(which='both',width=2,colors='r') plt.show() 参数direction direction的值为'in'、'out'、'inout'，分别代表刻度线显示在绘图区内侧、外侧以及同时显示 plt.subplot(131) plt.minorticks_on() plt.tick_params(direction='in', width=2, length=4, colors='r') plt.subplot(132) plt.minorticks_on() plt.tick_params(direction='out', width=2, length=4, colors='r') plt.subplot(133) plt.minorticks_on() plt.tick_params(direction='inout', width=2, length=4, colors='r') plt.show() ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190924192705350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hIRzIwMTcxMjI2,size_16,color_FFFFFF,t_70) 参数 length和width 参数length和width分别用于设置刻度线的长度和宽度 plt.subplot(121) plt.tick_params(width=4, colors='red') plt.subplot(122) plt.tick_params(length=10,colors='red') plt.show() 参数 pad 参数pad用于设置刻度线与标签间的距离 plt.subplot(121) plt.tick_params(pad=1, colors='red') plt.subplot(122) plt.tick_params(pad=10,colors='red') plt.show() 参数color、labelcolor、colors 参数color、labelcolor、colors分别用于设置刻度线的颜色、刻度线标签的颜色以及同时设置刻度线及标签颜色 plt.subplot(131) plt.tick_params(width=4,color='r') plt.subplot(132) plt.tick_params(width=4,labelcolor='r') plt.subplot(133) plt.tick_params(width=4,colors='r') plt.show() 参数 labelsize 参数labelsize用于设置刻度线标签的字体大小 plt.subplot(131) plt.tick_params(labelsize='medium') plt.subplot(132) plt.tick_params(labelsize='large') plt.subplot(133) plt.tick_params(labelsize=15) plt.show() 参数bottom, top,left, right 参数bottom, top, left, right的值为布尔值，分别代表设置绘图区四个边框线上的的刻度线是否显示 plt.subplot(131) plt.tick_params(bottom=False,top=True,width=4,colors='r') plt.subplot(132) plt.tick_params(left=False,right=True,width=4,colors='r') plt.subplot(133) plt.tick_params(top=True,right=True,width=4,colors='r') 参数labelbottom,labeltop, labelleft, labelright 参数labelbottom, labeltop, labelleft, labelright的值为布尔值，分别代表设置绘图区四个边框线上的刻度线标签是否显示 plt.subplot(131) plt.tick_params(labelbottom=False,labeltop=True,width=4,colors='r') plt.subplot(132) plt.tick_params(labelleft=False,labelright=True,width=4,colors='r') plt.subplot(133) plt.tick_params(labeltop=True,labelright=True,width=4,colors='r') 参数 labelrotation 标签旋转 plt.subplot(121) plt.tick_params(axis=\"x\",labelrotation=60) plt.subplot(122) plt.tick_params(axis=\"x\",labelrotation=-60) Update time： 2020-05-23 "},"Chapter1/Matplotlib axes脊柱_坐标轴.html":{"url":"Chapter1/Matplotlib axes脊柱_坐标轴.html","title":"Matplotlib：axes脊柱(坐标轴)","keywords":"","body":"Matplotlib：axes脊柱(坐标轴) 设置坐标轴范围 plt.xlim()、plt.ylim() 另外也可以使用plt.axis([xmin, xmax, ymin, ymax])确定坐标值的范围 面向对象的方法 ax.set_xlim() ax.set_ylim () 设置坐标轴的范围可以通过axis(),xlim()和ylim()三个来设置，axis()用来同时设置x轴和y轴，后面的两个都是针对于特定的坐标轴而言。 matplotlib.pyplot.xlim(*args, **kwargs) 有两种参数输入方式 plt.xlim(num1, num2) plt.xlim(xmin=num1,xmax=num2) matplotlib.pyplot.axis(*v, **kwargs) 参数详解： xmin, xmax, ymin, ymax : float, optional pyplot.axis([1,2,2,4]) 设置坐标轴名称 plt.xlabel()、plt.ylabel() 设置坐标轴名称 面向对象的方法 ax.set_xlabel() ax.set_ylabel() 设置坐标轴刻度标签 plt.xticks、plt.yticks设置坐标轴刻度 面向对象的方法 ax.set_xticklabel() ax.set_yticklabel() matplotlib.pyplot.xticks(ticks=None, labels=None, *kwargs) 参数 ticksarray-like, optional The list of xtick locations. Passing an empty list removes all xticks. labelsarray-like, optional The labels to place at the given ticks locations. This argument can only be passed if ticks is passed as well. kwargs Text properties can be used to control the appearance of the labels. 常用的文本属性有 fontsize color rotation 等 显示数字标签 plt.plot() plt.xticks( np.arange(5) ) 显示x轴的刻标以及对应的标签 plt.plot() plt.xticks( np.arange(5), ['Tom', 'Dick', 'Harry', 'Sally', 'Sue'] ) x = np.linspace(-3, 3, 50) y1 = 2*x + 1 y2 = x**2 plt.figure() plt.plot(x, y2) plt.plot(x, y1, color='red', linewidth=1.0, linestyle='--') plt.xlim((-1, 2)) plt.ylim((-2, 3)) plt.xlabel('I am x') plt.ylabel('I am y') new_ticks = np.linspace(-1, 2, 5) plt.xticks(new_ticks) plt.yticks([-2, -1.8, -1, 1.22, 3], [r'$really\\ bad$', r'$bad$', r'$normal$', r'$good$', r'$really\\ good$']) 设置axes脊柱(坐标系) 属性列表 去掉脊柱(坐标系) ax.spines[‘top’].set_visible(False) #去掉上边框 ax.spines[‘bottom’].set_visible(False) #去掉下边框 ax.spines[‘left’].set_visible(False) #去掉左边框 ax.spines[‘right’].set_visible(False) #去掉右边框 plt.tick_params(axis=\"x\",labelrotation=-60) ax=plt.gca() #获取对象 ax.spines['top'].set_visible(False) #去掉上边框 移动脊柱 ax.spines[‘right’].set_color(‘none’) ax.spines[‘top’].set_color(‘none’) ax.xaxis.set_ticks_position(‘bottom’) # 刻度的显示位置 ax.spines[‘bottom’].set_position((‘data’,0)) ax.yaxis.set_ticks_position(‘left’) ax.spines[‘left’].set_position((‘data’,0)) plt.tick_params(axis=\"x\",labelrotation=-60) ax=plt.gca() ax.spines['top'].set_visible(False) #去掉上边框 ax.spines['right'].set_visible(False) #去掉上边框 # 设置 bottom 的位置在 left 0.8处 ax.spines['bottom'].set_position(('data',0.8)) plt.tick_params(axis=\"x\",labelrotation=-60) ax=plt.gca() ax.spines['top'].set_visible(False) #去掉上边框 ax.spines['right'].set_visible(False) #去掉上边框 # 设置ticks 显示在top 处 ax.xaxis.set_ticks_position('top') ax.spines['bottom'].set_position(('data',0.8)) 设置边框线颜色 ax = plt.gca() # 获取当前的axes ax.spines['right'].set_color('blue') ax.spines['top'].set_color('none') 设置边框线宽 ax1.spines['left'].set_linewidth(5) 设置边框线型 ax.spines['left'].set_linestyle('--') 设置反方向x轴(y轴同理) ax.invert_xaxis() # x轴反向 plt.tick_params(axis=\"x\",labelrotation=-60) ax=plt.gca() ax.spines['top'].set_visible(False) #去掉上边框 ax.spines['right'].set_visible(False) #去掉上边框 ax.xaxis.set_ticks_position('bottom') ax.spines['bottom'].set_position(('data',0.5)) ax.invert_xaxis() # x轴反向 gca():获取当前坐标轴信息 .spines:设置边框 .set_color:设置边框颜色：默认白色 .spines:设置边框 .xaxis.set_ticks_position:设置x坐标刻度数字或名称的位置 .yaxis.set_ticks_position:设置y坐标刻度数字或名称的位置 .set_position:设置边框位置 案例 # 导入模块 import matplotlib.pyplot as plt import numpy as np # 数据 x = np.linspace(-10, 10, 100) y = x**2 # 绘图 plt.plot(x, y) ax = plt.gca() # ===设置脊(边框)=== # 1.隐藏上与右的边框 ax.spines['top'].set_visible(False) ax.spines['right'].set_color(None) # 2.设置颜色 ax.spines['left'].set_color('b') ax.spines['bottom'].set_color('r') # 3.设置线宽 ax.spines['left'].set_linewidth(5) ax.spines['bottom'].set_linewidth(3) # 4.设置线形 ax.spines['left'].set_linestyle('--') ax.spines['left'].set_linestyle('-.') # 5.设置交点位置（0， 35） ax.spines['left'].set_position(('data', 0)) ax.spines['bottom'].set_position(('data', 35)) # 6.设置数据显示的位置 #ax.xaxis.set_ticks_position('bottom') #ax.yaxis.set_ticks_position('right') # 7.设置反方向(y轴同理) ax.invert_xaxis() # x轴反向 # 导入模块 import matplotlib.pyplot as plt import numpy as np # 数据 x = np.linspace(-10, 10, 100) y = x**2 # 绘图 plt.plot(x, y) ax = plt.gca() # ===设置脊(边框)=== # 1.隐藏上与右的边框 ax.spines['top'].set_visible(False) ax.spines['right'].set_color(None) # 2.设置颜色 ax.spines['left'].set_color('b') ax.spines['bottom'].set_color('r') # 3.设置线宽 ax.spines['left'].set_linewidth(5) ax.spines['bottom'].set_linewidth(3) # 4.设置线形 ax.spines['left'].set_linestyle('--') ax.spines['left'].set_linestyle('-.') # 5.设置交点位置（0， 35） ax.spines['left'].set_position(('data', 0)) ax.spines['bottom'].set_position(('data', 35)) # 6.设置数据显示的位置 ax.xaxis.set_ticks_position('bottom') ax.yaxis.set_ticks_position('right') # 7.设置反方向(y轴同理) ax.invert_xaxis() # x轴反向 将坐标轴移到中间，即笛卡尔坐标轴。路径：将图形上，右边隐藏，将下，左边移动到中间，需要用到gac函数获取Axes对象，接着通过这个对象指定每条边的位置，使用set_color设置成none。实现代码如下： x = np.arange(-2*np.pi,2*np.pi,0.01)#定义横轴范围 y = np.sin(3*x)/x#函数 y2 = np.sin(2*x)/x y3 = np.sin(x)/x plt.plot(x,y)#绘制,matplotlib默认展示不同的颜色 plt.plot(x,y2,'--') plt.plot(x,y3) plt.xticks([-2*np.pi,-np.pi,0,np.pi,2*np.pi],[r'$-2\\pi$',r'$\\pi$','$0$','$\\pi$','$2\\pi$'])#显示横坐标刻度值，不加第二个参数，将显示的是数值而不是字母 plt.yticks([-1,0,1,2,3],[r'$-1$','$0$','$+1$','$+2$','$+3$']) plt.legend(['y','y2','y3']) plt.title('M10') ax = plt.gca()#使用gca函数获取axes对象 ax.spines['right'].set_color('none')#右侧边隐藏 ax.spines['top'].set_color('none') ax.xaxis.set_ticks_position('bottom')#将底边设为横坐标 ax.spines['bottom'].set_position(('data',0))#将坐标置于坐标0处 ax.yaxis.set_ticks_position('left')#左边设置为纵坐标 ax.spines['left'].set_position(('data',0)) Update time： 2020-05-23 "},"Chapter1/坐标轴标签设置.html":{"url":"Chapter1/坐标轴标签设置.html","title":"坐标标签设置","keywords":"","body":"坐标标签设置 Update time： 2020-05-23 "},"Chapter1/坐标轴显示范围设置.html":{"url":"Chapter1/坐标轴显示范围设置.html","title":"坐标轴显示范围设置","keywords":"","body":"坐标轴显示范围设置 Update time： 2020-05-23 "},"Chapter1/设置水平参考线和垂直参考线.html":{"url":"Chapter1/设置水平参考线和垂直参考线.html","title":"设置水平参考线和垂直参考线","keywords":"","body":"设置水平参考线和垂直参考线 axhline() / axvline() ax ~ axis h ~ horizontal，水平的 v ~ vertical，垂直的 组合起来看，这两个函数分别用于设置水平参考线和垂直参考线。 Update time： 2020-05-23 "},"Chapter1/设置平行于x轴-y轴的参考区域.html":{"url":"Chapter1/设置平行于x轴-y轴的参考区域.html","title":"设置平行于x轴/y轴的参考区域","keywords":"","body":"设置平行于x轴/y轴的参考区域 axhspan() / axvspan() ax ~ axis h ~ horizontal，水平的 v ~ vertical，垂直的 span ~ 跨度，区间，范围 这两个函数分别用于设置平行于x轴/y轴的参考区域。 import matplotlib.pyplot as plt import numpy as np # 生成数据 x = np.linspace(0, 10, 100) y = np.sin(x) # 使用scatter绘图 plt.plot(x, y, ls='-.', lw=2, c='c', label='sin(x)') plt.legend() # xmin/xmax/ymin/ymax用于设置区间范围 # facecolor用于设置区域颜色 # alpha用于设置透明度 plt.axhspan(ymin=-0.25, ymax=0.25, facecolor='purple', alpha=0.3) plt.axvspan(xmin=4, xmax=6, facecolor='g', alpha=0.3) plt.show() import matplotlib.pyplot as plt fig, ax = plt.subplots() ax.plot(range(20)) ax.axvspan(8, 14, ymin=0.1, ymax=0.9, alpha=0.5, color='red') plt.show() Update time： 2020-05-23 "},"Chapter1/axes脊柱.html":{"url":"Chapter1/axes脊柱.html","title":"axes脊柱(坐标系)设置","keywords":"","body":"axes脊柱(坐标系)设置 ax = plt.gca() # 获取当前的axes 属性列表 去掉脊柱(坐标系) ax.spines[‘top’].set_visible(False) #去掉上边框 ax.spines[‘bottom’].set_visible(False) #去掉下边框 ax.spines[‘left’].set_visible(False) #去掉左边框 ax.spines[‘right’].set_visible(False) #去掉右边框 移动脊柱 ax.spines[‘right’].set_color(‘none’) ax.spines[‘top’].set_color(‘none’) ax.xaxis.set_ticks_position(‘bottom’) ##刻度的显示位置(轴的下面/上面) ax.spines[‘bottom’].set_position((‘data’,0)) ax.yaxis.set_ticks_position(‘left’) ax.spines[‘left’].set_position((‘data’,0)) plt.tick_params(axis=\"x\",labelrotation=-60) ax=plt.gca() ax.spines['top'].set_visible(False) #去掉上边框 ax.spines['right'].set_visible(False) #去掉上边框 ax.xaxis.set_ticks_position('bottom') ax.spines['bottom'].set_position(('data',0.5)) 设置边框线颜色 ax = plt.gca() # 获取当前的axes ax.spines['right'].set_color('blue') ax.spines['top'].set_color('none') 设置边框线宽 ax1.spines['left'].set_linewidth(5) 设置边框线型 ax.spines['left'].set_linestyle('--') 设置反方向x轴(y轴同理) ax.invert_xaxis() # x轴反向 plt.tick_params(axis=\"x\",labelrotation=-60) ax=plt.gca() ax.spines['top'].set_visible(False) #去掉上边框 ax.spines['right'].set_visible(False) #去掉上边框 ax.xaxis.set_ticks_position('bottom') ax.spines['bottom'].set_position(('data',0.5)) ax.invert_xaxis() # x轴反向 示例： # 导入模块 import matplotlib.pyplot as plt import numpy as np # 数据 x = np.linspace(-10, 10, 100) y = x**2 # 绘图 plt.plot(x, y) ax = plt.gca() # ===设置脊(边框)=== # 1.隐藏上与右的边框 ax.spines['top'].set_visible(False) ax.spines['right'].set_color(None) # 2.设置颜色 ax.spines['left'].set_color('b') ax.spines['bottom'].set_color('r') # 3.设置线宽 ax.spines['left'].set_linewidth(5) ax.spines['bottom'].set_linewidth(3) # 4.设置线形 ax.spines['left'].set_linestyle('--') ax.spines['left'].set_linestyle('-.') # 5.设置交点位置（0， 35） ax.spines['left'].set_position(('data', 0)) ax.spines['bottom'].set_position(('data', 35)) # 6.设置数据显示的位置 #ax.xaxis.set_ticks_position('bottom') #ax.yaxis.set_ticks_position('right') # 7.设置反方向(y轴同理) ax.invert_xaxis() # x轴反向 # 展示 plt.show() 将坐标轴移到中间，即笛卡尔坐标轴。路径：将图形上，右边隐藏，将下，左边移动到中间，需要用到gca函数获取Axes对象，接着通过这个对象指定每条边的位置，使用set_color设置成none。 Update time： 2020-05-23 "},"Chapter1/Matplotlib subplots绘制多子图.html":{"url":"Chapter1/Matplotlib subplots绘制多子图.html","title":"Matplotlib:subplots绘制多子图","keywords":"","body":"Matplotlib:subplots绘制多子图 调整子图间距和整体空白 fig.tight_layout()#调整整体空白 plt.subplots_adjust(wspace =0, hspace =0)#调整子图间距 创建一个图像对象（figure） 和 一系列的子图（subplots）。 def subplots(nrows=1, ncols=1, sharex=False, sharey=False, squeeze=True, subplot_kw=None, gridspec_kw=None, **fig_kw): # 返回值 return fig, axs 参数 nrows ，ncols ：子图的行列数。 sharex , sharey ： 设置为 True 或者 all 时，所有子图共享 x 轴或者 y 轴， 设置为 False or none 时，所有子图的 x，y 轴均为独立， 设置为 row 时，每一行的子图会共享 x 或者 y 轴， 设置为 col 时，每一列的子图会共享 x 或者 y 轴。 squeeze ： 默认为 True，是设置返回的子图对象的数组格式。 当为 False 时，不论返回的子图是只有一个还是只有一行，都会用二维数组格式返回他的对象。 当为 True 时，如果设置的子图是（nrows=ncols=1），即子图只有一个，则返回的子图对象是一个标量的形式，如果子图有（N×1）或者（1×N）个，则返回的子图对象是一个一维数组的格式，如果是（N×M）则是返回二位格式。 subplot_kw : 字典格式，传递给 add_subplot() ，用于创建子图。 gridspec_kw ：字典格式，传递给 GridSpec 的构造函数，用于创建子图所摆放的网格。 class matplotlib.gridspec.GridSpec(nrows, ncols, figure=None, left=None, bottom=None, right=None, top=None, wspace=None, hspace=None, width_ratios=None, height_ratios=None) 所有其他关键字参数都传递给 figure（）调用。如，设置 figsize=(21, 12) ，则设置了图像大小。 返回值 fig ： matplotlib.figure.Figure对象 ax ：子图对象（ matplotlib.axes.Axes）或者是他的数组 fig, axes = plt.subplots(23) ：即表示一次性在 figure 上创建成2*3的网格 规则划分 import matplotlib.pyplot as plt import numpy as np x = np.linspace(0, 2 * np.pi, 400) y = np.sin(x ** 2) # 创建一个子图 fig, ax = plt.subplots() ax.plot(x, y) ax.set_title('Simple plot') plt.show() 创建两个子图，并且共享y轴 f, (ax1, ax2) = plt.subplots(1, 2, sharey=True) ax1.plot(x, y) ax1.set_title('Sharing Y axis') ax2.scatter(x, y) 创建4个子图 fig, axes = plt.subplots(2, 2, subplot_kw=dict(polar=True))# polar:极地 axes[0, 0].plot(x, y) axes[1, 1].scatter(x, y) 共享每列子图的x轴 plt.subplots(2, 2, sharex='col') 共享每行子图的y轴 plt.subplots(2, 2, sharey='row') 共享所有子图的 x 和 y 轴 # plt.subplots(2, 2, sharex='all', sharey='all') plt.subplots(2, 2, sharex=True, sharey=True) 不规则划分 import numpy as np import matplotlib.pyplot as plt def f(t): return np.exp(-t) * np.cos(2*np.pi*t) t1 = np.arange(0.0, 3.0, 0.01) ax2 = plt.subplot(221) ax2.margins(2, 2) # Values >0.0 zoom out ax2.plot(t1, f(t1)) ax2.set_title('Zoomed out') ax3 = plt.subplot(222) ax3.margins(x=0, y=-0.25) # Values in (-0.5, 0.0) zooms in to center ax3.plot(t1, f(t1)) ax3.set_title('Zoomed in') ax1 = plt.subplot(212) ax1.margins(0.05) # Default margin is 0.05, value 0 means fit ax1.plot(t1, f(t1)) plt.show() 分成 2x2，占用第一个，即第一行第一列的子图 plt.subplot(221) 分成 2x2，占用第二个，即第一行第二列的子图 plt.subplot(222) 分成 2x1，占用第二个，即第二行 plt.subplot(212) 通过GridSpec来定制Subplot的坐标 GridSpec 指定子图所放置的几何网格。 SubplotSpec 在 GridSpec 中指定子图（subplot）的位置 subplot2grid 类似于 pyplot.subplot ，但是它从0开始索引 ax = plt.subplot2grid((2,2),(0, 0)) ax = plt.subplot(2,2,1) 以上两行的子图（subplot）命令是相同的。subplot2grid 使用的命令类似于HTML语言。 ax1 = plt.subplot2grid((3,3), (0,0), colspan=3) ax2 = plt.subplot2grid((3,3), (1,0), colspan=2) ax3 = plt.subplot2grid((3,3), (1, 2), rowspan=2) ax4 = plt.subplot2grid((3,3), (2, 0)) ax5 = plt.subplot2grid((3,3), (2, 1)) 参考 subplot 子图 Update time： 2020-05-23 "},"Chapter1/调整子图间距,调整整体空白.html":{"url":"Chapter1/调整子图间距,调整整体空白.html","title":"调整子图间距,调整整体空白","keywords":"","body":"调整子图间距,调整整体空白 matplotlib.pyplot.subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=None, hspace=None ) # 参数 left = 0.125 # 子图(subplot)距画板(figure)左边的距离 right = 0.9 # 右边 bottom = 0.1 # 底部 top = 0.9 # 顶部 wspace = 0.2 # 子图水平间距 hspace = 0.2 # 子图垂直间距 fig,ax = plt.subplots(2,4,figsize=(14,6),sharey=True,sharex=True) plt.subplots_adjust(left=0.125, bottom=0.125, right=0.9, top=0.9, wspace=None, hspace=0.3) for i,a in enumerate(ax.flat): # print(i) a.scatter(x=data.groupby('year').get_group(2012+i)['stage'] ,y=data.groupby('year').get_group(2012+i)['discharge'] ,s=5) a.set_title(2012+i,fontsize=18) a.xaxis.set_major_locator(MultipleLocator(2)) # 设置20倍数 a.xaxis.set_tick_params(which='major',length=4,labelsize=12) a.yaxis.set_tick_params(which='major',length=4,labelsize=12) plt.savefig('o1.jpeg',dpi=600,transparent=True,bbox_inches='tight' ) # plt.show() Update time： 2020-08-04 "},"Chapter1/[Matplotlib 线型、标记.html":{"url":"Chapter1/[Matplotlib 线型、标记.html","title":"Matplotlib：线型、标记","keywords":"","body":"Matplotlib：线型、标记 ﻿在Python中用matplotlib画图的时候，为了区分曲线的类型，给曲线上面加一些标识或者颜色。以下是颜色和标识的汇总。 颜色（color简写为 c）： 蓝色： 'b' (blue) 绿色： 'g' (green) 红色： 'r' (red) 蓝绿色(墨绿色)： 'c' (cyan) 红紫色(洋红)： 'm' (magenta) 黄色： 'y' (yellow) 黑色： 'k' (black) 白色： 'w' (white) 灰度表示： e.g. 0.75 ([0,1]内任意浮点数) RGB表示法： e.g. '#2F4F4F' 或 (0.18, 0.31, 0.31) 任意合法的html中的颜色表示： e.g. 'red', 'darkslategray' 线型（linestyle 简写为 ls）： 实线： '-' 虚线： '--' 虚点线： '-.' 点线： ':' 点： '.' 点型（标记marker）： 像素： ',' 圆形： 'o' 上三角： '^' 下三角： 'v' 左三角： ' 右三角： '>' 方形： 's' 加号： '+' 叉形： 'x' 棱形： 'D' 细棱形： 'd' 三脚架朝下： '1'（就是丫） 三脚架朝上： '2' 三脚架朝左： '3' 三脚架朝右： '4' 六角形： 'h' 旋转六角形： 'H' 五角形： 'p' 垂直线： '|' 水平线： '_' gnuplot 中的steps： 'steps' （只能用于kwarg中） 标记大小（markersize简写为ms）： markersize： 实数 标记边缘宽度（markeredgewidth简写为 mew）： markeredgewidth：实数 标记边缘颜色（markeredgecolor 简写为mec`）： markeredgecolor：颜色选项中的任意值 标记表面颜色（markerfacecolor 简写为 mfc）： markerfacecolor：颜色选项中的任意值 透明度（alpha）： alpha： [0,1]之间的浮点数 线宽（linewidth）： linewidth： 实数 Update time： 2020-05-23 "},"Chapter1/Matplotlib 图形填充.html":{"url":"Chapter1/Matplotlib 图形填充.html","title":"Matplotlib：图形填充","keywords":"","body":"Matplotlib：图形填充 ﻿区域填充函数有 fill(*args, **kwargs)和fill_between() 绘制填充多边形fill() 语法结构 fill(*args, **kwargs) args - sequence of x, y, [color] ax.fill(x, y) # a polygon with default color ax.fill(x, y, \"b\") # a blue polygon ax.fill(x, y, x2, y2) # two polygons ax.fill(x, y, \"b\", x2, y2, \"r\") # a blue and a red polygon kwargs - 对象matplotlib.patches.Polygon的特性（class:~matplotlib.patches.Polygon properties） 示例 import numpy as np import matplotlib.pyplot as plt x = np.linspace(0, 5 * np.pi, 1000) y1 = np.sin(x) y2 = np.sin(2 * x) plt.plot(x, y1, label=\"$ y = sin(x) $\") plt.plot(x, y2, label=\"$ y = sin(2 * x) $\") plt.legend(loc=3) plt.show() 绘制填充图 import numpy as np import matplotlib.pyplot as plt x = np.linspace(0, 5 * np.pi, 1000) y1 = np.sin(x) y2 = np.sin(2 * x) plt.fill(x, y1, color=\"g\", alpha=0.3) plt.fill(x, y2, color=\"b\", alpha=0.3) plt.show() 函数间区域填充fill_between 基本语法 两函数间的Y轴方向的填充 plt.fill_between( x, y1, y2=0, where=None, interpolate=False, step=None, hold=None, data=None, **kwargs ) x - array( length N) 定义曲线的 x 坐标 y1 - array( length N ) or scalar 定义第一条曲线的 y 坐标 y2- array( length N ) or scalar 定义第二条曲线的 y 坐标 where - array of bool (length N), optional, default: None 排除一些（垂直）区域被填充。 注：我理解的垂直区域，但帮助文档上写的是horizontal regions 也可简单地描述为 plt.fill_between(x，y1，y2，where=条件表达式, color=颜色，alpha=透明度) \" where = \" 可以省略，直接写条件表达式 示例 import numpy as np import matplotlib.pyplot as plt x = np.linspace(0, 5 * np.pi, 1000) y1 = np.sin(x) y2 = np.sin(2 * x) plt.plot(x, y1, c=\"g\") plt.plot(x, y2, c='r') # 将两函数间区域填充成浅灰色 plt.fill_between(x, y1, y2, facecolor=\"lightgray\") plt.show() 我们看到，其实只要介于两函数值之间的区域均被 lightgray 颜色填充了。 进一步通过where = 条件表达式（这里的 where = 省略了 ）该表图形 “ 形貌 ” 。 import numpy as np import matplotlib.pyplot as plt n = 1000 x = np.linspace(0, 8 * np.pi, n) sin_y = np.sin(x) cos_y = np.cos(x / 2) / 2 plt.figure('Fill', facecolor='lightgray') plt.title('Fill', fontsize=20) plt.xlabel('x', fontsize=14) plt.ylabel('y', fontsize=14) plt.tick_params(labelsize=10) plt.grid(linestyle=':') # 把正弦余弦两条曲线画出 plt.plot(x, sin_y, c='dodgerblue', label=r'$y=sin(x)$') plt.plot(x, cos_y, c='orangered', label=r'$\\frac{1}{2}cos(\\frac{x}{2})$') # 填充 plt.fill_between(x, cos_y, sin_y, cos_y sin_y, color='orangered', alpha=0.5) plt.legend(loc = 3) plt.show() 指定区间填充 # 填充 plt.fill_between(x, cos_y, sin_y, where=(cos_y sin_y)&(15 import numpy as np import matplotlib.pyplot as plt # 生成模拟数据 x = np.arange(0.0, 4.0 * np.pi, 0.01) y = np.sin(x) # 绘制正弦曲线 plt.plot(x, y) # 绘制基准水平直线 plt.plot((x.min(), x.max()), (0, 0)) # 设置坐标轴标签 plt.xlabel('x') plt.ylabel('y') # 填充指定区域 plt.fill_between(x, y, where=(2.3 10), facecolor='purple') # 可以填充多次 plt.fill_between(x, y, where=(7 使用fill_betweenx在两条水平曲线之间着色。 def fill_betweenx(self, y, x1, x2=0, where=None, step=None, interpolate=False, **kwargs): \"\"\" Fill the area between two vertical curves. The curves are defined by the points (*x1*, *y*) and (*x2*, *y*). This creates one or multiple polygons describing the filled area. You may exclude some vertical sections from filling using *where*. By default, the edges connect the given points directly. Use *step* if the filling should be a step function, i.e. constant in between *y*. Parameters ---------- y : array (length N) The y coordinates of the nodes defining the curves. x1 : array (length N) or scalar The x coordinates of the nodes defining the first curve. x2 : array (length N) or scalar, optional, default: 0 The x coordinates of the nodes defining the second curve. where : array of bool (length N), optional, default: None Define *where* to exclude some vertical regions from being filled. The filled regions are defined by the coordinates ``y[where]``. More precisely, fill between ``y[i]`` and ``y[i+1]`` if ``where[i] and where[i+1]``. Note that this definition implies that an isolated *True* value between two *False* values in *where* will not result in filling. Both sides of the *True* position remain unfilled due to the adjacent *False* values. import matplotlib.pyplot as plt import numpy as np y = np.arange(0.0, 2, 0.01) x1 = np.sin(2 * np.pi * y) x2 = 1.2 * np.sin(4 * np.pi * y) fig, [ax1, ax2, ax3] = plt.subplots(3, 1, sharex=True) ax1.fill_betweenx(y, 0, x1) ax1.set_ylabel('(x1, 0)') ax2.fill_betweenx(y, x1, 1) ax2.set_ylabel('(x1, 1)') ax3.fill_betweenx(y, x1, x2) ax3.set_ylabel('(x1, x2)') ax3.set_xlabel('x') plt.show() fill_betweenx 的范围是纵坐标上 fill_betweeny 的范围是横坐标上 fill_betweenx 的参数应该输入（纵坐标的下限，纵坐标的上限，x 轴上的取值，颜色 Update time： 2020-05-23 "},"Chapter1/Matplotlib grid栅格设置.html":{"url":"Chapter1/Matplotlib grid栅格设置.html","title":"Matplotlib:grid栅格设置","keywords":"","body":"Matplotlib:grid栅格设置 栅格设置 打开栅格:plt.grid(true) 函数 matplotlin.pyplot.grid(b, which, axis, color, linestyle, linewidth， **kwargs ) b: 布尔值。就是是否显示网格线的意思。官网说如果b设置为None， 且kwargs长度为0，则切换网格状态。但是没弄明白什 么意思。如果b设置为None，但是又给了其它参数，则默认None值失效。 which : 取值为major, minor， both。 默认为’major’。显示主刻度、副刻度、全部显示网格 axis: 取值为both，x，y。就是想绘制哪个方向的网格线。 color : 就是设置网格线的颜色。或者直接用 c 来代替 color 也可以。 linestyle :也可以用ls来代替linestyle， 设置网格线的风格，是连续实线，虚线或者其它不同的线条。 | ‘-’ | ‘–’ | ‘-.’ | ‘:’ | ‘None’ | ’ ’ | ‘’] linewidth : 设置网格线的宽度 alpha:设置透明度 参数 axis fig,ax = plt.subplots(1,3) ax[0].grid(axis=\"x\") ax[1].grid(axis=\"y\") ax[2].grid(axis=\"both\") Update time： 2020-05-23 "},"Chapter1/Matplotlib text注释.html":{"url":"Chapter1/Matplotlib text注释.html","title":"Matplotlib text注释","keywords":"","body":"Matplotlib text注释 matplotlib.pyplot.text(x, y, s, fontdict=None, withdash=False, **kwargs) 参数 x, y：表示坐标； s：字符串文本； fontdict：字典，可选, 文字属性； family: 字体优先级列表 ‘serif’, ‘sans-serif’, ‘cursive’, ‘fantasy’, ‘monospace’ style: 字体风格 ‘normal’, ‘italic’ , ‘oblique’. weight: 字体粗细，0-1000之间数字或者 ‘ultralight’, ‘light’, ‘normal’, ‘regular’, ‘book’, ‘medium’, ‘roman’, ‘semibold’, ‘demibold’, ‘demi’, ‘bold’, ‘heavy’, ‘extra bold’, ‘black’中的一个 size: 字体大小，‘xx-small’, ‘x-small’, ‘small’, ‘medium’, ‘large’, ‘x-large’, ‘xx-large’ 或者一个整数 backgroundcolor : 背景色 fontsize 字体大小 kw： fontsize=12, horizontalalignment=‘center’、 ha=’cener’ verticalalignment=’center’、 va=’center’ bbox 给字体添加框，如bbox=dict(facecolor='red', alpha=0.5)等，各种风格 alpha 设置框体的透明度， facecolor 设置框体的颜色 rotation 表示标签的旋转角度，以逆时针计算，取整 x = np.arange(-10, 11, 1) #形成一个数组，第三个参数表示步长，#start,end,step y = x ** 2 plt.plot(x, y) # 第一个参数是x轴坐标 # 第二个参数是y轴坐标 # 第三个参数是要显式的内容 # alpha 设置字体的透明度 # family 设置字体 # size 设置字体的大小 # style 设置字体的风格 # wight 字体的粗细 # bbox 给字体添加框，alpha 设置框体的透明度， facecolor 设置框体的颜色 plt.text(x=-3, y=80, s=\"function: $y = x * x$\", size = 15, alpha = 0.8) plt.text(x=-3, y=40, s=\"function: $y = x * x$\", size = 15,\\ family = \"fantasy\", color = \"r\", style = \"italic\", weight = \"light\",\\ bbox = dict(facecolor = \"r\", alpha = 0.2)) 添加数据标签 def showResult(xList, yList, title, xLabel, yLabel): plt.plot(xList, yList, 'g*-') plt.title(title) plt.xlabel(xLabel) plt.ylabel(yLabel) for x, y in zip(xList, yList): plt.text(x, y+0.3, str(y), ha='center', va='bottom', fontsize=10.5) plt.savefig('111.jpg') plt.show() x_arr = [1, 2, 3, 4, 5, 6] y_arr = [1, 4, 9, 16, 25, 36] showResult(x_arr, y_arr, 'title', 'x', 'y') 其中 for x, y in zip(xList, yList): plt.text(x, y+0.3, '%.0f'%y, ha='center', va='bottom', fontsize=10.5) 逐个获取需要标注的点的横纵坐标 x与 y，然后在位置 (x, y+0.3) 处以 10.5 的字体显示出 y 的值，‘center’ 和 ‘bottom’ 分别指水平和垂直方向上的对齐方式。 Update time： 2020-05-23 "},"Chapter1/Matplotlib Annotation注释.html":{"url":"Chapter1/Matplotlib Annotation注释.html","title":"Matplotlib：Annotation注释","keywords":"","body":"Matplotlib：Annotation注释 添加注释和箭头 plt.annotate() 添加注释 annotate() 参数 ：(1) s : 注释文本 (2) xy : 箭头坐标 (3) xytext: 文本坐标 (4) 字体设置等参数 (5) 设置箭头，arrowprops arrowprops : 是一个dict (字典) 第一种方式：{'width':宽度,'headwidth':箭头宽,facecolor,'headlength':箭头长, 'shrink':两端收缩总长度分数} facecolor：箭头颜色 shrink:箭头的长度（两坐标距离的比例，0~1） width:箭头的宽度 例如：arrowprops={'width':5,'headwidth':10,'headlength':10,'shrink':0.1} 第二种方式：'arrowstyle':样式 例如： 有关arrowstyle的样式：'-' 、'->'、''、'' 'fancy','simple','wedge' x = np.random.randint(0,30,size=10) x[5] = 30 # 把索引为5的位置改为30 plt.figure(figsize=(12,6)) plt.plot(x) plt.ylim([-2,35]) # 设置y轴的刻度 plt.annotate(s='this point is important',xy=(5,30),xytext=(6,31),fontsize=16, arrowprops={'arrowstyle':'->'}) Update time： 2020-05-23 "},"Chapter1/Matplotlib Legend图例.html":{"url":"Chapter1/Matplotlib Legend图例.html","title":"Matplotlib:Legend 图例","keywords":"","body":"Matplotlib:Legend 图例 图例legend基础语法及用法 matplotlib.pyplot.legend(*args, **kwargs) loc Location code string, or tuple (see below).图例所有figure位置 prop the font property字体参数 fontsize the font size (used only if prop is not specified) markerscale the relative size of legend markers vs. original 图例标记与原始标记的相对大小 markerfirst If True (default), marker is to left of the label. 如果为True，则图例标记位于图例标签的左侧 numpoints the number of points in the legend for line 为线条图图例条目创建的标记点数 scatterpoints the number of points in the legend for scatter plot 为散点图图例条目创建的标记点数 scatteryoffsets a list of yoffsets for scatter symbols in legend 为散点图图例条目创建的标记的垂直偏移量 frameon If True, draw the legend on a patch (frame). 控制是否应在图例周围绘制框架 fancybox If True, draw the frame with a round fancybox. 控制是否应在构成图例背景的FancyBboxPatch周围启用圆边 shadow If True, draw a shadow behind legend. 控制是否在图例后面画一个阴影 framealpha Transparency of the frame. 控制图例框架的 Alpha 透明度 edgecolor Frame edgecolor. facecolor Frame facecolor. ncol number of columns 设置图例分为n列展示 columnspacing the spacing between columns 列间距 borderpad the fractional whitespace inside the legend border 图例边框的内边距 labelspacing the vertical space between the legend entries 图例条目之间的垂直间距 handlelength the length of the legend handles 图例句柄的长度 handleheight the height of the legend handles 图例句柄的高度 handletextpad the pad between the legend handle and text 图例句柄和文本之间的间距 borderaxespad the pad between the axes and legend border 轴与图例边框之间的距离 title the legend title bbox_to_anchor the bbox that the legend will be anchored. 指定图例在轴的位置 bbox_transform the transform for the bbox. transAxes if None. 设置图例位置 使用 loc 参数 plt.legend(loc=‘lower left’) 设置图例字体 设置字体大小 fontsize : int or float or {‘xx-small’, ‘x-small’, ‘small’, ‘medium’, ‘large’, ‘x-large’, ‘xx-large’} plt.legend(fontsize=\"xx-large\") 设置图例边框及背景 plt.legend(loc='best',frameon=False) #去掉图例边框 plt.legend(loc='best',edgecolor='blue') #设置图例边框颜色 plt.legend(loc='best',facecolor='blue') #设置图例背景颜色,若无边框,参数无效 设置图例标题 plt.legend(loc='best',title='figure 1 legend') #去掉图例边框 案例：设置图例legend到图形边界外 bbox_to_anchor：表示legend的位置，前一个表示左右，后一个表示上下。当使用这个参数时。loc将不再起正常的作用，ncol=3表示图例三列显示。 首先按上面的方式，如果你想将图例放上面就box.height0.8，放右边就box.width0.8其它方式一样。 #主要是bbox_to_anchor的使用 box = ax1.get_position() # 调整图的位置 并压缩某一条轴 ax1.set_position([box.x0, box.y0, box.width , box.height* 0.8]) ax1.legend(loc='center', bbox_to_anchor=(0.5, 1.2),ncol=3) 案例：显示多图例 legend import matplotlib.pyplot as plt import numpy as np x = np.random.uniform(-1, 1, 4) y = np.random.uniform(-1, 1, 4) p1, = plt.plot([1, 2, 3]) p2, = plt.plot([3, 2, 1]) l1 = plt.legend([p2, p1], [\"line 2\", \"line 1\"], loc='upper left') p3 = plt.scatter(x[0:2], y[0:2], marker='D', color='r') p4 = plt.scatter(x[2:], y[2:], marker='D', color='g') # This removes l1 from the axes. plt.legend([p3, p4], ['label', 'label1'], loc='lower right', scatterpoints=1) # Add l1 as a separate artist to the axes plt.gca().add_artist(l1) plt.show() import matplotlib.pyplot as plt line1, = plt.plot([1,2,3], label=\"Line 1\", linestyle='--') line2, = plt.plot([3,2,1], label=\"Line 2\", linewidth=4) # 为第一个线条创建图例 first_legend = plt.legend(handles=[line1], loc=1) # 手动将图例添加到当前轴域 ax = plt.gca().add_artist(first_legend) # 为第二个线条创建另一个图例 plt.legend(handles=[line2], loc=4) plt.show() import pandas as pd import numpy as np import matplotlib.pyplot as plt fig = plt.figure(1) ax1 = fig.add_subplot(1,1,1) df1 = pd.DataFrame(np.random.randn(3,5),columns = ['one','two','three','four','five']) df1.plot(ax = ax1, title = \"df1\", grid = 'on') ax1.legend( loc='lower center', ncol=5,bbox_to_anchor=(0.5,-0.15), borderaxespad = 0. ,fontsize = 8) ##设置ax1中legend的位置，将其放在图外 plt.savefig('./o1.png',dpi=600) plt.show() Update time： 2020-05-23 "},"Chapter1/颜色库.html":{"url":"Chapter1/颜色库.html","title":"颜色库","keywords":"","body":" Update time： 2020-05-23 "},"Chapter1/图片保存.html":{"url":"Chapter1/图片保存.html","title":"图片保存","keywords":"","body":"图片保存 生成透明背景 plt.savefig('./变化.png'.format(last_data), bbox_inches='tight',transparent=True) # bbox_inches='tight' 图片边界空白紧致 # transparent=True 背景透明 指定图片大小和像素 plt.savefig(‘plot123_2.png’, dpi=200)#指定分辨率 #figsize(12.5, 4) # 设置 figsize plt.rcParams['savefig.dpi'] = 300 #图片像素 plt.rcParams['figure.dpi'] = 300 #分辨率 # 默认的像素：[6.0,4.0]，分辨率为100，图片尺寸为 600&400 # 指定dpi=200，图片尺寸为 1200*800 # 指定dpi=300，图片尺寸为 1800*1200 # 设置figsize可以在不改变分辨率情况下改变比例 Update time： 2020-05-23 "},"Chapter1/面向对象绘图.html":{"url":"Chapter1/面向对象绘图.html","title":"面向对象绘图","keywords":"","body":"面向对象绘图 ﻿# Matplotlib中图像的结构 atplotlib图像中最重要的三个对象分别是figure(画布)，ax(坐标系)，axis (坐标轴)。一个figure中可以有多个 ax（多个子图），figure可以设置图像的尺寸，背景色，像素等。一个ax中一般有多个 axis，如xaxis，yaxis。ax可以设置子图的大小，标题，数据的呈现形式，线型，颜色等。axis又有label，tick等对象，可以设置坐标轴刻度，坐标轴标签，坐标轴标题等。 面向对象绘图一般自上而下： 0，绘图前设置绘图风格等全局参数，例如style，font等。 1，开始绘图时，首先是figure对象布局，包括大小size，像素dpi等。 2， 接着是axes对象规划，包括图形(如点线柱饼)，axes区域(如背景颜色，栅格，图例)等。 3，然后是axis对象设置，包括坐标轴，刻度线，标签等。 4，最后是添加文字信息，包括标题，数据标注，其他文字说明等。 绘图前设置绘图风格等全局参数 例如style，font等。 # 查看可用的绘图风格 print(plt.style.available) # 选择绘图风格 plt.style.use('bmh') # 用来正常显示中文标签 plt.rcParams['font.sans-serif'] = ['FangSong'] # 指定默认字体 # 解决符号‘-’显示为方块的问题 plt.rcParams['axes.unicode_minus'] = False # 设置全局默认字体属性 font = {'weight': 'bold', 'size': 15} plt.rc('font', **font) 1，开始绘图时，首先是figure对象布局，包括大小figsize,像素dpi等。 参考 fig = plt.figure() 2，接着是axes对象规划，包括图形(如点线柱饼),axes区域(如背景颜色,栅格,图例)等。 ax = fig.add_subplot(111, facecolor=(0, 1, 0, 0.3)) # ax.figure(dpi=600) ax.plot(x, y, label='$sin(x)$', color='r', linestyle=\"-\", linewidth=3, marker=\"o\", markeredgecolor='g', markersize=8, markerfacecolor='red', alpha=0.8) # 网格设置 ax.grid(color='b', linestyle=':', linewidth=1) # 图例设置 ax.legend(loc='best', fontsize=18, frameon=True) plt.show() 3，然后是axis对象设置，包括坐标轴，刻度线，标签等。 # 坐标轴的范围 ax.axis([-0.5, 6.5, -1.1, 1.1]) # 设置刻度 ax.xaxis.set_ticks([0, np.pi / 2, np.pi, 3 * np.pi / 2, 2 * np.pi]) # 设置刻度标签 ax.xaxis.set_ticklabels(['$0$', '$\\\\frac{\\pi}{2}$', '$\\pi$', '$\\\\frac{3\\pi}{2}$', '$2\\,\\pi$' ]) # ax.set_xticks() # ax.set_xticklabels() # ax.xaxis.set_major_locator() # ax.xaxis.set_major_formatter() # 设置坐标轴标题 ax.set_xlabel('X ', fontsize=20) ax.set_ylabel('Y ', fontsize=20, rotation=0) # ax.xaxis.set_label_text('X',fontsize = 20) # ax.yaxis.set_label_text('y',fontsize = 20,rotation =0) # 设置坐标轴。标签的位置 ax.xaxis.set_label_coords(1,-0.05) ax.yaxis.set_label_coords(-0.05,1) # 设置坐标轴是否可见 ax.spines['right'].set_visible(False) #设置坐标轴颜色，当颜色为 none 时，坐标轴不可见 ax.spines['top'].set_color('none') ax.spines['bottom'].set_color('red') # 移动坐标轴的位置 ax.spines['left'].set_position((\"data\",0)) ax.spines['bottom'].set_position((\"data\",0)) 4，最后是添加文字信息，包括标题，数据标注，其他文字说明等。 # 设置标题 ax.set_title(u'正弦曲线',color='black',fontsize=20) # ax.annotate(-3.7, 3, r'$This\\ is\\ the\\ some\\ text. \\mu\\ \\sigma_i\\ \\alpha_t$', # ) # ax.text(0.85,0.75,'matplotlib\\n plot',fontsize=20, # horizontalalignment='center', # verticalalignment='center', # transform= ax.transAxes, # bbox=dict(facecolor='green',alpha=0.6)) fig.savefig(u'02020202.png',dpi=600) 其它方法; formatter = ticker.FormatStrFormatter('$%1.2f') ax.yaxis.set_major_formatter(formatter) case 1 import numpy as np import matplotlib.pyplot as plt import matplotlib.ticker as ticker # Fixing random state for reproducibility np.random.seed(19680801) fig, ax = plt.subplots() ax.plot(100*np.random.rand(20)) formatter = ticker.FormatStrFormatter('$%1.2f') ax.yaxis.set_major_formatter(formatter) for tick in ax.yaxis.get_major_ticks(): tick.label1.set_visible(False) tick.label2.set_visible(True) tick.label2.set_color('green') # ax.yaxis.get_major_ticks() 返回两个纵轴的坐标，label1，label2分别表示不同的轴 plt.show() Formatters and Locators 'Axis.get_major_formatter' Get the formatter of the major ticker 'Axis.get_major_locator' Get the locator of the major ticker 'Axis.get_minor_formatter' Get the formatter of the minor ticker 'Axis.get_minor_locator ' Get the locator of the minor ticker 'Axis.set_major_formatter' Set the formatter of the major ticker. 'Axis.set_major_locator ' Set the locator of the major ticker. 'Axis.set_minor_formatter' Set the formatter of the minor ticker. 'Axis.set_minor_locator' Set the locator of the minor ticker. from matplotlib.ticker import NullFormatter, FixedLocator ax.grid(True) ax.set_xlim([-180, 180]) ax.yaxis.set_minor_formatter(NullFormatter()) ax.yaxis.set_major_locator(FixedLocator(np.arange(-90, 90, 30))) 主、副刻度密度的设置 ax.xaxis.set_major_locator(MultipleLocator(20)) # 设置20倍数 ax.xaxis.set_major_formatter(FormatStrFormatter('%5.1f')) # 设置文本格式 # y轴 ax.yaxis.set_major_locator(MultipleLocator(100)) # 设置100倍数 ax.yaxis.set_major_formatter(FormatStrFormatter('%1.2f')) # 设置文本格式 # 设置轴的副刻度 # x轴 ax.xaxis.set_minor_locator(MultipleLocator(5)) # 设置10倍数 # ax.xaxis.set_minor_formatter(FormatStrFormatter('%2.1f')) # 设置文本格式 # y轴 ax.yaxis.set_minor_locator(MultipleLocator(50)) # 设置50倍数 # ax.yaxis.set_minor_formatter(FormatStrFormatter('%1.0f')) # 设置文本格式 Axis Label 'Axis.set_label_coords' Set the coordinates of the label. 'Axis.set_label_position' Set the label position (top or bottom) 'Axis.set_label_text' Set the text value of the axis label. 'Axis.get_label_position' Return the label position (top or bottom) 'Axis.get_label_text' Get the text of the label Ticks, tick labels and Offset text 'Axis.grid' Configure the grid lines. 'Axis.set_tick_params' Set appearance parameters for ticks, ticklabels, and gridlines. 'Axis.axis_date' Sets up axis ticks and labels treating data along this axis as dates. axis.Axis.set_tick_params Set appearance parameters for ticks, ticklabels, and gridlines. 参数：Matplotlib：tick_params matplotlib.axes.Axes.tick_params axes.Axes.set_title Axes.set_title(self, label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs) 参数： label : str Text to use for the title fontdict :dict A dictionary controlling the appearance of the title text, the default fontdict is: {'fontsize': rcParams['axes.titlesize'], 'fontweight': rcParams['axes.titleweight'], 'color': rcParams['axes.titlecolor'], 'verticalalignment': 'baseline', 'horizontalalignment': loc} loc: {'center', 'left', 'right'}, default: rcParams[\"axes.titlelocation\"] (default: 'center')which title to set. y: float, default: rcParams[\"axes.titley\"] (default: None) Vertical axes loation for the title (1.0 is the top). If None (the default), y is determined automatically to avoid decorators on the axes. pad :float, default: rcParams[\"axes.titlepad\"] (default: 6.0) The offset of the title from the top of the axes, in points. 返回值： Text The matplotlib text instance representing the title Discouraged 'Axis.set_ticklabels' Set the text values of the tick labels. 'Axis.set_ticks' Set the locations of the tick marks from sequence ticks 双Y轴 ax2 = ax1.twinx() # instantiate a second axes that shares the same x-axis ax2.tick_params(axis='y', labelcolor=color) # 刻度和标签设置 matplotlib.axes.Axes.tick_params 设置刻度线和刻度标签的位置 matplotlib.axis.YAxis.set_ticks_position axis.Axis.set_ticks() 设置刻度和标签 Axis.set_ticks(self, ticks, minor=False) ticks : sequence of floats minor : bool 设置刻度和标签 Axis.set_ticks_position(self, position) 设置刻度和标签的位置 YAxis.set_ticks_position(self, position) Parameters: position : {'left', 'right', 'both', 'default', 'none'} 如果时y轴的，可以设置参数为上面的 # loc 表示位置，spine表示当前位置的对象 for loc, spine in ax.spines.items(): print(loc) print(spine) left Spine right Spine bottom Spine top Spine spines.Spine.set_position() 设置 X，Y,轴分离开： 1.spines.Spine.set_position .set_position(self, position) spine.set_position(('outward', 10)) # outward by 10 points 2. .set_color(self, c) 3. .set_smart_bounds(self, value) Spine Placement Demo: fig = plt.figure() x = np.linspace(-np.pi, np.pi, 100) y = 2 * np.sin(x) ax = fig.add_subplot(2, 2, 1) ax.set_title('centered spines') ax.plot(x, y) ax.spines['left'].set_position('center') ax.spines['right'].set_color('none') ax.spines['bottom'].set_position('center') ax.spines['top'].set_color('none') ax.spines['left'].set_smart_bounds(True) ax.spines['bottom'].set_smart_bounds(True) ax.xaxis.set_ticks_position('bottom') ax.yaxis.set_ticks_position('left') ax = fig.add_subplot(2, 2, 2) ax.set_title('zeroed spines') ax.plot(x, y) ax.spines['left'].set_position('zero') ax.spines['right'].set_color('none') ax.spines['bottom'].set_position('zero') ax.spines['top'].set_color('none') ax.spines['left'].set_smart_bounds(True) ax.spines['bottom'].set_smart_bounds(True) ax.xaxis.set_ticks_position('bottom') ax.yaxis.set_ticks_position('left') ax = fig.add_subplot(2, 2, 3) ax.set_title('spines at axes (0.6, 0.1)') ax.plot(x, y) ax.spines['left'].set_position(('axes', 0.6)) ax.spines['right'].set_color('none') ax.spines['bottom'].set_position(('axes', 0.1)) ax.spines['top'].set_color('none') ax.spines['left'].set_smart_bounds(True) ax.spines['bottom'].set_smart_bounds(True) ax.xaxis.set_ticks_position('bottom') ax.yaxis.set_ticks_position('left') ax = fig.add_subplot(2, 2, 4) ax.set_title('spines at data (1, 2)') ax.plot(x, y) ax.spines['left'].set_position(('data', 1)) ax.spines['right'].set_color('none') ax.spines['bottom'].set_position(('data', 2)) ax.spines['top'].set_color('none') ax.spines['left'].set_smart_bounds(True) ax.spines['bottom'].set_smart_bounds(True) ax.xaxis.set_ticks_position('bottom') ax.yaxis.set_ticks_position('left') ```python import matplotlib.pyplot as plt import numpy as np def adjust_spines(ax,spines): for loc, spine in ax.spines.items(): if loc in spines: spine.set_position(('outward', 10)) # outward by 10 points else: spine.set_color('none') # don't draw spine # turn off ticks where there is no spine if 'left' in spines: ax.yaxis.set_ticks_position('left') else: # no yaxis ticks ax.yaxis.set_ticks([]) if 'bottom' in spines: ax.xaxis.set_ticks_position('bottom') else: # no xaxis ticks ax.xaxis.set_ticks([]) fig = plt.figure() x = np.linspace(0,2np.pi,100) y = 2np.sin(x) ax = fig.add_subplot(2,2,1) ax.plot(x,y) adjust_spines(ax,['left']) ax = fig.add_subplot(2,2,2) ax.plot(x,y) adjust_spines(ax,[]) ax = fig.add_subplot(2,2,3) ax.plot(x,y) adjust_spines(ax,['left','bottom']) ax = fig.add_subplot(2,2,4) ax.plot(x,y) adjust_spines(ax,['bottom']) plt.show() ``` ...... 更多参考官方文档：https://matplotlib.org/api/axis_api.html Update time： 2020-08-04 "},"Chapter1/图层顺序Zorder.html":{"url":"Chapter1/图层顺序Zorder.html","title":"图层顺序Zorder","keywords":"","body":"图层顺序Zorder Zorder演示 艺术家的绘画顺序是由他们的 zorder 属性，它是一个浮点数。具有更高 zorder 画在上面。您可以通过设置 zorder . 默认值取决于艺术家的类型： 对plotting方法的任何调用都可以显式地为该特定项的zorder设置值。 import matplotlib.pyplot as plt import numpy as np r = np.linspace(0.3, 1, 30) theta = np.linspace(0, 4*np.pi, 30) x = r * np.sin(theta) y = r * np.cos(theta) 以下示例包含 Line2D 创建的 plot() 点（a） PatchCollection )创建者 scatter() . 因此，在默认情况下，点位于线的下方（第一个子图）。在第二个子图中 zorder 点的顶端被明确地设置为移动。 fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(6, 3.2)) ax1.plot(x, y, 'C3', lw=3) ax1.scatter(x, y, s=120) ax1.set_title('Lines on top of dots') ax2.plot(x, y, 'C3', lw=3) ax2.scatter(x, y, s=120, zorder=2.5) # move dots on top of line ax2.set_title('Dots on top of lines') plt.tight_layout() 许多创建可见对象的函数都接受 zorder 参数。 x = np.linspace(0, 7.5, 100) plt.rcParams['lines.linewidth'] = 5 plt.figure() plt.plot(x, np.sin(x), label='zorder=2', zorder=2) # bottom plt.plot(x, np.sin(x+0.5), label='zorder=3', zorder=3) plt.axhline(0, label='zorder=2.5', color='lightgrey', zorder=2.5) plt.title('Custom order of elements') l = plt.legend(loc='upper right') l.set_zorder(2.5) # legend between blue and orange line plt.show() Update time： 2020-08-01 "},"Chapter1/matplotlib——cm选择颜色映射.html":{"url":"Chapter1/matplotlib——cm选择颜色映射.html","title":"matplotlib.cm选择颜色映射","keywords":"","body":"matplotlib.cm选择颜色映射 matplotlib.cm.cmap(float) 输入0-1 的浮点数，从 cmap中随机生成一个颜色 返回值为元组： plt.cm.tab10(5.2) #(0.09019607843137255, 0.7450980392156863, 0.8117647058823529, 1.0) #R,G,B,alpha 当所绘制只有一个 item 的时候需要将其转换成二维数组 colorx=plt.cm.tab10(5.2)#从tab10色带中取出一个颜色 x1=np.random.randn(10) x2=x1+x1**2-10 plt.scatter(x1,x2,s=50,c=np.array(colorx).reshape(1,-1)) cmap : 可以连续的或者分段的颜色库。 渐变色： 连续色： datasets=pd.read_csv(\"./midwest_filter.csv\")#由原博主提供的在线数据集直接导入 #查看数据 watch_data1=datasets.head() #print(watch_data1) watch_data2=datasets.columns #print(watch_data2) #准备标签 watch_cat=datasets['category'] #print(watch_cat)#查看原始标签 categories=np.unique(datasets['category'])#去掉重复项 #print(categories)#查看去重后类别 #print(len(categories))#查看有几个类别 #准备颜色 '''colorx=plt.cm.tab10(5.2)#从tab10色带中取出一个颜色 x1=np.random.randn(10) x2=x1+x1**2-10 plt.scatter(x1,x2,s=50,c=np.array(colorx).reshape(1,-1)) plt.show()''' #开始绘制复杂散点图 #我们需要循环和类别数目一样的次数，目前有14各类别 #我们用循环的i来生成小数，这样就可以生成不同的颜色 plt.figure(figsize=(16,10))#定义画布 for i in range (len(categories)): plt.scatter(datasets.loc[datasets[\"category\"]==categories[i],\"area\"] ,datasets.loc[datasets[\"category\"]==categories[i],\"poptotal\"] ,s=20 #点的大小 ,c=np.array(plt.cm.tab10(i/len(categories))).reshape(1,-1) #每次生成一个颜色 ,label=categories[i]) plt.legend() plt.show() 参考：https://www.osgeo.cn/matplotlib/tutorials/colors/colormaps.html Update time： 2020-09-04 "},"Chapter2/":{"url":"Chapter2/","title":"折线图","keywords":"","body":"折线图 Update time： 2020-05-23 "},"Chapter3/":{"url":"Chapter3/","title":"散点图","keywords":"","body":"散点图 matplotlib.pyplot.scatter matplotlib.pyplot.scatter(x, y, s=None, c=None, marker=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, verts=, edgecolors=None, *, plotnonfinite=False, data=None, **kwargs) 参数： x, y The data positions. shape (n, ) s shape (n, ), 以点 2为单位的标记大小。默认值为rcParams['lines.marker大小']2。 c 颜色或颜色的数组或列表 marker MarkerStyle，默认值：rcParams[“散点标记“]（默认值：'o'） cmap Colormap ，可选，默认值：无颜色映射，可选，默认值：无 alpha : 标量，可选，默认值：无 alpha混合值，介于0（透明）和1（不透明）之间。 linewidths : 标量或类似数组，可选，默认值：无 标记边缘的线条宽度。 edgecolors : 标记的边缘颜色 参数 ：c 颜色或颜色的数组或列表 使用列表映射颜色， import numpy as np #数学处理库 import pandas as pd #用于处理.csv excel html 文本等文件 import matplotlib as mpl #画图像的库 import matplotlib.pyplot as plt #画二维图像的库 import seaborn as sns #颜色库 #2.无图例，分类型变量，即存在有两种数据，两列X对应一列y的情况 x = np.random.randn(10,2)#10行2列的数据集 y = np.array([0,0,1,1,0,1,0,1,0,0])#类别：假设目前有两种类型的数据分别是0和1 plt.figure(figsize=(8,4)) plt.scatter(x[:,0], x[:,1], s=50, c=y # 使用数组标签映射颜色分类 ) plt.savefig('./fig/散点图1.png') 有图例的多类别散点图 有多图例的图，用循环的方式，进行绘制。 import numpy as np #数学处理库 import pandas as pd #用于处理.csv excel html 文本等文件 import matplotlib as mpl #画图像的库 import matplotlib.pyplot as plt #画二维图像的库 import seaborn as sns #颜色库 #3.有图例，分类型变量，即存在有两种数据，两列X对应一列y的情况 x = np.random.randn(10,2)#10行2列的数据集 y = np.array([0,0,1,1,0,1,0,1,0,0])#类别：假设目前有两种类型的数据分别是0和1 plt.figure(figsize=(8,4)) #要想生成两个图例，就要循环，分别循环颜色和标签 colors = [\"red\",\"black\"] labels=[\"Zero\",\"One\"] for i in range(x.shape[1]): plt.scatter(x[y==i,0],x[y==i,1],c=colors[i],label=labels[i]) #在标签中存在几种类别，我们就循环几次，一次画一个点 plt.legend() plt.savefig('./fig/散点图2.png') 随机颜色散点图 datasets=pd.read_csv(\"./midwest_filter.csv\")#由原博主提供的在线数据集直接导入 watch_cat=datasets['category'] #print(watch_cat)#查看原始标签 categories=np.unique(datasets['category'])#去掉重复项 #print(categories)#查看去重后类别 #print(len(categories))#查看有几个类别 #准备颜色 '''colorx=plt.cm.tab10(5.2)#从tab10色带中取出一个颜色 x1=np.random.randn(10) x2=x1+x1**2-10 plt.scatter(x1,x2,s=50,c=np.array(colorx).reshape(1,-1)) plt.show()''' #开始绘制复杂散点图 #我们需要循环和类别数目一样的次数，目前有14各类别 #我们用循环的i来生成小数，这样就可以生成不同的颜色 plt.figure(figsize=(16,10))#定义画布 for i in range (len(categories)): plt.scatter(datasets.loc[datasets[\"category\"]==categories[i],\"area\"] ,datasets.loc[datasets[\"category\"]==categories[i],\"poptotal\"] ,s=20,c=np.array(plt.cm.tab10(i/len(categories))).reshape(1,-1) #每次生成一个颜色 ,label=categories[i]) plt.legend() plt.savefig('./fig/cm2.png') Update time： 2020-09-04 "},"Chapter3/气泡图.html":{"url":"Chapter3/气泡图.html","title":"气泡图","keywords":"","body":"气泡图 import numpy as np import matplotlib.pyplot as plt # Fixing random state for reproducibility np.random.seed(19680801) N = 50 x = np.random.rand(N) y = np.random.rand(N) colors = np.random.rand(N) area = (30 * np.random.rand(N))**2 # 0 to 15 point radii plt.scatter(x, y, s=area, c=colors, alpha=0.5) plt.show() 在复杂散点图绘制的基础上对代码进行修改，使之变为气泡图 原始散点图： import numpy as np #数学处理库 import pandas as pd #用于处理.csv excel html 文本等文件 import matplotlib as mpl #画图像的库 import matplotlib.pyplot as plt #画二维图像的库 import seaborn as sns #颜色库 datasets=pd.read_csv(\"./midwest_filter.csv\") watch_cat=datasets['category'] #print(watch_cat)#查看原始标签 categories=np.unique(datasets['category'])#去掉重复项 #print(categories)#查看去重后类别 #print(len(categories))#查看有几个类别 #开始绘制复杂散点图 #我们需要循环和类别数目一样的次数，目前有14各类别 #我们用循环的i来生成小数，这样就可以生成不同的颜色 #以下两个步骤可以去掉图例的边框 plt.style.use('seaborn-whitegrid')#设定整体风格 sns.set_style(\"white\")#设置背景 plt.figure(figsize=(16,10), dpi=120, facecolor='w', edgecolor='k')#定义画布，分辨率，背景，边框 for i in range (len(categories)): plt.scatter(datasets.loc[datasets[\"category\"]==categories[i],\"area\"], datasets.loc[datasets[\"category\"]==categories[i],\"poptotal\"], s=20,c=np.array(plt.cm.tab10(i/len(categories))).reshape(1,-1), label=categories[i]) #开始装饰 plt.gca().set(xlim=(0.0,0.12),ylim=(0,80000))#控制横纵坐标的范围 plt.xticks(fontsize=12) plt.yticks(fontsize=12) plt.ylabel('Population',fontsize=22) plt.xlabel('Area',fontsize=22) plt.title(\"scatterplot of midwest Area vs Population\",fontsize=22) plt.legend(fontsize=12) plt.show() 要产生气泡图的实质是要让点的大小随着某一个类别的值的大小而变化，那么，就是要对s参数进行改变。我们之前可以让颜色变化同理就可以让点的尺寸变化，修改下面的代码看看效果，主要看s的部分: for i in range (len(categories)): plt.scatter(datasets.loc[datasets[\"category\"]==categories[i],\"area\"], datasets.loc[datasets[\"category\"]==categories[i],\"poptotal\"], s=datasets.loc[datasets[\"category\"]==categories[i],\"popasian\"], c=np.array(plt.cm.tab10(i/len(categories))).reshape(1,-1), label=categories[i]) 但是存在很多问题，我们一一来解决： 问题1：点的颜色不透明，符号不好看，不是我们想要的； 加入下面的代码我们再来看看，增加了透明度，边缘颜色，边缘线宽参数之后： for i in range (len(categories)): plt.scatter(datasets.loc[datasets[\"category\"]==categories[i],\"area\"], datasets.loc[datasets[\"category\"]==categories[i],\"poptotal\"], s=datasets.loc[datasets[\"category\"]==categories[i],\"popasian\"], c=np.array(plt.cm.tab10(i/len(categories))).reshape(1,-1), edgecolors=np.array(plt.cm.tab10(i/len(categories))).reshape(1,-1), # 描边颜色与主题颜色相同 linewidths=0.5, alpha=0.7, # 修改透明度 label=categories[i]) 问题2：以人数绝对值为点的大小不合理，最好使用占比表达，但是占比的数值都比较小，怎么能使用它呢？ 我们可以整体给占比乘一个比较大的数，扩大以后，显示就没有问题了，代码修改和效果如下： 问题3：气泡图整饰的问题，图例很难看，点超出范围了，图名不正确。 plt.gca().set(xlim=(0.0,0.12),ylim=(0,90000))#控制横纵坐标的范围 plt.xticks(fontsize=12) plt.yticks(fontsize=12) plt.ylabel('Population',fontsize=22) plt.xlabel('Area',fontsize=22) plt.title(\"Bubble Plot with Encircling\",fontsize=22) plt.legend(fontsize=12,markerscale=0.5)#现有图例的0.5倍 Update time： 2020-09-04 "},"Chapter4/":{"url":"Chapter4/","title":"柱状图","keywords":"","body":"柱状图 Update time： 2020-05-23 "},"Chapter4/堆叠柱状图.html":{"url":"Chapter4/堆叠柱状图.html","title":"堆叠柱状图","keywords":"","body":"堆叠柱状图 bar(left, height, width=0.8, bottom=None, **kwargs) left为x轴的位置序列，一般采用arange函数产生一个序列； height为y轴的数值序列，也就是柱形图的高度，一般就是我们需要展示的数据； width为柱形图的宽度，一般这是为1即可；color为柱形图填充的颜色; align设置plt.xticks()函数中的标签的位置； yerr让柱形图的顶端空出一部分。 color设置柱状的颜色 alpha 设置柱状填充颜色的透明度 大于0 小于等于1 linewidth 线条的宽度 bottom bottom决定了柱子距离x轴的高度，默认为None，即表示与x轴距离为0 基本用法 import pandas as pd import matplotlib.pyplot as plt #读取数据 datafile = u'matplotlib.xlsx' data = pd.read_excel(datafile) plt.figure(figsize=(10,5))#设置画布的尺寸 plt.title('Examples of Histogram',fontsize=20)#标题，并设定字号大小 plt.xlabel(u'x-year',fontsize=14)#设置x轴，并设定字号大小 plt.ylabel(u'y-income',fontsize=14)#设置y轴，并设定字号大小 #alpha：透明度；width：柱子的宽度；facecolor：柱子填充色；edgecolor：柱子轮廓色；lw：柱子轮廓的宽度；label：图例； plt.bar(data['时间'],data['收入_Jay'], alpha=0.6,width = 0.8, facecolor = 'deeppink', edgecolor = 'darkblue', lw=1, label='Jay income') plt.legend(loc=2)#图例展示位置，数字代表第几象限 plt.show()#显示图像 多个直方图并列显示 通过bar() 中的 width 参数来调节 绘制并列柱状图与堆叠柱状图类似，都是绘制多组柱体，只需要控制好每组柱体的位置和大小即可。 size=5 x=np.arange(size) a=np.random.random(size) b=np.random.random(size) c=np.random.random(size) total_width,n=0.8,3 width=total_width/n x=x-(total_width-width)/2 plt.bar(x,a,width=width,label='a') plt.bar(x+width,b,width=width,label='b') plt.bar(x+2*width,c,width=width,label='c') plt.legend() plt.show() width_val = 0.4 #若显示 n 个柱状图，则width_val的值需小于1/n ，否则柱形图会有重合 #alpha：透明度；width：柱子的宽度；facecolor：柱子填充色；edgecolor：柱子轮廓色；lw：柱子轮廓的宽度；label：图例； plt.bar(data['时间'],data['收入_Jay'], alpha=0.6,width = width_val, facecolor = 'deeppink', edgecolor = 'deeppink', lw=1, label='Jay income') plt.bar(data['时间']+width_val,data['收入_JJ'], alpha=0.6,width = width_val, facecolor = 'darkblue', edgecolor = 'darkblue', lw=1, label='JJ income') 显示直方图上的数值 import pandas as pd import matplotlib.pyplot as plt #读取数据 datafile = u'matplotlib.xlsx' data = pd.read_excel(datafile) plt.figure(figsize=(10,5))#设置画布的尺寸 plt.title('Examples of Histogram',fontsize=20)#标题，并设定字号大小 plt.xlabel(u'x-year',fontsize=14)#设置x轴，并设定字号大小 plt.ylabel(u'y-income',fontsize=14)#设置y轴，并设定字号大小 width_val = 0.4 #若显示 n 个柱状图，则width_val的值需小于1/n ，否则柱形图会有重合 #alpha：透明度；width：柱子的宽度；facecolor：柱子填充色；edgecolor：柱子轮廓色；lw：柱子轮廓的宽度；label：图例； rects_Jay = plt.bar(data['时间'],data['收入_Jay'], alpha=0.6,width = width_val, facecolor = 'deeppink', label='Jay income') rects_JJ = plt.bar(data['时间']+width_val,data['收入_JJ'], alpha=0.6,width = width_val, facecolor = 'darkblue',label='JJ income') # 添加数据标签 就是矩形上面的数值 def add_labels(rects): for rect in rects: height = rect.get_height() plt.text(rect.get_x() + rect.get_width()/2, height, height, ha='center', va='bottom') rect.set_edgecolor('white') add_labels(rects_Jay) add_labels(rects_JJ) plt.legend(loc=2)#图例展示位置，数字代表第几象限 plt.show()#显示图像 直方图堆叠显示 通过bar() 中的 bottom 参数来调节 import pandas as pd import matplotlib.pyplot as plt #读取数据 datafile = u'matplotlib.xlsx' data = pd.read_excel(datafile) plt.figure(figsize=(10,5))#设置画布的尺寸 plt.title('Examples of Histogram',fontsize=20)#标题，并设定字号大小 plt.xlabel(u'x-year',fontsize=14)#设置x轴，并设定字号大小 plt.ylabel(u'y-income',fontsize=14)#设置y轴，并设定字号大小 width_val = 0.4 #通过bottom使得两个柱状图堆叠显示，且没有交叉 #alpha：透明度；width：柱子的宽度；facecolor：柱子填充色；edgecolor：柱子轮廓色；lw：柱子轮廓的宽度；label：图例； plt.bar(data['时间'],data['收入_Jay'], alpha=0.6,width = width_val, facecolor = 'deeppink', edgecolor = 'deeppink', lw=1, label='Jay income' ) plt.bar(data['时间'],data['收入_JJ'], bottom=data['收入_Jay'], alpha=0.6, width = width_val, facecolor = 'darkblue', edgecolor = 'darkblue', lw=1, label='JJ income' ) plt.legend(loc=2)#图例展示位置，数字代表第几象限 plt.show()#显示图像 水平直方图 通过 barh() 函数实现，与 bar() 函数的主要区别是：在 bar() 函数中，width 这一参数代表的是柱子的宽度（胖瘦），而在 barh() 函数中 width 这一参数代表的是横向柱子的长度（长短），在下面代码中，width = data[‘收入_Jay’]。 Matplotlib 中绘制水平柱状图（直方图、条形图）的函数为 barh() ，使用语法如下： matplotlib.pyplot.barh(y, width, height=0.8, left=None, *, align=‘center’, **kwargs) import pandas as pd import matplotlib.pyplot as plt #读取数据 datafile = u'matplotlib.xlsx' data = pd.read_excel(datafile) plt.figure(figsize=(10,5))#设置画布的尺寸 plt.title('Examples of Histogram',fontsize=20)#标题，并设定字号大小 plt.xlabel(u'x-year',fontsize=14)#设置x轴，并设定字号大小 plt.ylabel(u'y-income',fontsize=14)#设置y轴，并设定字号大小 #alpha：透明度；facecolor：柱子填充色；edgecolor：柱子轮廓色；lw：柱子轮廓的宽度；label：图例； plt.barh(data['时间'],data['收入_Jay'], alpha=0.6, facecolor = 'deeppink', edgecolor = 'deeppink', label='Jay income') plt.legend(loc=4)#图例展示位置，数字代表第几象限 plt.show()#显示图像 import matplotlib.pyplot as plt import numpy as np n = 12 X = np.arange(n) Y1 = (1 - X / float(n)) * np.random.uniform(0.5, 1.0, n) Y2 = (1 - X / float(n)) * np.random.uniform(0.5, 1.0, n) plt.bar(X, +Y1) plt.bar(X, -Y2) plt.xlim(-.5, n) plt.ylim(-1.25, 1.25) #隐藏坐标轴刻度数字 plt.xticks(()) plt.yticks(()) #移动坐标轴 # ax=plt.gca() # ax.spines['bottom'].set_position(('data',0)) plt.show() 设置柱体样式 颜色 通过facecolor(或fc)关键字参数可以设置柱体颜色 plt.bar(range(len(data)), data, fc='g') 通过 color 关键字参数 可以一次性设置多个颜色 plt.bar(range(len(data)), data, color='rgb') # or `color=['r', 'g', 'b']` 设置tick label 设置x轴刻度（tick_label）用labels = [‘Tom’, ‘Dick’, ‘Harry’, ‘Slim’, ‘Jim’]显示 import matplotlib.pyplot as plt data = [5, 20, 15, 25, 10] labels = ['Tom', 'Dick', 'Harry', 'Slim', 'Jim'] plt.bar(range(len(data)), data, tick_label=labels) plt.show() Update time： 2020-05-23 "},"Chapter5/":{"url":"Chapter5/","title":"分类图","keywords":"","body":"分类图 Update time： 2020-05-23 "},"Chapter5/利用plt.pcolormesh绘制分类图.html":{"url":"Chapter5/利用plt.pcolormesh绘制分类图.html","title":"利用plt.pcolormesh绘制分类图","keywords":"","body":"利用plt.pcolormesh绘制分类图 用pcolormesh()能画的, 用scatter()也能画, 但是经过测试, 发现用scatter()画的速度比pcolormesh()要慢不少 - - plt.pcolormesh(X,Y,Z,cmap=cm) X，Y：指的是二维网格面每一个点的横纵坐标 Z:(X,Y) :坐标处的颜色值 cmap:着色方案 pcolormesh 的作用是: 用不规则的矩形网格创建伪彩色图。 ''' 多元分类：逻辑回归分类器 并绘制pcolormesh伪彩图 sklearn.linear_model.LogisticRegression( solver='liblinear', C=正则强度) ''' # pcolormesh(x, y, c=d, cmap='jet') cmap:渐变色映射 plt.pcolormesh(...): a = np.array([1, 2, 3]) b = np.array([-1, -2, -3, -4]) a.shape, b.shape Out[55]: ((3,), (4,)) c = np.meshgrid(a, b); # c # c is a 'list', not 'numpy.array' Out[57]: # c[0]：沿行(axis=0)广播, 每一行元素跟上一行相同 [array([[1, 2, 3], # c[1]：沿列(axis=1)广播, 每一列元素跟上一列相同 [1, 2, 3], # (c[0],c[1])组成的坐标点(x,y)将覆盖并形成(1 | -1 (1,-1) (2,-1) (3,-1) | -2 (1,-2) (2,-2) (3,-2) | -3 (1,-3) (2,-3) (3,-3) | -4 (1,-4) (2,-4) (3,-4) | ''' ''' 多元分类：逻辑回归分类器 sklearn.linear_model.LogisticRegression( solver='liblinear', C=正则强度) ''' import numpy as np import matplotlib.pyplot as plt import sklearn.linear_model as lm # train_set x = np.array([ [4, 7], [3.5, 8], [3.1, 6.2], [0.5, 1], [1, 2], [1.2, 1.9], [4, 2], [5.7, 1.5], [5.4, 2.2]]) # 散点[x,y] y = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2]) # 多元分类 3类 # 逻辑回归分类器 model = lm.LogisticRegression(solver='liblinear', C=50) # C model.fit(x, y) plt.figure('Logistic Classification', facecolor='lightgray') plt.title('Logistic Classification', fontsize=14) plt.xlabel('x', fontsize=14) plt.ylabel('y', fontsize=14) plt.tick_params(labelsize=10) ''' pcolormesh参数设置： ''' l, r, h = x[:, 0].min() - 1, x[:, 0].max() + 1, 0.005 # 左边界，右边界，水平方向点间距 b, t, v = x[:, 1].min() - 1, x[:, 1].max() + 1, 0.005 # 下边界，上边界，垂直方向点间距 #print(np.arange(l, r, h).shape, np.arange(b, t, v).shape) # (1440,) (1800,),shape不同，不能直接作为输入,转为 grid_x = np.meshgrid(np.arange(l, r, h), np.arange(b, t, v)) # (m-array,n-array)--> list(mat(m,n), mat(m,n)) print(grid_x[0]) # x[i, j] (1800, 1440) print(grid_x[1]) # y[i, j] (1800, 1440) #print(grid_x[1].shape) # (1800, 1440) flat_x = np.c_[grid_x[0].ravel(), grid_x[1].ravel()] # 保证输入散点的坐标点横纵坐标个数一样 flat_y = model.predict(flat_x) # 输入栅格点阵坐标，模型预测输出的分类 grid_y = flat_y.reshape(grid_x[0].shape) # 分类标签：用做pcolormesh栅格着色的依据 print(grid_y) #[[1 1 1 ... 2 2 2] # 0, 1, 2 分别代表三种不同颜色 # [1 1 1 ... 2 2 2] # [1 1 1 ... 2 2 2] # ... # [0 0 0 ... 0 0 0] # [0 0 0 ... 0 0 0] # [0 0 0 ... 0 0 0]] # pcolormesh: 伪彩图 pcolormesh(X, Y, C) # X,Y均为2-D array,如果为1-D 会自动广播，X和Y构成网格点阵 # X,Y对应位置元素x[i,j]和y[i,j]组成一个坐标点(x[i,j],y[i,j])，对样本周围（包括样本所在坐标）的四 #个坐标点进行着色，C代表着色方案 plt.pcolormesh(grid_x[0], grid_x[1], grid_y, cmap='gray') # gray_r 与gray的色带相反 plt.scatter(x[:, 0], x[:, 1], c=y, cmap='brg', s=60) # 颜色映射 参考： plt.pcolormesh绘制分类图 利用plt.pcolormesh绘制分类图 Update time： 2020-05-23 "},"Chapter6/":{"url":"Chapter6/","title":"热力图","keywords":"","body":"热力图 Update time： 2020-05-23 "},"Chapter6/热力图.html":{"url":"Chapter6/热力图.html","title":"热力图","keywords":"","body":"热力图 利用热力图可以看数据表里多个特征两两的相似度。 seaborn.heatmap(data, vmin=None, vmax=None, cmap=None, center=None, robust=False, annot=None, fmt=’.2g’, annot_kws=None, linewidths=0, linecolor=’white’, cbar=True, cbar_kws=None, cbar_ax=None, square=False, xticklabels=’auto’, yticklabels=’auto’, mask=None, ax=None, **kwargs) 热力图输入数据参数: data:矩阵数据集，可以是numpy的数组（array），也可以是pandas的DataFrame。如果是DataFrame，则 df 的index/column信息会分别对应到heatmap的columns和rows，即df.index是热力图的行标，df.columns是热力图的列标 热力图矩阵块颜色参数: vmax,vmin:分别是热力图的颜色取值最大和最小范围，默认是根据data数据表里的取值确定 cmap:从数字到色彩空间的映射，取值是matplotlib包里的colormap名称或颜色对象，或者表示颜色的列表；改参数默认值：根据center参数设定 center:数据表取值有差异时，设置热力图的色彩中心对齐值；通过设置center值，可以调整生成的图像颜色的整体深浅；设置center数据时，如果有数据溢出，则手动设置的vmax、vmin会自动改变 robust: 默认取值False；如果是False，且没设定vmin和vmax的值，热力图的颜色映射范围根据具有鲁棒性的分位数设定，而不是用极值设定 热力图矩阵块注释参数: annot(annotate的缩写):默认取值False；如果是True，在热力图每个方格写入数据；如果是矩阵，在热力图每个方格写入该矩阵对应位置数据 fmt:字符串格式代码，矩阵上标识数字的数据格式，比如保留小数点后几位数字 annot_kws:默认取值False；如果是True，设置热力图矩阵上数字的大小颜色字体，matplotlib包text类下的字体设置；官方文档： 热力图矩阵块之间间隔及间隔线参数： linewidths: 定义热力图里“表示两两特征关系的矩阵小块”之间的间隔大小 linecolor: 切分热力图上每个矩阵小块的线的颜色，默认值是’white’ 热力图颜色刻度条参数： cbar: 是否在热力图侧边绘制颜色刻度条，默认值是 True cbar_kws: 热力图侧边绘制颜色刻度条时，相关字体设置，默认值是None cbar_ax: 热力图侧边绘制颜色刻度条时，刻度条位置设置，默认值是None square:设置热力图矩阵小块形状，默认值是False xticklabels, yticklabels:xticklabels控制每列标签名的输出；yticklabels控制每行标签名的输出。默认值是auto。如果是True，则以DataFrame的列名作为标签名。如果是False，则不添加行标签名。如果是列表，则标签名改为列表中给的内容。如果是整数K，则在图上每隔K个标签进行一次标注。 如果是auto，则自动选择标签的标注间距，将标签名不重叠的部分(或全部)输出 mask: 控制某个矩阵块是否显示出来。默认值是None。如果是布尔型的DataFrame，则将DataFrame里True的位置用白色覆盖掉 ax:设置作图的坐标轴，一般画多个子图时需要修改不同的子图的该值 \\kwargs: All other keyword arguments are passed to ax.pcolormesh 测试： import seaborn as sns sns.set(font_scale=1.5) 采用的数据集是 Seaborn 中内置的 flights航班数据集 #导入数据集后按年月两个维度进行数据透视 data=sns.load_dataset(\"flights\")\\ .pivot(\"month\",\"year\",\"passengers\") data.head() sns.set_context({\"figure.figsize\":(8,8)}) sns.heatmap(data=data,square=True) #可以看到热力图主要展示的是二维数据的数据关系 #不同大小的值对应不同的颜色深浅 热力图的右侧是颜色带，上面代表了数值到颜色的映射，数值由小到大对应色彩由暗到亮。从上面的heatmap中我们可以得到两层信息，一是随着时间的推移，飞机的乘客数量是在逐步增多的，二是航班的乘坐旺季在七月和八月份 参数 vmax，vmin vmax：设置颜色带的最大值 vmin：设置颜色带的最小值 sns.heatmap(data=data,vmin=200,vmax=500) 可以看到右侧的颜色带最大最小值变了，而heatmap中颜色映射关系也会随之调整，将本图和上面的图进行对比便一目了然。 参数cmap cmap：设置颜色带的色系 sns.heatmap(data=data,cmap=\"RdBu_r\") 参数center center：设置颜色带的分界线 细心的朋友可以察觉到颜色带上色彩两级的分界线变成了300 参数annot annot：是否显示数值注释 怎么回事？乱码了吗？其实数值注释默认显示的是科学记数法的数值，我们得把数值进行格式化，这就用到了下面的参数。 参数fmt fmt：format的缩写，设置数值的格式化形式 参数 annot_kws 修改注释的字体等格式 #annot(矩阵上数字),annot_kws(矩阵上数字的大小颜色字体)matplotlib包text类下的字体设置 import numpy as np np.random.seed(20180316) x = np.random.randn(4, 4) f, (ax1, ax2) = plt.subplots(figsize=(6,6),nrows=2) sns.heatmap(x, annot=True, ax=ax1) sns.heatmap(x, annot=True, ax=ax2, annot_kws={'size':9,'weight':'bold', 'color':'blue'}) # Keyword arguments for ax.text when annot is True. http://stackoverflow.com/questions/35024475/seaborn-heatmap-key-words 参数 linewidths linewidths：控制每个小方格之间的间距 参数 linecolor linecolor：控制分割线的颜色 参数 cbar_kws cbar_kws：关于颜色带的设置 参数 ax 多子图时 指定当前子图的位置 #cmap(颜色) import matplotlib.pyplot as plt import seaborn as sns % matplotlib inline f, (ax1,ax2) = plt.subplots(figsize = (6,4),nrows=2) # cmap用cubehelix map颜色 cmap = sns.cubehelix_palette(start = 1.5, rot = 3, gamma=0.8, as_cmap = True) pt = df.corr() # pt为数据框或者是协方差矩阵 sns.heatmap(pt, linewidths = 0.05, ax = ax1, vmax=900, vmin=0, cmap=cmap) ax1.set_title('cubehelix map') ax1.set_xlabel('') ax1.set_xticklabels([]) #设置x轴图例为空值 ax1.set_ylabel('kind') # cmap用matplotlib colormap sns.heatmap(pt, linewidths = 0.05, ax = ax2, vmax=900, vmin=0, cmap='rainbow') # rainbow为 matplotlib 的colormap名称 ax2.set_title('matplotlib colormap') ax2.set_xlabel('region') ax2.set_ylabel('kind') 参数 mask mask 对某些矩阵块进行覆盖 #mask对某些矩阵块的显示进行覆盖 f, (ax1,ax2) = plt.subplots(figsize = (5,5),nrows=2) cmap = sns.cubehelix_palette(start = 1.5, rot = 3, gamma=0.8, as_cmap = True) p1 = sns.heatmap(pt, ax=ax1, cmap=cmap, xticklabels=False, mask=None) ax1.set_title('mask=None') ax1.set_ylabel('kind') p2 = sns.heatmap(pt, ax=ax2, cmap=cmap, xticklabels=True, mask=(pt 用mask实现：突出显示某些数据 f,(ax1,ax2) = plt.subplots(figsize=(4,6),nrows=2) x = np.array([[1,2,3],[2,0,1],[-1,-2,0]]) sns.heatmap(x, annot=True, ax=ax1) sns.heatmap(x, mask=x 参考 python可视化——热力图 heatmap热力图 Update time： 2020-05-23 "},"帕累托图/":{"url":"帕累托图/","title":"帕累托图","keywords":"","body":"帕累托图 Update time： 2020-08-01 "},"帕累托图/帕累托图.html":{"url":"帕累托图/帕累托图.html","title":"帕累托图","keywords":"","body":"帕累托图 01 1897 年，意大利经济学家帕累托，在抽样调查的数据中发现，社会上 20% 的人拥有 80% 的财富。 后来，人们发现这种「关键少数」的现象非常普遍，比如说：20% 的原因导致 80% 的问题，20% 的产品贡献 80% 的业绩，20% 的员工贡献 80% 的业绩，20% 的客户贡献 80% 的业绩 …… 因此，简称为「二八法则」。 为了纪念帕累托，我们把展现「二八法则」的图表，称之为帕累托图。 下面举个例子，我们汇总导致质量问题的原因，计算每种原因出现的频次，然后按照从大到小进行排列，制作成一张帕累托图如下： 与常见的帕累托图不同，对图表细节做了一些调整： （1）线条从坐标原点开始，代表累计百分比从 0 开始； （2）没有使用双坐标轴，线条的高度就是频次的累计； （3）灰色边框的高度就是频次的总和，以便展现部分与整体之间的占比关系； （4）用虚线标记大致符合「二八法则」的位置； （5）用文字标签说明累计百分比的具体数字，在标题中体现图表想要传递的信息。 借助帕累托图，有助于我们抓住问题的关键，从而解决核心的问题。 02 用 matplotlib 画图的具体步骤。 # 导入所需的库 import numpy as np import pandas as pd import matplotlib as mpl import matplotlib.pyplot as plt import matplotlib.image as image # 正常显示中文标签 mpl.rcParams['font.sans-serif'] = ['SimHei'] # 自动适应布局 mpl.rcParams.update({'figure.autolayout': True}) # 正常显示负号 mpl.rcParams['axes.unicode_minus'] = False # 禁用科学计数法 pd.set_option('display.float_format', lambda x: '%.2f' % x) # 定义颜色，主色：蓝色，辅助色：灰色，互补色：橙色 c = {'蓝色':'#00589F', '深蓝色':'#003867', '浅蓝色':'#5D9BCF', '灰色':'#999999', '深灰色':'#666666', '浅灰色':'#CCCCCC', '橙色':'#F68F00', '深橙色':'#A05D00', '浅橙色':'#FBC171'} 其次，从 Excel 文件中读取数据，并定义画图用的数据。 # 数据源路径 filepath='./data/帕累托图数据源.xlsx' # 读取 Excel文件 df = pd.read_excel(filepath) # 定义画图所需的数据 x = df['原因'] y = df['频次'] # 让折线图从坐标原点开始 x2 = np.arange(len(x)+1) - 0.5 # 计算累计频次 y_cumsum = [0] + list(y.cumsum()) # 计算累计百分比 y2 = y.cumsum()/y.sum() # 使用「面向对象」的方法画图 fig, ax = plt.subplots(figsize=(8, 6)) # 设置标题 ax.set_title('\\n%.1f%%' % (y_cumsum[2]/y.sum()*100) + '的质量问题是由20%的原因引起的\\n', fontsize=26, loc='left', color=c['深灰色']) # 用灰色方框代表总体的大小，体现每个数据的占比关系 ax.bar(x, y.sum(), width=1, color='w', edgecolor=c['浅灰色'], zorder=0) # 画柱形图 ax.bar(x, y, width=1, color=c['蓝色'], edgecolor=c['浅灰色'], zorder=1) # 画折线图 ax.plot(x2, y_cumsum, ls='-', lw=2, color=c['橙色'], label='累计百分比', zorder=2) # 标记体现二八法则的虚线 ax.hlines(y_cumsum[2], -0.5, 1.5, color=c['橙色'], ls='--') ax.vlines(1.5, 0, y_cumsum[2], color=c['橙色'], ls='--') # 隐藏边框 ax.spines['top'].set_visible(False) ax.spines['right'].set_visible(False) ax.spines['bottom'].set_visible(False) ax.spines['left'].set_visible(False) # 设置图形的位置，减少空白 ax.spines['left'].set_position(('data', -0.51)) # 隐藏 X 轴的刻度线 ax.tick_params(axis='x', which='major', length=0) ax.tick_params(axis='y', which='major', length=0) ax.set_yticklabels([]) # 设置坐标标签字体大小和颜色 ax.tick_params(labelsize=16, colors=c['深灰色']) # 设置数据标签 for a, a2, b, b2, b3 in zip(x, x2[1:], y, y_cumsum[1:], y2): ax.text(a, b, '%.0f' % b, ha='center', va= 'bottom', fontsize=16, color=c['蓝色']) # 标记 Y 轴标题 ax.text(-1, y.sum(), '频\\n次', fontsize=16, va='top', color=c['蓝色']) # 标记线条含义 ax.text(1.5, y_cumsum[2]+10, '累计%.1f%% ' % (y_cumsum[2]/y.sum()*100), fontsize=16, color=c['橙色'], va='bottom', ha='right', zorder=5) plt.show() 03 通过广泛寻找问题的原因，会发现影响因素有很多，但是各种因素对问题的影响程度并不相同，因此需要缩小范围，找出导致问题的主要原因。 要识别问题的主要原因，可以借助帕累托图，对各种原因进行优先级排序，多问几个「为什么」，逐级分析，以确定根本原因。 1951 年，管理学家戴克将帕累托图应用于库存管理，命名为 ABC 分析法。 1963 年，德鲁克将 ABC 分析法进一步推广，使其成为企业提高效益的管理方法。 对于个人来讲，把自己的工作清单分成 3 大类： A 类：需要投入巨大精力的长期工作。 B 类：需要及时响应并完成的工作。 C 类：需要快速跟进处理的工作。 坚持「要事优先」的原则，每天分配时间给重要的事情，我认为这也算是「二八法则」的一种实际应用。 Update time： 2020-08-01 "},"Chapter7/":{"url":"Chapter7/","title":"seaborn","keywords":"","body":"seaborn 参考： Seaborn 0.9 中文文档 Update time： 2020-05-23 "},"Chapter7/Seaborn 简介.html":{"url":"Chapter7/Seaborn 简介.html","title":"Seaborn 简介","keywords":"","body":"Seaborn 简介 Seaborn 是一个基于 matplotlib 且数据结构与 pandas 统一的统计图制作库。 这里列出了一些 seaborn 的功能： 计算多变量间关系的面向数据集接口 可视化类别变量的观测与统计 可视化单变量或多变量分布并与其子数据集比较 控制线性回归的不同因变量并进行参数估计与作图 对复杂数据进行易行的整体结构可视化 对多表统计图的制作高度抽象并简化可视化过程 提供多个内建主题渲染 matplotlib 的图像样式 提供调色板工具生动再现数据 Seaborn 框架旨在以数据可视化为中心来挖掘与理解数据。它提供的面向数据集制图函数主要是对行列索引和数组的操作，包含对整个数据集进行内部的语义映射与统计整合，以此生成富于信息的图表。 下面是一些 🌰 的喵： import seaborn as sns sns.set() tips = sns.load_dataset(\"tips\") sns.relplot(x=\"total_bill\", y=\"tip\", col=\"time\", hue=\"smoker\", style=\"smoker\", size=\"size\", data=tips); 上面发生了什么呢？我们一步步分析： 我们装载 seaborn，这是这个例子唯一需要的 python 库。 import seaborn as sns 此处，seaborn 实际调用了 matplotlib 作图。虽然很多任务都可以直接使用 seaborn 提供的函数来完成，不过一些更深层或者更加个性化的可能需要直接使用 matplotlib 来实现，下面会详细介绍这一点。如果需要获得交互式体验，推荐使用 Jupyter/IPython 工具并开启 matplotlib 模式。否则，在使用交互式工具时如果想要看到图片需要调用 matplotlib.pyplot.show 函数。 我们设置并使用 seaborn 默认的主题、尺寸大小以及调色板。 sns.set() 这里改变了 matplotlib rcParam 系统 所以会影响所有 matplotlib 图像的显示，即使你没有显式的调用 seaborn 修改这些参数。除了缺省的主题，我们提供一些其他选项，你可以独立的控制图片风格与尺寸来将他们迅速应用到演讲当中（例如，在演讲投影中使用一个拥有可阅读字体的图表）。如果你倾向于使用默认 matplotlib 主题或者其他的内置样式，你可以跳过这一部分，只使用 seaborn 提供的制图函数。 装载数据集 tips = sns.load_dataset(\"tips\") 文档中的代码多数会使用 load_dataset() 去取得样例数据集。这些数据集没什么特殊，都是 pandas 的数据结构（dataframes），所以我们也可以使用 pandas.read_csv 或者手动输入创建数据集。在文档中，多数作图都使用 tips 数据集，非常无聊但是就说明状况的作用还是可以。tips 数据集提供了一种“整洁”的整合数据的方式，所以如果你使用这种方式来整合自己的数据，使用 seaborn 再好不过了。下面详细解释为什么。 我们写一个多子图散点图，分配语义变量 sns.relplot(x=\"total_bill\", y=\"tip\", col=\"time\", hue=\"smoker\", style=\"smoker\", size=\"size\", data=tips) 这张图说明了 tips 数据集中五个变量的关系，三个是数值变量，另外两个是类别变量。其中 total_bill 和 tip 这两个数值变量决定了轴上每个点出现的位置，另外一个 size 变量影响着出现点的大小。第一个类别变量 time 将散点图分为两个子图，第二个类别变量 smoker 决定点的形状。 所有上述内容均由 relplot 一次调用生成。注意，在函数调用过程中，我们仅仅使用变量名来划分图像中的不同的语义。如果直接使用 matplotlib ，就必须将变量转换为可视化函数的参数（例如，指定颜色，指定每个类别的制图方式），这在 seaborn 中被自动执行了，以此让使用者将注意力放在他们要解决的问题上。 接口抽象 因为不存在可视化数据的最好方式，每一个制图所描述的问题都有自己最合适的可视化方法。seaborn 旨在让可视化方法间的切换变得更容易，有时仅仅需要改变同一个接口中的参数即可。 函数 relplot() 之所以这样命名是因为设计这个函数的初衷是想让他体现多个统计间的关系。散点图可以很好的体现统计数据间的关系，但是如果有一个变量具有时间意义，那线状图可能更好一点，因此，relplot() 函数提供了一个 kind 接口可以很方便的用作于改变图像的组织方式。 dots = sns.load_dataset(\"dots\") sns.relplot(x=\"time\", y=\"firing_rate\", col=\"align\", hue=\"choice\", size=\"coherence\", style=\"choice\", facet_kws=dict(sharex=False), kind=\"line\", legend=\"full\", data=dots); 参数 size 和 style 被散点图和线状图共享，但是他们对这些可视化结果产生的影响是不同的（例如，改变点大小和线的样式）。这些细节在实际使用中是无需被关注的，我们只需要将注意力放在组织图像的结构与我们想表达的信息中。 估计与误差 我们常常会想知道一个变量的均值函数以便在计算其他变量时作为可用参数。seaborn 的许多函数都可以自动的计算参数估计，这在解决一些问题中是十分必要的。 fmri = sns.load_dataset(\"fmri\") sns.relplot(x=\"timepoint\", y=\"signal\", col=\"region\", hue=\"event\", style=\"event\", kind=\"line\", data=fmri); 估计统计参数时，seaborn 使用了 bootstrap 方法计算置信区间和误差以表示估计的不确定性程度。 Seaborn 还能实现一些不是很好用语言描述统计估计。比如，使用 lmplot() 可以将一个线性回归模型放在散点图当中去： sns.lmplot(x=\"total_bill\", y=\"tip\", col=\"time\", hue=\"smoker\", data=tips); 分类图 标准的散点图和线状图用来可视化数值型数据，但是可能有些变量含有分类信息，之前的做法不再合适。我们提供了一些可视化分类变量的函数，在 catplot() 中可以找到。和 relplot() 相似的地方是，写 catplot() 函数的目的是为了提供一个面向数据集的通用接口，不仅可以显示数值变量，同时展示一个或多个类别变量。 在下面这种图中，你可以改变观测的粒聚集度，最好的情况是，所有的观测值都被调整的恰好到不会重叠但是又是沿着类别轴的： sns.catplot(x=\"day\", y=\"total_bill\", hue=\"smoker\", kind=\"swarm\", data=tips); 你也可以使用核密度估计来表示这些观测可能来源于的样本： sns.catplot(x=\"day\", y=\"total_bill\", hue=\"smoker\", kind=\"violin\", split=True, data=tips); 或者你可以在每个嵌套类别变量中求其唯一均值与置信区间： sns.catplot(x=\"day\", y=\"total_bill\", hue=\"smoker\", kind=\"bar\", data=tips); 图与轴的函数 了解 seaborn 提供的不同函数间的区别非常重要，到目前为止我们见到的函数都是基于 figure-level 的函数。由于直接创建包含子图的 matplotlib 图像，数据得以被沿着轴展开，挖掘数据得到了优化。这些函数还可以做一些比较有技巧性的事情，比如把图例放在轴外。我们可以使用 FacetGrid 来完成这些事情。 每一个 figure-level 的图像 kind （指传给 kind 参数位置的图类别变量）都包含着一个特殊的 axes-level 作为 FacetGrid 的对象。例如，散点图实际上使用的是 scatterplot() 函数，条形图使用的是 barplot() 函数，这些函数被称为 axes-level 因为他们只会作用一个独立 matplotlib 图像轴不会影响到其他剩余轴上的子图。 总之就是 figure-level 函数控制整个图像，axes-level 的函数可以和 matplotlib 图进行更复杂的结合，无论其他轴上的子图是否由 seaborn 作出。 import matplotlib.pyplot as plt f, axes = plt.subplots(1, 2, sharey=True, figsize=(6, 4)) sns.boxplot(x=\"day\", y=\"tip\", data=tips, ax=axes[0]) sns.scatterplot(x=\"total_bill\", y=\"tip\", hue=\"day\", data=tips, ax=axes[1]); 使用 figure-level 函数控制图像大小的方法和控制 matplotlib 图的方法有一点不同。figure-level 函数不会设置整个图的大小，而是调整每个组成图的子图的大小，并且对于子图设定高度与比例，不会去分别设定高度和宽度。这样的参数化形式使得控制图表大小更容易了，并不需要非得仔细计算到底结果图会包含多少行、多少列，即使这样容易让人比较晕： sns.relplot(x=\"time\", y=\"firing_rate\", col=\"align\", hue=\"choice\", size=\"coherence\", style=\"choice\", height=4.5, aspect=2 / 3, facet_kws=dict(sharex=False), kind=\"line\", legend=\"full\", data=dots); 区别 figure-level 函数和 axes-level 函数的方法就是去看函数是否携带一个 ax= 参数。或者你可以查看他们的输出类型：axes-level 函数返回一个 matplotlib axes，figure-level 函数返回一个 FacetGrid。 数据集结构可视化 在 seaborn 中创建多子图的可视化结果有两种方法，两种方法都可以刻画数据集的结构。第一种 jointplot() 方法注重单对单关系： iris = sns.load_dataset(\"iris\") sns.jointplot(x=\"sepal_length\", y=\"petal_length\", data=iris); 另一种是 pairplot() ，提供对数据更为全面的可视化。对于每对数据间的关系以及边缘分布都有考察，你可以选择用哪里分类变量作为条件： sns.pairplot(data=iris, hue=\"species\"); 这两种方法在数据可视化都提供一些自定义选项，他们都是对于两个高度可自定义的多图作图函数 JointGrid 和 PairGrid 再封装。 自定义样式 Seaborn 库选择尽可能美观的设计，并且添加富于信息的标签。如果需要设计更为精致的图片可能会需要多执行一些步骤，这有多种方法。 第一种方法是使用 seaborn 给你的其他的主题。设置了不同的主题或者调色板样式会让整个图的效果都不一样： sns.set(style=\"ticks\", palette=\"muted\") sns.relplot(x=\"total_bill\", y=\"tip\", col=\"time\", hue=\"smoker\", style=\"smoker\", size=\"size\", data=tips); 如果要仅针对图像设计，所有的 seaborn 函数都接受一系列的可选参数来改变默认的语义映射，比如颜色。（对颜色的恰当选择在数据可视化中非常关键，seaborn 提供了[附加支持]http://seaborn.pydata.org/tutorial/color_palettes.html#palette-tutorial) 来引导调色板的使用）。 最后，当 seaborn 的函数与 matploblib 函数具有显然一致性时（例如 scatterplot() 和 plt.scatter），多余的参数会被直接传给 matploblib 层： sns.relplot(x=\"total_bill\", y=\"tip\", col=\"time\", hue=\"size\", style=\"smoker\", size=\"size\", palette=\"YlGnBu\", markers=[\"D\", \"o\"], sizes=(10, 125), edgecolor=\".2\", linewidth=.5, alpha=.75, data=tips); 注意 relplot() 或者其他 figure-level 函数，因为当 relplot() 函数传递一些额外的关键字参数到 seaborn 底层的 axes-level 函数时，相当于将这些参数直接传给了底层 matplotlib 函数，这会使得你寻找对应文档变得有些麻烦，不过原则上是可以做到很高的自定义程度的。 有些 figure-level 的函数自定义可以通过传递额外参数到 FacetGrid 来实现，你可以使用这个对象的方法来控制图像的属性。甚至可以修改需要被作图的 matploblib 对象的值达到效果： g = sns.catplot(x=\"total_bill\", y=\"day\", hue=\"time\", height=3.5, aspect=1.5, kind=\"box\", legend=False, data=tips); g.add_legend(title=\"Meal\") g.set_axis_labels(\"Total bill ($)\", \"\") g.set(xlim=(0, 60), yticklabels=[\"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]) g.despine(trim=True) g.fig.set_size_inches(6.5, 3.5) g.ax.set_xticks([5, 15, 25, 35, 45, 55], minor=True); plt.setp(g.ax.get_yticklabels(), rotation=30); Figure-level 函数作用于需要高效显示数据的情况，所以如果要更精确的调整大小与组织形式，直接使用 matploblib 或者使用对应的 seaborn axes-level 函数。matploblib 具有易于理解和强大的接口，任何有关图像属性的值都可以通过接口来完成设置。最好是将高度抽象的 seaborn 接口和可深度自定义的 matplotlib 接口一起使用来制作达到出版质量的最终成果。 组织数据集 之前提到过，如果你的数据整合的比较好，seaborn 的表现也会很出众。这种能称为做“长型”或者“整洁”数据在这里被详细解释。这些方式可以大致概括为： 每个变量占有一个列 每个观测占有一个行 你的数据是否整洁了？一种比较好的思考方式是去想你要怎么画你的图，从这一点来讲，变量就是图中一种具有规律展现形式的元素。如果看看样例 tips 会比较好： tips.head() total_bill tip sex smoker day time size 0 16.99 1.01 Female No Sun Dinner 2 --- --- --- --- --- --- --- --- 1 10.34 1.66 Male No Sun Dinner 3 --- --- --- --- --- --- --- --- 2 21.01 3.50 Male No Sun Dinner 3 --- --- --- --- --- --- --- --- 3 23.68 3.31 Male No Sun Dinner 2 --- --- --- --- --- --- --- --- 4 24.59 3.61 Female No Sun Dinner 4 --- --- --- --- --- --- --- --- 从某种意义上讲，使用这种组织方式开始可能会感觉尴尬，比如使用时间序列数据，将时间点作为观测值放在列中。我们之前使用的 fmri 数据集展示了一个整洁的时间点在不同行间的组织形式： fmri.head() subject timepoint event region signal 0 s13 18 stim parietal -0.017552 --- --- --- --- --- --- 1 s5 14 stim parietal -0.080883 --- --- --- --- --- --- 2 s12 18 stim parietal -0.081033 --- --- --- --- --- --- 3 s11 18 stim parietal -0.046134 --- --- --- --- --- --- 4 s10 18 stim parietal -0.037970 --- --- --- --- --- --- 许多 seaborn 函数都提供了画出大范围数据图的功能，虽然在函数性上有所限制。要利用好整合较好的数据集，你肯定会使用 pandas.melt 函数来解构一个大的数据集。参考这篇 pandas 开发者写的博客。 Update time： 2020-05-23 "},"Chapter7/Seaborn样式设置.html":{"url":"Chapter7/Seaborn样式设置.html","title":"Seaborn:样式设置","keywords":"","body":"Seaborn 将matplotlib 参数分成两个独立的组。第一组设定了美学风格，第二组则是不同的度量元素，这样就可以很容易地添加到代码当中了。 操作这些参数的接口是两对函数。为了控制样式，使用 axesstyle() 和 setstyle()函数。为了扩展绘图，请使用plotting_context()和set_context()函数。在这两种情况下，第一个函数返回一个参数字典，第二个函数则设置 matplotlib默认属性。 标题样式控制：axes_style() and set_style() 特别的可以通过sns.axes_style(style=None, rc=None) 返回一个sns.set_style()可传的参数的字典 通过类似sns.set_style(\"ticks\", {\"xtick.major.size\": 8, \"ytick.major.size\": 8})的方式写入更具体的配置样式。 seaborn.set_style seaborn.set_style(style=None, rc=None) Parameters: style : dict, None, or one of {darkgrid, whitegrid, dark, white, ticks} A dictionary of parameters or the name of a preconfigured set. rc : dict, optional Parameter mappings to override the values in the preset seaborn style dictionaries. This only updates parameters that are considered part of the style definition. set_style( ),set( ) set_style( )是用来设置主题的，Seaborn 有五个预设好的主题： darkgrid , whitegrid, dark , white ,和 ticks 默认： darkgrid import matplotlib.pyplot as plt import seaborn as sns sns.set_style(\"whitegrid\") plt.plot(np.arange(10)) plt.show() set( )通过设置参数可以用来设置背景，调色板等，更加常用。 seaborn.set(context='notebook', style='darkgrid', palette='deep', font='sans-serif', font_scale=1, color_codes=True, rc=None) 参数：context：string or dict style：string or dict palette：string or sequence font：string font_scale：float, optional color_codes：bool rc：dict or None import seaborn as sns import matplotlib.pyplot as plt sns.set(style=\"white\", palette=\"muted\", color_codes=True) #set( )设置主题，调色板更常用 plt.plot(np.arange(10)) plt.show() seaborn 样式中最重要的元素如果您想要定制seanborn的样式，可以将参数字典传递给axes_style()和set_style()的rc参数。注意，只能通过该方法覆盖样式定义的一部分参数。(然而，更高层次的set()函数接受任何matplotlib参数的字典)。 如果您想要查看包含哪些参数，您可以只调用该函数而不带参数，这将返回当前设置的字典: sns.axes_style() {'axes.axisbelow': True, #轴在图形的下面 'axes.edgecolor': 'white', #边框的颜色 'axes.facecolor': '#EAEAF2', #背景颜色 'axes.grid': True, #是否显示网格 'axes.labelcolor': '.15', 'axes.linewidth': 0.0, 'figure.facecolor': 'white', 'font.family': ['sans-serif'], 'font.sans-serif': ['Arial', 'Liberation Sans', 'Bitstream Vera Sans', 'sans-serif'], 'grid.color': 'white', 'grid.linestyle': '-', 'image.cmap': 'Greys', 'legend.frameon': False, 'legend.numpoints': 1, 'legend.scatterpoints': 1, 'lines.solid_capstyle': 'round', 'text.color': '.15', 'xtick.color': '.15', 'xtick.direction': 'out', 'xtick.major.size': 0.0, 'xtick.minor.size': 0.0, 'ytick.color': '.15', 'ytick.direction': 'out', 'ytick.major.size': 0.0, 'ytick.minor.size': 0.0} 通过plotting_context()和 set_context()调整绘图元素 类似的，还可以使用其中一个名称来调用set_context()来设置参数，您可以通过提供参数值的字典来覆盖参数。 通过更改context还可以独立地扩展字体元素的大小。(这个选项也可以通过顶级set()函数获得）。 seaborn.set_context(context=None, font_scale=1, rc=None) This affects things like the size of the labels, lines, and other elements of the plot, but not the overall style 参数：context：dict, None, or one of {paper, notebook, talk, poster} font_scale：float, optional rc：dict, optional sns.set_context(\"notebook\", font_scale=1.5, rc={\"lines.linewidth\": 2.5}) sinplot() 四种预设，按相对尺寸的顺序(线条越来越粗)，分别是paper，notebook, talk, and poster。notebook的样式是默认的， 类似地(尽管它可能用处不大)，也可以使用with嵌套语句进行临时的设置。 样式和上下文都可以用set()函数快速地进行配置。这个函数还设置了默认的颜色选项，在下一节将详细介绍这一功能。 如何去掉图像上面和右面的刻度和轴线？ despine(fig=None, ax=None, top=True, right=True, left=False, bottom=False, offset=None, trim=False) sns.despine() 如何设置要画的图离轴线的距离? sns.despine(offset=10) 如何设置曲线的宽度? sns.set_context(fontscale=1.5, rc={'lines.linewidth':1.5) 如何设置分度值的字体大小? sns.set_context(fontscale=1.5) 斑驳陆离的调色板 Seaborn让你更容易选择和使用那些适合你数据和视觉的颜色。 %matplotlib inline import numpy as np import seaborn as sns import matplotlib.pyplot as plt sns.set(rc={\"figure.figsize\": (6, 6)}) np.random.seed(sum(map(ord, \"palettes\"))) 简单常用色彩总结： 分类：hls husl Paired Set1~Set3（色调不同） 连续：Blues[蓝s，颜色+s] BuGn[蓝绿] cubehelix（同色系渐变） 离散：BrBG[棕绿] RdBu[红蓝] coolwarm[冷暖]（双色对称） 通过color_palette()创建调色板 最重要的直接设置调色板的函数就是color_palette()。这个函数提供了许多（并非所有）在seaborn内生成颜色的方式。并且它可以用于任何函数内部的palette参数设置（在某些情况下当需要多种颜色时也可以传入到color参数） color_palette()允许任意的seaborn调色板或matplotlib的颜色映射（除了jet，你应该完全不使用它）。它还可以使用任何有效的matplotlib格式指定的颜色列表(RGB元组、十六进制颜色代码或HTML颜色名称)。返回值总是一个RGB元组的列表。 最后，直接调用没有传入参数的color_palette()将返回默认的颜色循环。 对应的函数set_palette()接受相同的参数，并为所有图设置默认的颜色循环。你也可以在with块中使用color_palette()来实现临时的更改调色板配置 通常在不知道数据的具体特征的情况下不可能知道什么类型的调色板或颜色映射对于一组数据来说是最好的。 因此，我们将用三种不同类型的调色板：分类色板、连续色板和离散色板，来区分和使用color_palette()函数。 定性调色板 当您想要区分不具有内在顺序的离散数据块时，定性(分类)调色板是最佳方案。 导入seaborn的同时，会引入默认的颜色循环，由6种颜色构成。并将调用标准matplotlib颜色循环，看起来也更加赏心悦目。 current_palette = sns.color_palette() sns.palplot(current_palette) 默认主题有六种变体，分别为deep, muted,pastel, bright, dark, and colorblind。 使用循环颜色系统 当您要区分任意数量的类别而不强调任何类别时，最简单的方法是在循环颜色空间中绘制间距相等的颜色(在此颜色空间中，色调会发生变化，同时保持亮度和饱和度不变)。这是大多数seaborn函数在处理当需要区分的数据集超过颜色循环中的6种颜色时时所使用的默认方法。 最为常用的方法是使用hls颜色空间——一种简单的RGB值变体。 sns.palplot(sns.color_palette(\"hls\", 8)) hls_palette()函数允许您控制颜色的亮度(lightness)和饱和度(saturation)。 sns.palplot(sns.hls_palette(8, l=.3, s=.8)) seaborn提供了一个husl系统(后来更名为HSLuv)的接口，这也使选择间隔均匀的色调变得容易，同时使亮度和饱和度都更加均匀。 sns.palplot(sns.color_palette(\"husl\", 8)) 类似地，husl_palette()函数也为这个系统提供了一个更灵活的接口。 使用Color Brewer调色板 sns.palplot(sns.color_palette(\"Paired\")) sns.palplot(sns.color_palette(\"Set2\")) 当然，您可能只希望手动指定一组您喜欢的颜色。color_palette()函数会接受一个颜色列表，操作起来也很简单。 flatui = [\"#9b59b6\", \"#3498db\", \"#95a5a6\", \"#e74c3c\", \"#34495e\", \"#2ecc71\"] sns.palplot(sns.color_palette(flatui)) 顺序调色板 sns.palplot(sns.color_palette(\"Blues\")) 与matplotlib类似，您可以通过添加加后缀_r来倒置顺序调色板的顺序。 sns.palplot(sns.color_palette(\"BuGn_r\")) seaborn同样添加了一个小窍门来帮助您创建“深色”调色板，它没有一个很宽的动态范围。在当您需要按顺序映射直线或点时这可能会很有用，因为颜色较亮的线条会比较难以区分。_d sns.palplot(sns.color_palette(\"GnBu_d\")) 顺序 “cubehelix” 调色板 发散调色板 seaborn.set_palette seaborn.set_palette(palette, n_colors=None, desat=None, color_codes=False) 通过searborn调色板设置matplotlib色彩循环 参数：palette：seaborn color paltte | matplotlib colormap | hls | husl 调色板参数。 应该可以被 color_palette() 函数处理。 n_colors：int 色彩循环中的颜色数量。默认数量与palette模式有关, 查看color_palette()文档了解更多内容。 desat：float 每种颜色去饱和的比例。 def sinplot(flip=1): x = np.linspace(0, 14, 100) for i in range(1, 7): plt.plot(x, np.sin(x + i * .5) * (7 - i) * flip) sns.set_palette(\"husl\") sinplot() seaborn.color_palette seaborn.color_palette(palette=None, n_colors=None, desat=None) 返回一个颜色列表来定义一个调色板。 有 deep, muted, bright, pastel, dark, colorblind 六种颜色模式 调用此函数并设置 palette=None 会返回当前 matplotlib 色彩循环。 m=sns.color_palette(palette='bright',n_colors=4 ) matplotlib 调色板的顺序可以通过在调色板名称后添加 “_r” 来倒置，同样，添加 “_d” 可以将调色板设置为深色模式。（这些选项为互斥属性，返回的颜色列表同样可以被取反） 例子 不带参数的调用将返回当前默认颜色循环中的所有颜色： >>> import seaborn as sns; sns.set() >>> sns.palplot(sns.color_palette()) 显示另一个 “seaborn 调色板”，具有与默认 matplotlib 颜色循环相同的基本色调顺序，但颜色更吸引人。默认情况下，使用调色板名称进行调用将返回6种颜色： >>> sns.palplot(sns.color_palette(\"muted\")) 使用一个内置 matplotlib clolormap 的离散值： >>> sns.palplot(sns.color_palette(\"RdBu\", n_colors=7)) 创建自定义 cubehelix 调色板： >>> sns.palplot(sns.color_palette(\"ch:2.5,-.2,dark=.3\")) 使用一个明确的 matplotlib 调色板并降低一些饱和度： >>> sns.palplot(sns.color_palette(\"Set1\", n_colors=8, desat=.5)) 创建 “dark”（深色）matplotlib 顺序调色板变体。(当对应于有序变量的多条线或点进行着色时，如果您不希望最轻的线不可见，则可以使用此选项)： >>> sns.palplot(sns.color_palette(\"Blues_d\")) 作为上下文管理器使用： >>> import numpy as np, matplotlib.pyplot as plt >>> with sns.color_palette(\"husl\", 8): ... _ = plt.plot(np.c_[np.zeros(8), np.arange(8)].T) seaborn.husl_palette seaborn.husl_palette(n_colors=6, h=0.01, s=0.9, l=0.65) 在 HUSL 色调空间中获得一组均匀间隔的颜色。 h, s, 和 l 值应该在 0 和 1 之间。 参数：n_colors：int 调色板中的颜色数 h：float 第一个色调 s：float 饱和度 l：float 亮度 返回值：palette：seaborn 调色板 在 HSL 系统中使用等间距圆形色调创建一个调色板。 例子 使用默认参数创建一个有 10 种颜色的调色板： >>> import seaborn as sns; sns.set() >>> sns.palplot(sns.husl_palette(10)) 创建一个以不同色调值开头的 10 种颜色的调色板： >>> sns.palplot(sns.husl_palette(10, h=.5)) seaborn.hls_palette seaborn.hls_palette(n_colors=6, h=0.01, l=0.6, s=0.65) 在 HLS 色调空间中获取一组均匀间隔的颜色。 h, s, 和 l 值应该在 0 和 1 之间。 参数：n_colors：int 调色板中的颜色数 h：float 第一个色调 l：float 亮度 s：float 饱和度 返回值：palette：seaborn 调色板 在 HUSL 系统中使用等间距圆形色调创建一个调色板。 例子 使用默认参数创建一个有 10 种颜色的调色板： >>> import seaborn as sns; sns.set() >>> sns.palplot(sns.hls_palette(10)) 创建一个以不同色调值开头的 10 种颜色的调色板： >>> sns.palplot(sns.hls_palette(10, h=.5)) 创建一个比默认颜色更暗的 10 种颜色的调色板： >>> sns.palplot(sns.hls_palette(10, l=.4)) seaborn.cubehelix_palette seaborn.cubehelix_palette(n_colors=6, start=0, rot=0.4, gamma=1.0, hue=0.8, light=0.85, dark=0.15, reverse=False, as_cmap=False) 参数：n_colors：int 调色板中的颜色数。 start：float, 0 1) 的颜色。 hue：float, 0 用 cubehelix 系统制作顺序调色板。 生成亮度呈线性减小(或增大)的 colormap。 除了使用这个函数，还可以在 seaborn 中使用字符串速记生成 cubehelix 调色板。 例子 生成默认调色板： >>> import seaborn as sns; sns.set() >>> sns.palplot(sns.cubehelix_palette()) 从相同的起始位置向后旋转： >>> sns.palplot(sns.cubehelix_palette(rot=-.4)) 使用不同的起点和较短的旋转： >>> sns.palplot(sns.cubehelix_palette(start=2.8, rot=.1)) 反转亮度渐变方向： >>> sns.palplot(sns.cubehelix_palette(reverse=True)) 生成一个 colormap 对象： >>> from numpy import arange >>> x = arange(25).reshape(5, 5) >>> cmap = sns.cubehelix_palette(as_cmap=True) >>> ax = sns.heatmap(x, cmap=cmap) 使用 color_palette() 函数接口： >>> sns.palplot(sns.color_palette(\"ch:2,r=.2,l=.6\")) seaborn.dark_palette seaborn.dark_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb') 参数：color：高值的基色 十六进制、RGB 元组或者颜色名字。 n_colors：int, 可选 调色板中的颜色数。 reverse：bool, 可选 如果为 True 值，则反转混合的方向。 as_cmap：bool, optional 如果为 True 值，则返回 matplotlib colormap 而不是列表。 input：{‘rgb’, ‘hls’, ‘husl’, xkcd’} 用于解释输入颜色的颜色空间。前三个选项适用于元组输入，后者适用于字符串输入。 返回值：palette or cmap：seaborn color palette or matplotlib colormap 制作一个混合深色和 color 模式的顺序调色板。 这种调色板适用于数据集的范围从相对低值(不感兴趣)到相对高值(很感兴趣)时。 可以通过多种方式指定 color 参数，包括用于在 matplotlib 中定义颜色的所有选项，以及由 seborn 处理的其他几个颜色空间。也可以使用 XKCD color survey 中的颜色名字数据库。 例子 从一个 HTML 颜色生成一个调色板： >>> import seaborn as sns; sns.set() >>> sns.palplot(sns.dark_palette(\"purple\")) 生成亮度降低的调色板： >>> sns.palplot(sns.dark_palette(\"seagreen\", reverse=True)) 从 HUSL 空间种子生成选项板： >>> sns.palplot(sns.dark_palette((260, 75, 60), input=\"husl\")) 生成一个 colormap 对象： >>> from numpy import arange >>> x = arange(25).reshape(5, 5) >>> cmap = sns.dark_palette(\"#2ecc71\", as_cmap=True) >>> ax = sns.heatmap(x, cmap=cmap) cmap = sns.dark_palette(\"purple\",n_colors=6) sns.set_palette(cmap) seaborn.light_palette seaborn.light_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb') 参数：color：高值的基色 十六进制、RGB 元组或者颜色名字。 n_colors：int, 可选 调色板中的颜色数。 reverse：bool, 可选 如果为 True 值，则反转混合的方向。 as_cmap：bool, optional 如果为 True 值，则返回 matplotlib colormap 而不是列表。 input：{‘rgb’, ‘hls’, ‘husl’, xkcd’} 用于解释输入颜色的颜色空间。前三个选项适用于元组输入，后者适用于字符串输入。 返回值：palette or cmap：seaborn color palette or matplotlib colormap 制作一个混合浅色和 color 模式的顺序调色板。 这种调色板适用于数据集的范围从相对低值(不感兴趣)到相对高值(很感兴趣)时。 可以通过多种方式指定 color 参数，包括用于在 matplotlib 中定义颜色的所有选项，以及由 seborn 处理的其他几个颜色空间。也可以使用 XKCD color survey 中的颜色名字数据库。 例子 从一个 HTML 颜色生成一个调色板： >>> import seaborn as sns; sns.set() >>> sns.palplot(sns.light_palette(\"purple\")) 生成亮度降低的调色板： >>> sns.palplot(sns.light_palette(\"seagreen\", reverse=True)) 从 HUSL 空间种子生成选项板： >>> sns.palplot(sns.light_palette((260, 75, 60), input=\"husl\")) 生成一个 colormap 对象： >>> from numpy import arange >>> x = arange(25).reshape(5, 5) >>> cmap = sns.light_palette(\"#2ecc71\", as_cmap=True) >>> ax = sns.heatmap(x, cmap=cmap) seaborn.diverging_palette seaborn.diverging_palette(h_neg, h_pos, s=75, l=50, sep=10, n=6, center='light', as_cmap=False) 参数：h_neg, h_pos：float in [0, 359] 图的正负范围的锚定色调 s：[0, 100] 范围内的浮点数，可选 图的两个范围的锚定饱和度 l：[0, 100] 范围内的浮点数，可选 图的两个范围的锚定亮度 n：int，可选 调色板中的颜色数（如果为not，返回一个colormap） center：{“light”, “dark”}, 可选 调色板中心为亮或暗 as_cmap：bool, 可选 如果为 true，返回一个 matplotlib colormap 而不是一个颜色列表。 返回值：palette or cmap：seaborn color palette or matplotlib colormap 类似列表的颜色对象的 RGB 元组，或者可以将连续值映射到颜色的 colormap 对象，具体取决于 as_cmap 参数的值。 在两个 HUSL 颜色直接建立一个发散调色板。 另外 创建具有暗值的连续调色板。创建具有亮值的连续调色板。 例子 生成一个蓝-白-红调色板： >>> import seaborn as sns; sns.set() >>> sns.palplot(sns.diverging_palette(240, 10, n=9)) 生成一个更亮的绿-白-紫调色板： >>> sns.palplot(sns.diverging_palette(150, 275, s=80, l=55, n=9)) 生成一个蓝-黑-红调色板: >>> sns.palplot(sns.diverging_palette(250, 15, s=75, l=40, ... n=9, center=\"dark\")) 生成一个 colormap 对象: >>> from numpy import arange >>> x = arange(25).reshape(5, 5) >>> cmap = sns.diverging_palette(220, 20, sep=20, as_cmap=True) >>> ax = sns.heatmap(x, cmap=cmap) Update time： 2020-05-23 "},"Chapter7/分类数据图.html":{"url":"Chapter7/分类数据图.html","title":"分类数据图","keywords":"","body":"分类数据图 在统计关系可视化教程中，我们学会了使用多种不同的方式来展示一个数据集中多个变量之间的关系。在一系列的例子中，我们聚焦于那些关系主要存在于两个数值型变量之间的情况。然而当其中一个变量是分类（离散）变量时，我们不妨使用更加有针对性的可视化方法。 在 seaborn 中，有多种不同的方式来展示包含了分类数据的变量关系。正如relplot()和scatterplot()/lineplot()之间的关系一样，我们可以使用catplot()函数来描述分类数据，也可以使用更多坐标轴级别的绘图函数来完成这些任务。catplot()提供了对这些axes-level的函数的整合，将他们放在了一个更高级别的统一的接口之中。 将分类可视化图形分为三类 分类散点图 stripplot() #或catplot(kind=\"strip\") swarmplot() #或catplot(kind=\"swarm\") 分类分布图 boxplot() #或 catplot(kind=\"box\") violinplot() #或 catplot(kind=\"violin\") boxenplot() #或 catplot(kind=\"boxen\") 分类统计估计图 pointplot() # 或 catplot(kind=\"point\") barplot() # 或 catplot(kind=\"bar\") countplot() #或 catplot(kind=\"count\") 这些分类从不同的粒度来展示数据。 catplot()提供的统一的API可以帮助我们轻松地在不同方法间切换并从不同的视角理解数据。 分类散点图 catplot catplot() 默认的处理方式就是散点图。在绘制分类散点图时，我们会遇到一个挑战，当在同一个类别中出现大量取值相同或接近的观测数据时，他们会挤到一起。 seaborn 中有两种分类散点图，分别以不同的方式处理了这个问题。catplot() 使用的默认方式是 stripplot()，它给这些散点增加了一些随机的偏移量： 默认类型 stripplot import seaborn as sns import matplotlib.pyplot as plt sns.set(style=\"ticks\", color_codes=True) tips = sns.load_dataset(\"tips\") sns.catplot(x=\"day\", y=\"total_bill\", data=tips) 参数 jitter jitter 参控制着偏移量的大小，或者我们可以直接禁止他们偏移： sns.catplot(x=\"day\", y=\"total_bill\", jitter=False, data=tips) 参数：kind=\"swarm\" 第二种解决方式使用算法避免了散点之间的重合。它提供了更好的方式来呈现观测点的分布，但是它仅适用于较小的数据集。这种图被叫做蜂群图，在seaborn 中我们用swarmplot()或者 catplot(kind=“swarm”)来绘制它： sns.catplot(x=\"day\", y=\"total_bill\", kind=\"swarm\", data=tips) 参数：hue 与关系图(relplot())类似，我们也可以使用hue参数来增加一个新的维度（但是分类图不支持size和style）。不同的分类图对于hue 参数的处理不太一样，对于散点图而言，它仅仅控制散点的颜色就足够了： sns.catplot(x=\"day\", y=\"total_bill\", hue=\"sex\", kind=\"swarm\", data=tips) “分类坐标轴”，在这些例子中，我们的分类水平都与水平坐标轴绑定。但是有些时候我们把分类变量放在垂直坐标轴上会更有帮助（尤其是当分类名称较长或者分类较多时）。我们只需要交换x和y分配的变量即可： sns.catplot(x=\"total_bill\", y=\"day\", hue=\"time\", kind=\"swarm\", data=tips) 参数：order 我们还可以通过order参数指定分类的顺序，当我们需要绘制多个分类变量图时这一点会很重要： sns.catplot(x=\"smoker\", y=\"tip\", order=[\"No\", \"Yes\"], data=tips) 分类分布图 当数据集的大小越来越大，分类散点图在表现不同分类的观测值的分布信息时就越发显得捉襟见肘。此时，我们有一些方法，能以清晰明了的对比方式来总结不同分类下的观测值分布信息。 箱线图 boxplot(): 或 catplot(kind=\"box\") 箱线图。它能在图中展现出数据的上下四分位数、中位数以及一些极值。箱体上下方的须线会分别向上和向下延伸1.5倍IQR（上下四分位数之间的距离），落在这个区域之外的点会单独显示为离群点（异常值） sns.catplot(x=\"day\", y=\"total_bill\", kind=\"box\", data=tips) 参数 hue 我们可以增加一个hue参数，这样就可以进一步增加一个维度来观察数据分布： sns.catplot(x=\"day\", y=\"total_bill\", hue=\"smoker\", kind=\"box\", data=tips) 参数：dodge 这种操作叫做“dodging”，它会默认保持打开，因为它假设 hue 参数对应的变量与坐标轴上的分类变量是相互嵌套的。假如事实并非如此，我们可以关闭“dodging”： tips[\"weekend\"] = tips[\"day\"].isin([\"Sat\", \"Sun\"]) sns.catplot(x=\"day\", y=\"total_bill\", hue=\"weekend\", kind=\"box\", dodge=False,data=tips) 增强箱图 Boxenplot 小提琴图 分类统计估计图 在某些应用场景中，相对于展示每个分类的数据分布，我们可能更想展示每个分类中数据的集中趋势估计（统计量，比如均值、中位数、方差等）。seaborn 有两种方式来展示此类信息。需要知道的是，这些函数基本的API与前边提到的那些绘图函数是一致的。 条形图 一种常见的图形是条形图。在seaborn中，barplot()函数在整个数据集上运行，并且应用一个函数来获得那些统计量（默认为均值）。当每个分类中有多个观测值时，它还可以通过 自助采样法 计算出一个置信区间，并且通过误差棒的方式绘制出来。 titanic = pd.read_csv('titanic.csv') sns.catplot(x=\"sex\", y=\"survived\", hue=\"class\", kind=\"bar\", data=titanic) countplot 一个特例是我们想要展示每个分类下观测值（样本）的数量而非统计量。这就像是“属于分类变量而非连续变量的直方图”。在seaborn中，我们可以使用countplot()轻易地达成目的： 参数：kind=count sns.catplot(x=\"deck\", kind=\"count\", palette=\"ch:.25\", data=titanic) barplot()和countplot()在调用的时候支持所有我们在上边讨论过的选项（参数），同时一些额外支持的参数在它们各自的详细文档中可以找到 sns.catplot(y=\"deck\", hue=\"class\", kind=\"count\", palette=\"pastel\", edgecolor=\".6\", data=titanic) 点图 我们也可以使用pointplot()来表现同样的信息。点图也使用高度来编码统计量，但是区别在于它不会画出一个完整的长条，而是用一个点以及置信区间来替代；另外，它还会将属于同一个hue分类的点连起来。这样，我们就可以很容易看到hue变量是如何影响坐标轴上的分类变量的（交互作用），因为不同线条的斜率简直是一目了然： sns.catplot(x=\"sex\", y=\"survived\", hue=\"class\", kind=\"point\", data=titanic) 分类绘图函数是没有style这一参数的（在relplot()中有）。但是我们同样可以修改线条和点的样式，使得我们的图片更有可读性，甚至可以在黑白色调下表现分类信息（考虑到色盲读者时，黑白色调会很有帮助）： sns.catplot(x=\"class\", y=\"survived\", hue=\"sex\", palette={\"male\": \"g\", \"female\": \"m\"}, markers=[\"^\", \"o\"], linestyles=[\"-\", \"--\"], kind=\"point\", data=titanic) 使用子图展示多重关系 与relplot()一样，calplot()也是基于FacetGrid构建，这意味着我们可以轻易地通过更多子图来表现高维的关系： sns.catplot(x=\"day\", y=\"total_bill\", hue=\"smoker\", col=\"time\", aspect=.6, kind=\"swarm\", data=tips) 当我们想要定制更多细节时，我们就需要使用FacetGrid对象支持的方法了： g = sns.catplot(x=\"fare\", y=\"survived\", row=\"class\", kind=\"box\", orient=\"h\", height=1.5, aspect=4, data=titanic.query(\"fare > 0\")) g.set(xscale=\"log\") 参考： Seaborn中文教程（二）：分类数据 Update time： 2020-05-23 "},"Chapter7/数据集的分布.html":{"url":"Chapter7/数据集的分布.html","title":"数据集的分布","keywords":"","body":"数据集的分布 当我们上手一个数据集时，往往第一件事就是了解每个变量是如何分布的。seaborn中检验一元分布和二元（维）分布。你也许会对如何对比一个变量在其他变量的不同水平下的分布有什么差异，在分类数据可视化教程中，你可以找到答案。 一元分布的可视化 在seaborn中，查看单变量分布情况最方便的方法就是使用distplot()函数。默认情况下，它会画一个直方图，并且做一个核密度估计（KDE） import numpy as np import pandas as pd import seaborn as sns import matplotlib.pyplot as plt from scipy import stats sns.set(color_codes=True) x = np.random.normal(size=100) sns.distplot(x) 直方图 直方图我们应该都很熟悉了，matplotlib中也有一个hist()函数来绘制直方图。直方图将数据划分到多个数据桶中，然后对每个桶中的样本进行计数，并将它们以长条的形式画出来。 我们通过演示来理解这个过程：去掉密度曲线，并且加一个“地毯图”（rugplot）。地毯图会在每个观测值的位置添加一个垂直的线段小标记。我们可以使用rugplot()来仅仅绘制地毯图，不过它在distplot()中已经得到了支持： # 高度和下方标记的密集度是成正比的 sns.distplot(x, kde=False, rug=True) 参数 bins 在绘制直方图时，最主要的选择就是指定数据桶的数量以及它们的边界。distplot()默认会用一条简单的规则来猜测多少个数据桶最合适，不过尝试更多或更少的分桶也许能帮助我们揭示数据的更多特性： sns.distplot(x, bins=20, kde=False, rug=True) 核密度估计 我们对核密度估计可能不太熟悉，但是它在展示数据分布形状方面很有用。与直方图类似，KDE图用高度对观测值的密度进行编码： sns.distplot(x, hist=False, rug=True) 相对于直方图，KDE图的绘制有更高的计算复杂度。在KDE的计算中，首先每个观测值会被替换为一条以该观测点为中心的正态曲线 接下来，我们把所有的曲线都叠加起来，得到每个点上的密度。然后我们把最终的曲线正则化（归一化），这样曲线下方的面积加起来刚好是1 如果我们直接用kdeplot()函数，那我们会得到同样的结果。distplot()中集成了这个函数，但是当我们只想绘制密度估计图时，kdeplot()能提供更直接的接口以及更多的选项。 拟合指定的分布 可以使用distplot()将数据拟合到一个指定的分布形态，我们可以在视觉上评估它们有多接近： 二元分布可视化 将两个变量的联合分布形态可视化出来往往会很有用。在seaborn中，最简单的实现方式是使用jointplot()函数，它会生成多个面板，不仅展示了两个变量之间的关系，也在两个坐标轴上分别展示了每个变量的分布。 散点图 最常见的展示二元分布的方法是使用散点图，我们使用x、y两个坐标轴来定位每一个观测值。它类似于二维的地毯图。我么可以使用matplotlib中的plt.scatter()函数来绘制散点图，同时，jointplot()的默认绘制类型也是散点图。 mean, cov = [0, 1], [(1, .5), (.5, 1)] data = np.random.multivariate_normal(mean, cov, 200) df = pd.DataFrame(data, columns=[\"x\", \"y\"]) sns.jointplot(x=\"x\", y=\"y\", data=df) 六边图 六边图（Hexbin），可以视为二维世界中的直方图，因为它展示了每个小六边形中观测点的数量。这种图在大数据集上表现最佳。我们使用matplotlib的plt.hexbin函数以及seaborn的jointplot(kind=\"hex\")都可以绘制它。 x, y = np.random.multivariate_normal(mean, cov, 1000).T with sns.axes_style(\"white\"): sns.jointplot(x=x, y=y, kind=\"hex\", color=\"k\") 核密度估计 核密度估计也适用于二元的情况。在seaborn中，这种图会以等高线的方式展示出来，我们可以用jointplot(kind=\"kde\")来绘制它 我们也可以直接使用kdeplot()来绘制二维的核密度估计图。这允许我们直接在某个指定的matplotlib坐标轴上（包括已存在的坐标轴体系）绘制这类图形。作为对比，在jointplot()中我们只能创建一个新的图来生成核密度估计图。 f, ax = plt.subplots(figsize=(6, 6)) sns.kdeplot(df.x, df.y, ax=ax) sns.rugplot(df.x, color=\"g\", ax=ax) sns.rugplot(df.y, vertical=True, ax=ax) jointplot()函数基于JointGrid对象来控制图形。我们可以直接使用JointGrid来获得更高的灵活性。jointplot()在绘制完成后会返回一个JointGrid对象，我们可以通过它来增加更多图层或者调整其他细节 g = sns.jointplot(x=\"x\", y=\"y\", data=df, kind=\"kde\", color=\"m\") g.plot_joint(plt.scatter, c=\"w\", s=30, linewidth=1, marker=\"+\") g.ax_joint.collections[0].set_alpha(0) g.set_axis_labels(\"$X$\", \"$Y$\") 数据集中成对关系的可视化 成对关系的可视化是指在一个数据集的所有变量中，两两之间的关系。假如我们想要看多个变量中两两组合之间的联合分布情况，我们可以使用pairplot()函数，它会创建一个由多个坐标轴构成的矩阵，然后把两两之间（一般是DataFrame的列之间的组合）的关系分别绘制在不同的坐标轴上去。默认情况下，它还会将每个变量自己的分布情况画在对角线的位置： iris = pd.read_csv(\"iris.csv\") sns.pairplot(iris) 参考 数据集的分布 Update time： 2020-05-23 "},"Chapter7/线性关系展示.html":{"url":"Chapter7/线性关系展示.html","title":"线性关系展示","keywords":"","body":"线性关系展示 许多数据集含有多个定量变量（数值型变量），而我们分析的目的往往是将他们关联起来。我们曾讨论过通过两个变量的联合分布来实现这一点。然而，使用统计模型来为两组带有噪声数据的观测值评估出一个简单的关系可以是非常有用的。这一章节我们讨论的函数将会在线性回归的框架下实现这种预测。 seaborn中的回归图主要是为了在EDA（探索数据分析）阶段为发掘数据中存在的规律提供一些视觉指引，也就是说，seaborn本身并非是一个用于统计分析的库。想要得到关于回归模型拟合效果的一些量化指标，你需要使用statsmodels库。seaborn的终极目标就是让我们通过可视化快速、轻易地探索数据，毕竟对于探索数据来说，可视化的重要性不比得到一个统计表格低。 绘制线性回归模型 seaborn主要通过两个函数来展示通过回归得到的线性关系，regplot()和lmplot()。它们紧密相关，而且共享大多数的核心功能。但是弄清楚他们的区别非常重要，这样我们就可以在针对特定工作时快速判断哪个工具更适合。 在最基本的调用过程中，他们都会画出关于x、y两个变量的散点图，同时用数据拟合一个y ~ x的模型出来，并将对应的直线和95%的置信区间绘制出来： import numpy as np import pandas as pd import seaborn as sns import matplotlib.pyplot as plt sns.set(color_codes=True) tips = pd.read_csv(\"tips.csv\") sns.regplot(x=\"total_bill\", y=\"tip\", data=tips) plt.savefig('r1.png') sns.lmplot(x=\"total_bill\", y=\"tip\", data=tips) 注意到除了图片的形状略有差异，其他地方都是一致的。需要知道的是，他们之间最主要的区别在于regplot()中的x, y参数接受多种数据类型，包括numpy数组、pandas序列（Series），或者将pandas DataFrame传递给data参数。作为对比，lmplot()的data参数是不能为空的，同时x和y参数必须以字符串形式指定。这种数据格式（这里是指regplot()支持而lmplot()不支持的类似一维数组的数据格式）被称为“long-form data”或“tidy data”。除了这一输入格式的灵活性以外，regplot()仅提供了lmplot()特性的一部分 seaborn支持其中一个变量属于离散变量的情况，不过这种数据集产生的散点图效果往往一般： sns.lmplot(x=\"size\", y=\"tip\", data=tips) 增加一些随机的偏移量会让这些分布看起来更清晰，需要注意的是这些偏移量仅仅会影响散点图的效果，不会对拟合的回归线产生干扰： sns.lmplot(x=\"size\", y=\"tip\", data=tips, x_jitter=.05) 另一个选择是将每个离散桶内的观测值隐藏起来，用代表集中趋势的统计量以及置信区间作为替代 sns.lmplot(x=\"size\", y=\"tip\", data=tips, x_estimator=np.mean); 拟合不同的模型 简单线性回归的模型非常容易拟合，然而它并不适用于所有数据集。Anscombe's quartet数据集展示了一些例子，在这些例子中简单线性回归提供了变量间关系一致的估计，但是却与我们视觉上的直观判断存在一些差异。比如，在第一个例子中，线性回归是一个很不错的模型： anscombe = pd.read_csv(\"anscombe.csv\") sns.lmplot(x=\"x\", y=\"y\", data=anscombe.query(\"dataset == 'I'\"), ci=None, scatter_kws={\"s\": 80}) 第二个数据集中有着同样的线性关系，但是我们瞬间就能判断线性回归并不是一个最佳的模型： sns.lmplot(x=\"x\", y=\"y\", data=anscombe.query(\"dataset == 'II'\"), ci=None, scatter_kws={\"s\": 80}) 在展示这种更高阶的关系时，lmplot()和regplot()可以通过拟合多项式回归模型来应对数据集中的一些简单的非线性趋势： sns.lmplot(x=\"x\", y=\"y\", data=anscombe.query(\"dataset == 'II'\"), order=2, ci=None, scatter_kws={\"s\": 80}) 另一个问题是由异常观测点导致的，这些观测点明显偏离了我们想要得到的主要趋势关系 sns.lmplot(x=\"x\", y=\"y\", data=anscombe.query(\"dataset == 'III'\"), ci=None, scatter_kws={\"s\": 80}) 在异常观测值存在时，我们可以拟合一个鲁棒回归(稳定回归)，它使用了不同的损失函数，对较大的残差做了降权： sns.lmplot(x=\"x\", y=\"y\", data=anscombe.query(\"dataset == 'III'\"), robust=True, ci=None, scatter_kws={\"s\": 80}) residplot()函数可以检查一个简单的回归模型对于某个数据集是否合适。它先拟合一个简单线性回归模型并移除它，然后将每个观测点与预测值的残差画出来。理想情况下，这些残差应该随机地分布在x轴上下方 sns.residplot(x=\"x\", y=\"y\", data=anscombe.query(\"dataset == 'I'\"), scatter_kws={\"s\": 80}) 如果残差的分布具有某种规律，那说明简单线性回归或许并不是一个好的选择： sns.residplot(x=\"x\", y=\"y\", data=anscombe.query(\"dataset == 'II'\"), scatter_kws={\"s\": 80}) relplot() 它用散点图和线图两种常用的手段来表现统计关系。 relplot() 使用两个坐标轴级别的函数来结合了FacetGrid： scatterplot()：(使用kind=\"scatter\"，这是默认参数) lineplot()：(使用`kind=“line”) ﻿我们用的最多的是relplot()。这是一个图形级别的函数，它用散点图和线图两种常用的手段来表现统计关系。 relplot()使用两个坐标轴级别的函数来结合了FacetGrid： scatterplot()：(使用kind=\"scatter\"，这是默认参数) lineplot()：(使用`kind=\"line\") import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns sns.set(style=\"darkgrid\") 用散点图展示相关变量 散点图是统计图形中的中流砥柱。它用一系列的散点将两个变量的联合分布描绘出来，其中每个点就是一个观测样本。这种描述方式可以让我们从视觉上推断出大量信息，来判断两个变量之间是否存在某种有意义的关系。 在seaborn中，我们有数种方法可以实现散点图的绘制。最基本的一种适用于两个变量都是数值型变量的情况，它就是scatterplot()。在分类可视化教程中，我们会看到如何绘制分类数据的散点图。 relplot()的默认类型(kind)就是scatterplot()（当然，我们也可以强制指定参数kind=\"scatter\"，这和不指定这一参数时效果是一样的）。 tips = sns.load_dataset(\"tips\") sns.relplot(x=\"total_bill\", y=\"tip\", data=tips) 参数hue 当我们已经将散点绘制在二维的平面上时，我们还可以根据第三个变量来对这些点施以不同的颜色，从而引入一个新的维度。在seaborn中，我们用hue参数实现了这种想法，因为点的颜色是有意义的。 参数`hue` 如果我们想要强调不同分类之间的差异，同时增加易读性，我们可以对不同的分类使用不同的标记样式： sns.relplot(x=\"total_bill\", y=\"tip\", hue=\"smoker\", style=\"smoker\", data=tips) 参数：style 我们也可以同时展示四个变量，只需要将hue和style参数单独调整到不同的分类变量即可。但是我们要谨慎使用这种方法，因为我们的眼睛对于形状的敏感性远远不如对颜色的敏感性。 sns.relplot(x=\"total_bill\", y=\"tip\", hue=\"smoker\", style=\"time\", data=tips) 在上边这个例子中，hue参数对应的变量是分类型数据，因此seaborn自动为它应用了默认的定性(分类)调色板。如果hue参数对应的变量是数值型的(可转化为浮点数的)，那么默认的颜色也会随之变为连续的定量调色板。 上述两种情况下（分类或连续数据），我们都可以自定义我们的调色板。有很多选项可以实现这一目的。下面，我们使用cubehelix_palette()的字符串接口来定制我们的连续调色板： sns.relplot(x=\"total_bill\", y=\"tip\", hue=\"size\", palette=\"ch:r=-.5,l=.75\", data=tips) 参数size 我们还可以使用点的大小来引入第三个额外的变量： sns.relplot(x=\"total_bill\", y=\"tip\", size=\"size\", data=tips); 参数sizes 与matplotlib.pyplot.scatter()不同的是，这里并不是使用原始数据中的数值来为每个点选择面积大小，seaborn将原始数据归一化（正则化）到了某个范围，这个范围可以由我们来指定： sns.relplot(x=\"total_bill\", y=\"tip\", size=\"size\", sizes=(15, 200), data=tips) 二、使用线图表现连续性 在某些数据集中，我们可能想要理解某个变量随着时间的变化规律，或者想要理解某个连续型的变量。这种情况下，线图会是一个不错的选择。在seaborn中，我们可以通过lineplot()函数或者使用带有kind=\"line\"参数的relplot()来实现线图的绘制。 df = pd.DataFrame(dict(time=np.arange(500), value=np.random.randn(500).cumsum())) g = sns.relplot(x=\"time\", y=\"value\", kind=\"line\", data=df) g.fig.autofmt_xdate() 参数：sort 由于lineplot()假设用户在大多数情况下是在尝试描绘y相对于x的函数（变化规律），因此它在绘制之前会默认先对x做一个排序。不过我们可以禁止它。 聚合并展示不确定性 参数：ci 在更多复杂的数据集中，会出现一个x轴变量对应了多个观测值（y）的情况。seaborn会默认将多个观测值聚合起来，并且将它们的均值以及95%的置信区间展示出来： ```python fmri = sns.load_dataset(\"fmri\") sns.relplot(x=\"timepoint\", y=\"signal\", kind=\"line\", data=fmri) ``` ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191031132949346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hIRzIwMTcxMjI2,size_16,color_FFFFFF,t_70) 置信区间是通过`自助采样法（bootstrapping）`计算的，这在遇到大型数据集时可以帮助我们节省时间。当然，我们也可以禁止它。 另一个不错的选择是，我们可以用标准差替代置信区间来展示每个时间点下观测值的分布，当数据集比较大时这一选择尤其明智。 ```python sns.relplot(x=\"timepoint\", y=\"signal\", kind=\"line\", ci=\"sd\", data=fmri) ``` ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191031133320459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hIRzIwMTcxMjI2,size_16,color_FFFFFF,t_70) #### 参数：`ciestimator` 如果想要关闭所有的聚合操作，我们可以设置estimator=None。不过当同一时间点存在多个观测值时，我们的图会看起来有些奇怪。 sns.relplot(x=\"timepoint\", y=\"signal\", estimator=None, kind=\"line\", data=fmri ) 通过参数映射可视化数据子集 lineplot()与scatterplot()一样具有很强的灵活性：它也可以通过hue、size和style参数来展示额外的三个变量。它和scatterplot()使用了相同的API，因此我们不需要停下来绞尽脑汁地思考哪些参数是用来控制线条、哪些参数是用来控制散点。 使用不同的参数会决定我们的数据如何聚合。比如，增加一个具有两个水平的分类变量作为hue参数，会将我们的图形分为两条线以及两个误差带，并分别施以不同的颜色来区分数据的分类归属。 sns.relplot(x=\"timepoint\", y=\"signal\", hue=\"event\", kind=\"line\", data=fmri) 我们可以增加一个·style参数，以不同的线条样式来展示不同的分类： sns.relplot(x=\"timepoint\", y=\"signal\", hue=\"region\", style=\"event\", kind=\"line\", data=fmri) 我们还可以设置不同分类的标记样式，标记样式既可以和线条样式同时设置，也可以各自单独设置。 sns.relplot(x=\"timepoint\", y=\"signal\", hue=\"region\", style=\"event\", dashes=False, ## markers=True, kind=\"line\", data=fmri) 跟散点图一样，我们要慎重使用这些参数来展示太多变量。有些时候它们会展示丰富的信息，但是有些时候它们会使图形太过复杂导致我们难以解析和解释它。然而当你仅打算考虑额外的一个变量时，同时修改它们的颜色和样式会很有帮助。 sns.relplot(x=\"timepoint\", y=\"signal\", hue=\"event\", style=\"event\", kind=\"line\", data=fmri); 当我们需要应对重复测量的数据时，我们可以将不同的抽样单元（单次实验观测到的数据系列）分离开来展示，这并不需要我们使用一个语义参数(hue/style/size)。后者会导致图例看起来像一个灾难（想象一下几十个分类的情况）: sns.relplot(x=\"timepoint\", y=\"signal\", hue=\"region\", units=\"subject\", estimator=None, kind=\"line\", data=fmri.query(\"event == 'stim'\")); 与scatterplot()类似，lineplot()默认的调色板以及图例处理方式也取决于hue对应的数据是分类型还是连续数值型。 ots = sns.load_dataset(\"dots\").query(\"align == 'dots'\") sns.relplot(x=\"time\", y=\"firing_rate\", hue=\"coherence\", style=\"choice\", kind=\"line\", data=dots); 当hue参数对应的变量的数据是均匀分布在对数刻度上的（即数据分布范围非常大，比如从1到1亿），即使是连续的调色板也无法很好地应对这种情况。但是我们可以使用列表或者字典对每条线指定一个颜色。 palette = sns.cubehelix_palette(light=.8, n_colors=6) sns.relplot(x=\"time\", y=\"firing_rate\", hue=\"coherence\", style=\"choice\", palette=palette, kind=\"line\", data=dots); 参数`size` sns.relplot(x=\"time\", y=\"firing_rate\", size=\"coherence\", style=\"choice\", kind=\"line\", data=dots); 绘制时间序列数据 线图常用来描绘日期、时间相关的诗句。这些方法以原始格式传入更底层的matplotlib函数中，这样它们就可以利用matplotlib的能力来格式化日期数据。但是所有的时间格式化过程都是在matplotlib层实现的，想要知道更多实现的细节就需要去看一下matplotlib中关于这部分的文档： df = pd.DataFrame(dict(time=pd.date_range(\"2017-1-1\", periods=500), value=np.random.randn(500).cumsum())) g = sns.relplot(x=\"time\", y=\"value\", kind=\"line\", data=df) g.fig.autofmt_xdate() 三、用更多子图展示多重关系 前边我们已经强调过，虽然我们可以在一张图中展示数个不同的语义变量(通过hue/style/size参数)，但是这么做并不是总会高效。那么当我们真的很想理解在某些额外变量的影响下两个变量之间的关系有什么不同时怎么办呢？ 最好的办法就是画更多的图。由于relplot()是基于FacetGrid的，因此这很容易做到。当我们想要表现出一个额外变量的影响时，我们可以不用将它赋给前边提到的语义参数(hue/style/size)，而是用它来将图形“面板”化。这意味着我们会创建多个坐标轴，分别用来绘制不同的子数据集： 参数：col sns.relplot(x=\"total_bill\", y=\"tip\", hue=\"smoker\", col=\"time\", data=tips); 我们还可以同时使用col（列）和row（行）参数来展示两个变量的影响。当我们在图中增加了更多的变量时（会有更多的子图），我们可能会想要调整图形的大小。要记住在FacetGrid中，我们用height（子图高度）和aspect（高宽比）来定制每个子图的大小： sns.relplot(x=\"timepoint\", y=\"signal\", hue=\"subject\", col=\"region\", row=\"event\", height=3, kind=\"line\", estimator=None, data=fmri) 参数：col_wrap 当我们想要检验某个具有大量水平的变量的影响时，我们可以将这个变量赋给col参数，同时我们通过col_wrap参数设置每行达到多少列就换行： sns.relplot(x=\"timepoint\", y=\"signal\", hue=\"event\", style=\"event\", col=\"subject\", col_wrap=5, height=3, aspect=.75, linewidth=2.5, kind=\"line\", data=fmri.query(\"region == 'frontal'\")); 这种常被叫做“格子图”或“small-multiples”的可视化方式，非常高效，因为它们呈现数据的方式使得我们很容易同时发现整体的模式以及不同模式之间的偏差。当你需要利用scatterplot()和relplot()的灵活性来表现更多信息时，一定要记住，多幅简单的图通常比一幅复杂的图更加高效。 散点图 scatterplot seaborn.scatterplot(x=None, y=None, hue=None, style=None, size=None, data=None, palette=None, hue_order=None, hue_norm=None, sizes=None, size_order=None, size_norm=None, markers=True, style_order=None, x_bins=None, y_bins=None, units=None, estimator=None, ci=95, n_boot=1000, alpha='auto', x_jitter=None, y_jitter=None, legend='brief', ax=None, **kwargs) data: DataFrame 可选参数 x,y为数据中变量的名称; 作用：对将生成具有不同颜色的元素的变量进行分组。可以是分类或数字. size：数据中的名称 作用：根据指定的名称(列名)，根据该列中的数据值的大小生成具有不同大小的效果。可以是分类或数字。 style:数据中变量名称(比如：二维数据中的列名) 作用：对将生成具有不同破折号、或其他标记的变量进行分组。 palette:调试板名称，列表或字典类型 作用：设置hue指定的变量的不同级别颜色。 hue_order:列表(list)类型 作用：指定hue变量出现的指定顺序，否则他们是根据数据确定的。 hue_norm:tuple或Normalize对象 sizes:list dict或tuple类型 作用：设置线宽度，当其为数字时，它也可以是一个元组，指定要使用的最大和最小值，会自动在该范围内对其他值进行规范化。 Update time： 2020-05-23 "},"Chapter7/构建结构化多图网格.html":{"url":"Chapter7/构建结构化多图网格.html","title":"构建结构化多图网格","keywords":"","body":"构建结构化多图网格 在探索中等维度数据时，经常需要在数据集的不同子集上绘制同一类型图的多个实例。这种技术有时被称为“网格”或“格子”绘图，它与“多重小图”的概念有关。这种技术使查看者从复杂数据中快速提取大量信息。 Matplotlib 为绘制这种多轴图提供了很好的支持; seaborn 构建于此之上，可直接将绘图结构和数据集结构关系起来。 要使用网格图功能，数据必须在 Pandas 数据框中，并且必须采用 Hadley Whickam 所谓的 “整洁”数据的形式。简言之，用来画图的数据框应该构造成每列一个变量，每一行一个观察的形式。 至于高级用法，可以直接使用本教程中讨论的对象，以提供最大的灵活性。一些 seaborn 函数（例如lmplot()，catplot()和pairplot()）也在后台使用它们。与其他在没有操纵图形的情况下绘制到特定的（可能已经存在的）matplotlib Axes上的“Axes-level” seaborn 函数不同，这些更高级别的函数在调用时会创建一个图形，并且通常对图形的设置方式更加严格。在某些情况下，这些函数或它们所依赖的类构造函数的参数将提供不同的接口属性，如lmplot()中的图形大小，你可以设置每个子图的高和宽高比。但是，使用这些对象的函数在绘图后都会返回它，并且这些对象大多都有方便简单的方法来改变图的绘制方式。 import seaborn as sns import matplotlib.pyplot as plt sns.set(style=\"ticks\") 基于一定条件的多重小图 当你想在数据集的不同子集中分别可视化变量分布或多个变量之间的关系时，FacetGrid类非常有用。 FacetGrid最多有三个维：row，col和hue。前两个与轴(axes)阵列有明显的对应关系;将色调变量hue视为沿深度轴的第三个维度，不同的级别用不同的颜色绘制。 首先，使用数据框初始化FacetGrid对象并指定将形成网格的行，列或色调维度的变量名称。这些变量应是离散的，然后对应于变量的不同取值的数据将用于沿该轴的不同小平面的绘制。例如，假设我们想要在tips数据集中检查午餐和晚餐小费分布的差异。 此外，relplot()，catplot()和lmplot()都在内部使用此对象，并且它们在完成时返回该对象，以便进一步调整。 tips = sns.load_dataset(\"tips\") g = sns.FacetGrid(tips, col=\"time\") 如上初始化网格会设置 matplotlib 图形和轴，但不会在其上绘制任何内容。 在网格上可视化数据的主要方法是FacetGrid.map()。为此方法提供绘图函数以及要绘制的数据框变量名作为参数。我们使用直方图绘制每个子集中小费金额的分布。 g = sns.FacetGrid(tips, col=\"time\") g.map(plt.hist, \"tip\"); map函数绘制图形并注释轴，生成图。要绘制关系图，只需传递多个变量名称。还可以提供关键字参数，这些参数将传递给绘图函数： g = sns.FacetGrid(tips, col=\"sex\", hue=\"smoker\") g.map(plt.scatter, \"total_bill\", \"tip\", alpha=.7) g.add_legend(); 有几个传递给类构造函数的选项可用于控制网格外观。 g = sns.FacetGrid(tips, row=\"smoker\", col=\"time\", margin_titles=True) g.map(sns.regplot, \"size\", \"total_bill\", color=\".3\", fit_reg=False, x_jitter=.1); 注意，matplotlib API 并未正式支持margin_titles，此选项在一些情况下可能无法正常工作。特别是，它目前不能与图之外的图例同时使用。 通过提供每个面的高度以及纵横比来设置图形的大小： g = sns.FacetGrid(tips, col=\"day\", height=4, aspect=.5) g.map(sns.barplot, \"sex\", \"total_bill\"); /Users/mwaskom/code/seaborn/seaborn/axisgrid.py:715: UserWarning: Using the barplot function without specifying order is likely to produce an incorrect plot. warnings.warn(warning) 小图的默认排序由 DataFrame 中的信息确定的。如果用于定义小图的变量是类别变量，则使用类别的顺序。否则，小图将按照各类的出现顺序排列。但是，可以使用适当的* _order参数指定任意构面维度的顺序： ordered_days = tips.day.value_counts().index g = sns.FacetGrid(tips, row=\"day\", row_order=ordered_days, height=1.7, aspect=4,) g.map(sns.distplot, \"total_bill\", hist=False, rug=True); 可以用 seaborn 调色板（即可以传递给color_palette()的东西。）还可以用字典将hue变量中的值映射到 matplotlib 颜色： pal = dict(Lunch=\"seagreen\", Dinner=\"gray\") g = sns.FacetGrid(tips, hue=\"time\", palette=pal, height=5) g.map(plt.scatter, \"total_bill\", \"tip\", s=50, alpha=.7, linewidth=.5, edgecolor=\"white\") g.add_legend(); 还可以让图的其他方面（如点的形状）在色调变量的各个级别之间变化，这在以黑白方式打印时使图易于理解。为此，只需将一个字典传递给 hue_kws，其中键是绘图函数关键字参数的名称，值是关键字值列表，每个级别为一个色调变量。 g = sns.FacetGrid(tips, hue=\"sex\", palette=\"Set1\", height=5, hue_kws={\"marker\": [\"^\", \"v\"]}) g.map(plt.scatter, \"total_bill\", \"tip\", s=100, linewidth=.5, edgecolor=\"white\") g.add_legend(); 如果一个变量的水平数过多，除了可以沿着列绘制之外，也可以“包装”它们以便它们跨越多行。执行此 wrap 操作时，不能使用row变量。 attend = sns.load_dataset(\"attention\").query(\"subject /Users/mwaskom/code/seaborn/seaborn/axisgrid.py:715: UserWarning: Using the pointplot function without specifying order is likely to produce an incorrect plot. warnings.warn(warning) 使用FacetGrid.map() （可以多次调用）绘图后，你可以调整绘图的外观。 FacetGrid对象有许多方法可以在更高的抽象层次上操作图形。最一般的是FacetGrid.set()，还有其他更专业的方法，如FacetGrid.set_axis_labels()，它们都遵循内部构面没有轴标签的约定。例如： with sns.axes_style(\"white\"): g = sns.FacetGrid(tips, row=\"sex\", col=\"smoker\", margin_titles=True, height=2.5) g.map(plt.scatter, \"total_bill\", \"tip\", color=\"#334488\", edgecolor=\"white\", lw=.5); g.set_axis_labels(\"Total bill (US Dollars)\", \"Tip\"); g.set(xticks=[10, 30, 50], yticks=[2, 6, 10]); g.fig.subplots_adjust(wspace=.02, hspace=.02); 对于需要更多自定义的情形，你可以直接使用底层 matplotlib 图形Figure和轴Axes对象，它们分别作为成员属性存储在Figure和轴Axes（一个二维数组）中。在制作没有行或列刻面的图形时，你还可以使用ax属性直接访问单个轴。 g = sns.FacetGrid(tips, col=\"smoker\", margin_titles=True, height=4) g.map(plt.scatter, \"total_bill\", \"tip\", color=\"#338844\", edgecolor=\"white\", s=50, lw=1) for ax in g.axes.flat: ax.plot((0, 50), (0, .2 * 50), c=\".2\", ls=\"--\") g.set(xlim=(0, 60), ylim=(0, 14)); 使用自定义函数 使用FacetGrid时，你除了可以使用现有的 matplotlib 和 seaborn 函数，还可以使用自定义函数。但是，这些函数必须遵循一些规则： 它必须绘制到“当前活动的”matplotlib 轴Axes上。 matplotlib.pyplot命名空间中的函数就是如此。如果要直接使用当前轴的方法，可以调用plt.gca来获取对当前Axes的引用。 它必须接受它在位置参数中绘制的数据。在内部，FacetGrid将为传递给FacetGrid.map()的每个命名位置参数传递一Series数据。 它必须能接受color和label关键字参数，理想情况下，它会用它们做一些有用的事情。在大多数情况下，最简单的方法是捕获** kwargs的通用字典并将其传递给底层绘图函数。 让我们看一下自定义绘图函数的最小示例。这个函数在每个构面采用一个数据向量： from scipy import stats def quantile_plot(x, **kwargs): qntls, xr = stats.probplot(x, fit=False) plt.scatter(xr, qntls, **kwargs) g = sns.FacetGrid(tips, col=\"sex\", height=4) g.map(quantile_plot, \"total_bill\"); 如果你想要制作一个双变量图，编写函数则应该有分别接受 x 轴变量，y 轴变量的参数： def qqplot(x, y, **kwargs): _, xr = stats.probplot(x, fit=False) _, yr = stats.probplot(y, fit=False) plt.scatter(xr, yr, **kwargs) g = sns.FacetGrid(tips, col=\"smoker\", height=4) g.map(qqplot, \"total_bill\", \"tip\"); 因为plt.scatter接受颜色和标签关键字参数并做相应的处理，所以我们可以毫无困难地添加一个色调构面： g = sns.FacetGrid(tips, hue=\"time\", col=\"sex\", height=4) g.map(qqplot, \"total_bill\", \"tip\") g.add_legend(); 这种方法还允许我们使用额外的美学元素来区分色调变量的级别，以及不依赖于分面变量的关键字参数： g = sns.FacetGrid(tips, hue=\"time\", col=\"sex\", height=4, hue_kws={\"marker\": [\"s\", \"D\"]}) g.map(qqplot, \"total_bill\", \"tip\", s=40, edgecolor=\"w\") g.add_legend(); 有时候，你需要使用color和label关键字参数映射不能按预期方式工作的函数。在这种情况下，你需要显式捕获它们并在自定义函数的逻辑中处理它们。例如，这种方法可用于映射plt.hexbin，使它与FacetGrid API 匹配： def hexbin(x, y, color, **kwargs): cmap = sns.light_palette(color, as_cmap=True) plt.hexbin(x, y, gridsize=15, cmap=cmap, **kwargs) with sns.axes_style(\"dark\"): g = sns.FacetGrid(tips, hue=\"time\", col=\"time\", height=4) g.map(hexbin, \"total_bill\", \"tip\", extent=[0, 50, 0, 10]); 绘制成对数据关系 PairGrid允许你使用相同的绘图类型快速绘制小子图的网格。在PairGrid中，每个行和列都分配给一个不同的变量，结果图显示数据集中的每个对变量的关系。这种图有时被称为“散点图矩阵”，这是显示成对关系的最常见方式，但是PairGrid不仅限于散点图。 了解FacetGrid和PairGrid之间的差异非常重要。前者每个构面显示以不同级别的变量为条件的相同关系。后者显示不同的关系（尽管上三角和下三角组成镜像图）。使用PairGrid可为你提供数据集中有趣关系的快速，高级的摘要。 该类的基本用法与FacetGrid非常相似。首先初始化网格，然后将绘图函数传递给map方法，并在每个子图上调用它。还有一个伴侣函数， pairplot() ，可以更快的绘图。 iris = sns.load_dataset(\"iris\") g = sns.PairGrid(iris) g.map(plt.scatter); 可以在对角线上绘制不同的函数，以显示每列中变量的单变量分布。但请注意，轴刻度与该绘图的计数或密度轴不对应。 g = sns.PairGrid(iris) g.map_diag(plt.hist) g.map_offdiag(plt.scatter); 此图的一种常见用法是通过单独的分类变量对观察结果进行着色。例如，iris 数据集三种不同种类的鸢尾花都有四种测量值，因此你可以看到不同花在这些取值上的差异。 g = sns.PairGrid(iris, hue=\"species\") g.map_diag(plt.hist) g.map_offdiag(plt.scatter) g.add_legend(); 默认情况下，使用数据集中的每个数值列，但如果需要，你可以专注于特定列。 g = sns.PairGrid(iris, vars=[\"sepal_length\", \"sepal_width\"], hue=\"species\") g.map(plt.scatter); 也可以在上三角和下三角中使用不同的函数来强调关系的不同方面。 g = sns.PairGrid(iris) g.map_upper(plt.scatter) g.map_lower(sns.kdeplot) g.map_diag(sns.kdeplot, lw=3, legend=False); 对角线上具有单位关系的方形网格实际上只是一种特殊情况，你也可以在行和列中使用不同的变量进行绘图。 g = sns.PairGrid(tips, y_vars=[\"tip\"], x_vars=[\"total_bill\", \"size\"], height=4) g.map(sns.regplot, color=\".3\") g.set(ylim=(-1, 11), yticks=[0, 5, 10]); 当然，美学属性是可配置的。例如，你可以使用不同的调色板（例如，显示色调变量的顺序）并将关键字参数传递到绘图函数中。 g = sns.PairGrid(tips, hue=\"size\", palette=\"GnBu_d\") g.map(plt.scatter, s=50, edgecolor=\"white\") g.add_legend(); PairGrid很灵活，但要快速查看数据集，使用pairplot()更容易。此函数默认使用散点图和直方图，但会添加一些其他类型（目前，你还可以绘制非对角线上的回归图和对角线上的 KDE）。 sns.pairplot(iris, hue=\"species\", height=2.5); 还可以使用关键字参数控制绘图的美观，函数会返回PairGrid实例以便进一步调整。 g = sns.pairplot(iris, hue=\"species\", palette=\"Set2\", diag_kind=\"kde\", height=2.5) Update time： 2020-05-23 "},"Chapter7/控制图像的美学样式aesthetics.html":{"url":"Chapter7/控制图像的美学样式aesthetics.html","title":"控制图像的美学样式(aesthetics)","keywords":"","body":"控制图像的美学样式(aesthetics) 绘制有吸引力的图像很十分重要的。当你在探索一个数据集并为你自己做图的时候，制作一些让人看了心情愉悦的图像是很好的。可视化对向观众传达量化的简介也是很重要的，在这种情况下制作能够抓住查看者的注意力并牢牢吸引住他们的图像就更有必要了。 Matplotlib 是高度可定制的，但是很难知道要如何设置图像才能使得图像更加吸引人。Seaborn 提供了许多定制好的主题和高级的接口，用于控制 Matplotlib 所做图像的外观。 import numpy as np import seaborn as sns import matplotlib.pyplot as plt 让我们定义一个简单的函数来绘制一些偏移正弦波，这将帮助我们看到我们可以调整的能够影响图像风格的不同参数。 def sinplot(flip=1): x = np.linspace(0, 14, 100) for i in range(1, 7): plt.plot(x, np.sin(x + i * .5) * (7 - i) * flip) 这是 Matplotlib 默认情况下的绘图外观： sinplot() 为了将图像的风格转变为 seaborn 的默认样式，我们可以 set() 函数。 sns.set() sinplot() （注意，在 0.8 之前的 seaborn 版本中， set() 已经在使用 impory 语句导入的时候就被调用了。但在以后的版本中，必须要显式调用它）。 Seaborn 将 matplotlib 参数分成两个独立的组。第一组设置了图像的美术风格，第二组则对图像中不同的元素进行了控制，使得图像可以很容易地融入不同的环境中。 操作这些参数的接口是两对函数。要控制样式，请使用 axes_style() 和 set_style() 函数。要对图像中元素的样式进行修改，请使用 plotting_context() 和 set_context() 函数。在这两种情况下（控制图像样式与修改元素样式），第一个函数会返回一个参数字典，第二个函数设置 matplotlib 中相关参数的默认值。 Seaborn 图像参数 有五个预设的 Seaborn 主题： darkgrid，whitegrid，dark，white以及 ticks。它们分别适用于不同的应用程序和个人偏好。默认主题为 darkgrid。如上所述，坐标方格有助于将制出的图像用作定量信息的查阅表，灰色背景上的白色有助于防止网格与表示数据的行发生竞争。 whitegrid 主题类似，但它更适用于包含大量数据元素的绘图： sns.set_style(\"whitegrid\") data = np.random.normal(size=(20, 6)) + np.arange(6) / 2 sns.boxplot(data=data); 对许多的图像而言，（尤其是在你只是想通过图像来提供给人们一个对数据模式的印象时，比如说作报告时）坐标网格都是不必要的。 sns.set_style(\"dark\") sinplot() sns.set_style(\"white\") sinplot() 有时，您可能希望为绘图提供一点额外的结构，这正是 tick 样式的用武之地： sns.set_style(\"ticks\") sinplot() 移除坐标轴 white 样式与 ticks 样式的好处是都能删除所不需要的顶部与右部坐标轴。使用 seaborn 中的函数 despine() 可以来移除它们： sinplot() sns.despine() 有些图的好处在于，可以让坐标的主轴随着数据进行偏移，这可以使用 despine()函数来完成。当刻度无法覆盖轴的整个范围时，trim参数将限制不受影响的坐标轴的范围。 f, ax = plt.subplots() sns.violinplot(data=data) sns.despine(offset=10, trim=True); 你也可以通过控制 despine()的额外参数来删除坐标轴： sns.set_style(\"whitegrid\") sns.boxplot(data=data, palette=\"deep\") sns.despine(left=True) 设置临时图像格式 虽然来回切换很容易，但你也可以在with语句中使用 axes_style() 函数来临时设置绘图参数。 这也允许您使用不同风格的坐标轴制作图形： f = plt.figure() with sns.axes_style(\"darkgrid\"): ax = f.add_subplot(1, 2, 1) sinplot() ax = f.add_subplot(1, 2, 2) sinplot(-1) 覆盖控制 seaborn 样式的元素 如果你想要自己定制 seaborn 的样式，你可以通过给 axes_style() 与set_style()函数中的 rc 参数传递一个参数字典来实现。请注意，您只能通过此方法覆盖作为样式定义一部分的参数。（但是，更高级别的 set() 函数会获取任何 matplotlib 参数的字典）。 如果你想看看包含哪些参数，你可以只调用没有参数的函数，这将返回当前设置： sns.axes_style() {'axes.axisbelow': True, 'axes.edgecolor': '.8', 'axes.facecolor': 'white', 'axes.grid': True, 'axes.labelcolor': '.15', 'axes.spines.bottom': True, 'axes.spines.left': True, 'axes.spines.right': True, 'axes.spines.top': True, 'figure.facecolor': 'white', 'font.family': ['sans-serif'], 'font.sans-serif': ['Arial', 'DejaVu Sans', 'Liberation Sans', 'Bitstream Vera Sans', 'sans-serif'], 'grid.color': '.8', 'grid.linestyle': '-', 'image.cmap': 'rocket', 'lines.solid_capstyle': 'round', 'patch.edgecolor': 'w', 'patch.force_edgecolor': True, 'text.color': '.15', 'xtick.bottom': False, 'xtick.color': '.15', 'xtick.direction': 'out', 'xtick.top': False, 'ytick.color': '.15', 'ytick.direction': 'out', 'ytick.left': False, 'ytick.right': False} 然后，您可以设置这些参数的不同版本： sns.set_style(\"darkgrid\", {\"axes.facecolor\": \".9\"}) sinplot() 缩放图像元素 一组独立的参数控制绘图元素的比例，这允许您使用相同的代码来制作在适合使用不同大小图片场景下的图片。 首先，让我们通过调用 set()来重置默认的参数： sns.set() 按照相对大小的顺序排序，四个预设环境是 paper， notebook， talk与 poster。 notebook样式是默认样式，上文中的图就是使用该样式绘制的。 sns.set_context(\"paper\") sinplot() sns.set_context(\"talk\") sinplot() sns.set_context(\"poster\") sinplot() 您现在知道的关于样式函数的大部分内容应该转移到环境函数中。 你可以通过在调用 set_context() 时指定环境的名字来设置参数，你也可以通过提供一个参数字典来覆盖原有的参数值。 你也在转换环境的时候独立地对字符元素的大小进行缩放。（这个操作也能够顶层的 set() 函数来实现）。 sns.set_context(\"notebook\", font_scale=1.5, rc={\"lines.linewidth\": 2.5}) sinplot() 同样的，你也可以暂时的通过嵌套在 with 语句下的语句来实现图像的缩放。 样式和环境都可以使用 set() 函数快速配置。 此函数还设置默认调色板，但更详细的介绍将在本教程的 下一节 进行叙述。 Update time： 2020-05-23 "},"Chapter7/选择调色板.html":{"url":"Chapter7/选择调色板.html","title":"选择调色板","keywords":"","body":"选择调色板 颜色在图像风格中比起其他元素显得更为重要。当合理有效地使用颜色时，数据模式会被凸显出来；反之，则会被掩盖。这里有很多数据可视化中关于颜色使用的优秀资源，我推荐阅读这些 Rob Simmon 的博客文章以及这篇更加学术性的论文。 此外，matplotlib 文档也提供了一篇很好的教程来说明一些内置 Colormap 的感知属性。 seaborn 让您在选择与您处理的数据类型和可视化过程中搭配的配色方案变得简单。 import numpy as np import seaborn as sns import matplotlib.pyplot as plt sns.set() 创建调色板 使用离散调色板过程中最重要函数是color_palette()。这个函数为许多(但不是全部)可以在 seaborn 中生成颜色的方式提供了一个接口，并且在任何具有palette参数的函数的内部都可以使用(以及某些需要多种颜色时具有color参数的情况)。 color_palette() 会接受所有的 seaborn 调色板或者 matplotlib Colormap (除了 jet, 您永远都不应该使用它). 它还可以获取以任何有效 matplotlib 格式(RGB 元组、十六进制颜色代码或 HTML 颜色名字)指定的颜色列表。返回值始终是 RGB 元组的列表。 最后，在没有参数的情况下调用color_palette()函数将会返回当前默认的颜色循环。 函数set_palette()接受相同的参数，并将为所有图像设置默认的颜色循环。您也可以在with语句中调用color_palette()来临时改变调色板。(参见) 在不了解数据特征的情况下，通常也不可能知道哪种调色板或 Colormap 最适合一组数据。接下来，我们将通过三种常见的调色板 定性调色板 , 顺序调色板 , 和 发散调色板 来拆分介绍color_palette()函数的使用方法以及其他 seaborn 函数。 定性调色板 当您想要区分不具有内在顺序的离散数据块时，定性(分类)调色板是最佳方案。 导入 seaborn 的同时，会引入默认的颜色循环，由 6 种颜色构成。并将调用标准 matplotlib 颜色循环，看起来也更加赏心悦目。 current_palette = sns.color_palette() sns.palplot(current_palette) 默认主题有六种变体，分别为deep, muted, pastel, bright, dark, and colorblind。 使用循环颜色系统 当您要区分任意数量的类别而不强调任何类别时，最简单的方法是在循环颜色空间中绘制间距相等的颜色(在此颜色空间中，色调会发生变化，同时保持亮度和饱和度不变)。这是大多数 seaborn 函数在处理当需要区分的数据集超过颜色循环中的 6 种颜色时时所使用的默认方法。 最为常用的方法是使用hls颜色空间——一种简单的 RGB 值变体。 sns.palplot(sns.color_palette(\"hls\", 8)) hls_palette()函数允许您控制颜色的亮度(lightness)和饱和度(saturation)。 sns.palplot(sns.hls_palette(8, l=.3, s=.8)) 然而，由于人类视觉系统的工作方式，RGB 强度很高的颜色也不一定看起来同样强烈。我们认为黄色和绿色是相对较亮的，蓝色是相对较暗的，当目标是与hls系统保持一致性时可能会带来一些问题。 为了解决这一问题，seaborn 提供了一个husl系统(后来更名为 HSLuv)的接口，这也使选择间隔均匀的色调变得容易，同时使亮度和饱和度都更加均匀。 sns.palplot(sns.color_palette(\"husl\", 8)) 类似地，husl_palette()函数也为这个系统提供了一个更灵活的接口。 使用 Color Brewer 调色板 Color Brewer为定性调色板提供了另一种美观的配色方案(同样包含顺序调色板包括和发散调色板，详情见下文)。这些也作为 matplotlib Colormap 存在，但并没有得到很好的处理。在 seaborn 中，当您需要定性(qualitative)的 Color Brewer 方案时，你总是会得到离散的颜色，但这意味着在某些情况下颜色会循环重复。 Color Brewer 的一个很好的特点是它对色盲比较友好。色盲有很多种，最为常见的是红绿色盲。通常，对于需要根据颜色进行元素区分时，应该尽量避免使用这两种颜色。 sns.palplot(sns.color_palette(\"Paired\")) sns.palplot(sns.color_palette(\"Set2\")) 为了帮助您从 Color Brewer 库中选取配色方案，seaborn 提供了choose_colorbrewer_palette()函数。这个函数能够启动交互式组件来帮助您浏览各种选项，修改不同的参数。但是只能在 Jupyter notebook 中使用。 当然，您可能只希望手动指定一组您喜欢的颜色。color_palette()函数会接受一个颜色列表，操作起来也很简单。 flatui = [\"#9b59b6\", \"#3498db\", \"#95a5a6\", \"#e74c3c\", \"#34495e\", \"#2ecc71\"] sns.palplot(sns.color_palette(flatui)) 使用来自 xkcd color survey 的颜色名字 不久前，xkcd开展了一项众包工作来为随机 RGB 颜色命名。产生了954 个颜色名字，您现在可以在 seaborn 中使用xkcd_rgb字典来引用它们： plt.plot([0, 1], [0, 1], sns.xkcd_rgb[\"pale red\"], lw=3) plt.plot([0, 1], [0, 2], sns.xkcd_rgb[\"medium green\"], lw=3) plt.plot([0, 1], [0, 3], sns.xkcd_rgb[\"denim blue\"], lw=3); 除了从xkcd_rgb字典中提取单一颜色外，您也可以向xkcd_palette()函数传递一个颜色名字列表。 colors = [\"windows blue\", \"amber\", \"greyish\", \"faded green\", \"dusty purple\"] sns.palplot(sns.xkcd_palette(colors)) 顺序调色板 第二类主要的调色板被称为“顺序调色板”(sequential)，当数据集的范围从相对低值(不感兴趣)到相对高值(很感兴趣)时，最好使用顺序调色板，尽管在某些情况下您可能需要顺序调色板中的离散颜色。在kdeplot()和heatmap()函数中使用它们来作为 Colormap 则更为常见(以及类似的 matplotlib 函数)。 在这种情况下使用jet（或其他彩虹调色板）等 Colormap 是很常见的，因为色调范围给人的印象是提供有关数据的额外信息。然而，具有较大色调变化的 Colormap 往往会引入数据中不存在的不连续性，并且我们的视觉系统无法自然地将彩虹光谱映射到诸如“高”或“低”的定量区分。导致来这些可视化的结果更加令人困惑，因为它们掩盖了数据中的模式，而不是揭示它们。jet 调色板使用了最亮的颜色(黄色和青色)的中间数据值，导致效果是强调无趣的(和任意的)值，而不是强调极端的值。 对于连续性的数据，最好使用色调变化幅度较小，而亮度和饱和度变化幅度较大的配色方案。这种方法会很自然地吸引人们注意数据中相对重要的部分。 Color Brewer 库有大量这样的配色方案，它们以调色板中主要的一种或多种颜色命名。 sns.palplot(sns.color_palette(\"Blues\")) 与 matplotlib 类似，您可以通过添加加后缀_r来倒置顺序调色板的顺序。 sns.palplot(sns.color_palette(\"BuGn_r\")) seaborn 同样添加了一个小窍门来帮助您创建“深色”调色板，它没有一个很宽的动态范围。在当您需要按顺序映射直线或点时这可能会很有用，因为颜色较亮的线条会比较难以区分。 sns.palplot(sns.color_palette(\"GnBu_d\")) 您可能想要使用choose_colorbrewer_palette()函数来尝试多种选项，当您希望传递给 seaborn 或者 matplotlib 的返回值为 Colormap 对象时，您可以将as_cmap对象设置为True。 顺序 “cubehelix” 调色板 cubehelix调色板系统使顺序调色板的亮度产生线性变化，色调也会产生一些变化。这意味着您的 Colormap 在转换为黑白模式时(用于打印)的信息将得到保留，且对色盲友好。 Matplotlib 内置了默认的 cubehelix 版本： sns.palplot(sns.color_palette(\"cubehelix\", 8)) Seborn 为 cubehelix 系统提供了一个接口，以便您可以制作各种调色板，这些调色板都具有良好的线性亮度渐变。 由 seborn cubehelix_palette() 函数返回的默认调色板与 matplotlib 的默认值稍有不同，因为它不会围绕色轮旋转很远，也不会覆盖很宽的强度范围。它还反转顺序，以便让更重要的值的颜色更暗： sns.palplot(sns.cubehelix_palette(8)) cubehelix_palette() 函数的其他参数控制调色板的外观。您将更改的两个主要参数为 start (介于 0 到 3 之间的值)和 rot —— 旋转次数(任意值，但可能在-1 和 1 之间)。 sns.palplot(sns.cubehelix_palette(8, start=.5, rot=-.75)) 您还可以控制端点的亮度，甚至反转渐变： sns.palplot(sns.cubehelix_palette(8, start=2, rot=0, dark=0, light=.95, reverse=True)) 如同其他 seaborn 函数，您将默认得到一个颜色列表。但您也可以通过修改 as_cmap=True 将调色板作为 Colormap 对象的返回值来传递给 seaborn 或 matplotlib 函数。 x, y = np.random.multivariate_normal([0, 0], [[1, -.5], [-.5, 1]], size=300).T cmap = sns.cubehelix_palette(light=1, as_cmap=True) sns.kdeplot(x, y, cmap=cmap, shade=True); 为了帮助您选择更好的调色板或者 Colormap，您可以在 Jupyter notebook 中使用 choose_cubehelix_palette() 函数来启动互动界面帮助您测试、修改不同的参数。如果您希望函数返回一个 Colormap(而不是列表)，则在例如像 hexbin 这样的函数中设置 as_Cmap=True。 自定义调色板 为了更简单地生成自定义顺序调色板，您可以使用 light_palette() 或 dark_palette() 函数。它们都是以某个颜色为种子，从明向暗或从暗向明渐变，产生顺序调色板。与这些函数相搭配的还有 choose_light_palette() 和 choose_dark_palette() 来提供交互式组件便于创建调色板。 sns.palplot(sns.light_palette(\"green\")) sns.palplot(sns.dark_palette(\"purple\")) 这些调色板同样可以被反转。 sns.palplot(sns.light_palette(\"navy\", reverse=True)) 这些调色板同样可以被用来创建 Colormap 对象而不是颜色列表。 pal = sns.dark_palette(\"palegreen\", as_cmap=True) sns.kdeplot(x, y, cmap=pal); 默认情况下，输入可以是任何有效的 matplotlib 颜色。替代解释由 input 参数控制。现在，您可以在 hls 或 husl 空间中提供元组以及默认的 rgb，您也可以使用任何有效的 xkcd 颜色来生成调色板。 sns.palplot(sns.light_palette((210, 90, 60), input=\"husl\")) sns.palplot(sns.dark_palette(\"muted purple\", input=\"xkcd\")) 注意，交互式调色板小部件的默认输入空间是 husl，它不同于函数本身的默认设置，但是在这种情况下更有用。 发散调色板 第三类调色板称为“发散调色板”(diverging)。当数据集的低值和高值都很重要，且数据集中有明确定义的中点时，这会是您的最佳选择。例如，绘制温度相对于基准时间点的变化图时，最好使用发散 Colormap 来同时显示温度相对于基准值的上升和下降 选择良好分散调色板的规则类似于良好的顺序调色板。不过在这种情况时需要注意两端颜色向中间颜色渐变时中间点的颜色不应该喧宾夺主，两端的颜色也应该具有相似的亮度和饱和度。 这里还需要强调的是，应该避免使用红色和绿色，因为需要考虑到红绿色盲患者的观感。 不出所料，Color Brewer 库也同样提供了一些精心挑选的发散调色板。 sns.palplot(sns.color_palette(\"BrBG\", 7)) sns.palplot(sns.color_palette(\"RdBu_r\", 7)) matplotlib 库中内置的 coolwarm 调色板也是一个很好的选择。请注意，这个 Colormap 的中间值和极值之间的对比度较小。 sns.palplot(sns.color_palette(\"coolwarm\", 7)) 自定义发散调色板 您可以使用 seaborn 的diverging_palette()函数来创建自定义 colormap 来描述发散数据(搭配有交互式组件choose_diverging_palette())。此函数使用 husl 颜色系统来创建发散调色板，您需要在函数中设置两个色调参数(用度表示)，也可以选择设置两端颜色的亮度和饱和度。 使用 husl 意味着两端到中间点的色调变化将是平衡的。 sns.palplot(sns.diverging_palette(220, 20, n=7)) sns.palplot(sns.diverging_palette(145, 280, s=85, l=25, n=7)) sep 参数控制两端到中间点色调变化的间隔。 sns.palplot(sns.diverging_palette(10, 220, sep=80, n=7)) 也可以将中间点的颜色设置成暗色而非亮色。 sns.palplot(sns.diverging_palette(255, 133, l=60, n=7, center=\"dark\")) 设置默认调色板 与color_palette()函数相伴随的有set_palette()。 两者之间的关系与美学教程中介绍的set_palette()函数和color_palette()函数接受相同参数的关系相类似。但它会更改默认的 matplotlib 参数，以便调色板应用于所有图像。 def sinplot(flip=1): x = np.linspace(0, 14, 100) for i in range(1, 7): plt.plot(x, np.sin(x + i * .5) * (7 - i) * flip) sns.set_palette(\"husl\") sinplot() 您可以在 with 语句中通过 color_palette() 函数来临时改变调色板。 with sns.color_palette(\"PuBuGn_d\"): sinplot() Update time： 2020-05-23 "},"Chapter7/seaborn.relplot.html":{"url":"Chapter7/seaborn.relplot.html","title":"seaborn.relplot","keywords":"","body":"seaborn.relplot seaborn.relplot(x=None, y=None, hue=None, size=None, style=None, data=None, row=None, col=None, col_wrap=None, row_order=None, col_order=None, palette=None, hue_order=None, hue_norm=None, sizes=None, size_order=None, size_norm=None, markers=None, dashes=None, style_order=None, legend='brief', kind='scatter', height=5, aspect=1, facet_kws=None, **kwargs) 绘制相关关系图像到 FacetGrid 的图像级别接口。 此函数提供对一些不同轴级别函数的访问，这些函数通过子集的语义映射显示两个变量之间的关系。kind参数选择要使用的基础轴级函数： scatterplot() （通过kind=\"scatter\"访问；默认为此） lineplot() (通过kind=\"line\"访问) 额外的关键字参数会被传递给隐含的函数，因此使用时应当参考对应函数的文档去了解各种选项。 对于数据不同子集的x与y的绘制关系可以通过hue, size以及style参数控制。这些参数控制使用哪些视觉语义来区分不同的子集。使用所有三个语义类型可以独立展示三个维度，但是这种方式得到的绘制结果难以被理解而且低效。使用多种语义（例如对相同变量同时使用hue及style）可以使图像更加易懂。 参考tutorial获得更多信息。 绘制后，会返回带有图像的FacetGrid，随后可以直接进行图像细节调节或者加入其他图层。 值得注意的是，与直接使用隐含函数的方式不同，数据必须以长格式的 DataFrame 传入，同时变量通过x, y及其他参数指定。 参数：x, y：data中的变量名 输入数据的变量；数据必须为数值型。 hue: data中的名称，可选 将会产生具有不同颜色的元素的变量进行分组。这些变量可以是类别变量或者数值型变量，尽管颜色映射在后面的情况中会有不同的表现。 size：data中的名称，可选 将会产生具有不同尺寸的元素的变量进行分组。这些变量可以是类别变量或者数值型变量，尽管尺寸映射在后面的情况中会有不同的表现。 style：data中的名称，可选 将会产生具有不同风格的元素的变量进行分组。这些变量可以为数值型，但是通常会被当做类别变量处理。 data：DataFrame 长格式的 DataFrame，每列是一个变量，每行是一个观察值。 row, col：data中的变量名，可选 确定网格的分面的类别变量。 col_wrap：int, 可选 以此宽度“包裹”列变量，以便列分面跨越多行。与row分面不兼容。 row_order, col_order：字符串列表，可选 以此顺序组织网格的行和/或列，否则顺序将从数据对象中推断。 palette：色盘名，列表，或者字典，可选 用于hue变量的不同级别的颜色。应当是color_palette()可以解释的东西，或者将色调级别映射到 matplotlib 颜色的字典。 hue_order：列表，可选 指定hue变量层级出现的顺序，否则会根据数据确定。当hue变量为数值型时与此无关。 hue_norm：元组或者 Normalize 对象，可选 当hue变量为数值型时，用于数据单元的 colormap 的标准化。如果hue为类别变量则与此无关。 sizes：列表、典或者元组，可选 当使用sizes时，用于确定如何选择尺寸。此变量可以一直是尺寸值的列表或者size变量的字典映射。当size为数值型时，此变量也可以是指定最小和最大尺寸的元组，这样可以将其他值标准化到这个范围。 size_order：列表，可选 指定size变量层次的表现顺序，不指定则会通过数据确定。当size变量为数值型时与此无关。 size_norm：元组或者 Normalize 对象，可选 当size变量为数值型时，用于数据单元的 scaling plot 对象的标准化。 legend：“brief”, “full”, 或者 False, 可选 用于决定如何绘制坐标轴。如果参数值为“brief”, 数值型的hue以及size变量将会被用等间隔采样值表示。如果参数值为“full”, 每组都会在坐标轴中被记录。如果参数值为“false”, 不会添加坐标轴数据，也不会绘制坐标轴。 kind：string, 可选 绘制图的类型，与 seaborn 相关的图一致。可选项为(scatter及line). height：标量, 可选 每个 facet 的高度（英寸）。参见aspect。 aspect：标量, 可选 每个 facet 的长宽比，因此“长宽比*高度”可以得出每个 facet 的宽度（英寸）。 facet_kws：dict, 可选 以字典形式传给FacetGrid的其他关键字参数. kwargs：键值对 传给后续绘制函数的其他关键字参数。 返回值：g：FacetGrid 返回包含图像的FacetGrid对象，图像可以进一步调整。 示例 使用FacetGrid的坐标轴布局绘制简单的 facet。 >>> import seaborn as sns >>> sns.set(style=\"ticks\") >>> tips = sns.load_dataset(\"tips\") >>> g = sns.relplot(x=\"total_bill\", y=\"tip\", hue=\"day\", data=tips) 利用其他变量绘制 facet: >>> g = sns.relplot(x=\"total_bill\", y=\"tip\", ... hue=\"day\", col=\"time\", data=tips) 绘制两行两列的 facet: >>> g = sns.relplot(x=\"total_bill\", y=\"tip\", hue=\"day\", ... col=\"time\", row=\"sex\", data=tips) 将多行 facets 转换为多列: >>> g = sns.relplot(x=\"total_bill\", y=\"tip\", hue=\"time\", ... col=\"day\", col_wrap=2, data=tips) 利用指定的属性值对每个 facet 使用多种语义变量: >>> g = sns.relplot(x=\"total_bill\", y=\"tip\", hue=\"time\", size=\"size\", ... palette=[\"b\", \"r\"], sizes=(10, 100), ... col=\"time\", data=tips) 使用不同类型的图: >>> fmri = sns.load_dataset(\"fmri\") >>> g = sns.relplot(x=\"timepoint\", y=\"signal\", ... hue=\"event\", style=\"event\", col=\"region\", ... kind=\"line\", data=fmri) 改变每个 facet 的大小: >>> g = sns.relplot(x=\"timepoint\", y=\"signal\", ... hue=\"event\", style=\"event\", col=\"region\", ... height=5, aspect=.7, kind=\"line\", data=fmri) Update time： 2020-05-23 "},"Chapter7/散点图scatterplot.html":{"url":"Chapter7/散点图scatterplot.html","title":"散点图scatterplot","keywords":"","body":"seaborn.scatterplot seaborn.scatterplot(x=None, y=None, hue=None, style=None, size=None, data=None, palette=None, hue_order=None, hue_norm=None, sizes=None, size_order=None, size_norm=None, markers=True, style_order=None, x_bins=None, y_bins=None, units=None, estimator=None, ci=95, n_boot=1000, alpha='auto', x_jitter=None, y_jitter=None, legend='brief', ax=None, **kwargs) 绘制几个语义分组的散点图。 数据的不同子集的 x 和 y 之间的关系可以用 hue, size, style 这三个参数来控制绘图属性。 这些参数控制用于识别不同子集的视觉语义信息，三种语义类型全部使用的话可以独立显示三个维度， 但是这种风格的绘图很难解释或者说没大部分时候什么效果。使用过多的语义信息 （例如：对同一个变量同时使用 hue 和 style)对作图来说是很有帮助同时也更容易理解。 阅读下面的教程可以 get 更多信息哦。 参数: x, y: data 或是向量 data 里面的变量名字，可选择 输入数据的变量，必须是数字，可以直接传递数据或引用数据中的列 hue： data 或是向量 data 里面的变量名字，可选择 将产生不同大小的点的变量进行分组，可以是类别也可以是数字， 但是大小映射在后一种情况会有不同的表现 style： data 或是向量 data 里面的变量名字，可选择 将产生不同标记的点的变量进行分类，可以有一个数字类型，但是这个数字会被当作类别 data：DataFrame Tidy (“long-form”) dataframe 它的每一列是一个变量，每一行是一个观测值 plaette : 调色板的名字、列表或字典，可选 用于不同 level 的 hue 变量的颜色，应该是可以被 color_palette() 执行的 something， 或者是一个可以对 matplotlib colors 映射 hue 级别的字典。 hue_order：列表，可选 对 hue 变量的级别的表象有特定的顺序，否则的话，顺序由 data 决定。当 hue 是数字的时候与它不相关 hue_norm：元组或标准化的对象，可选 当 hue 变量是数字的时候，应用于 hue 变量的色彩映射的数据单元中的标准化。如果是类别则不相关 sizes：列表，字典或元组，可选 当使用 size 的时候，用来决定如何选择 sizes 的一个对象。可以一直是一个包含 size 数值的列表， 或者是一个映射变量 size 级别到 sizes 的字典。当 size 是数字时，sizes 可以是包含 size 最大值 和最小值的元组，其他的值都会标准化到这个元组指定的范围 size_order：元组，可选 size 变量级别表现的特定顺序，否则顺序由 data 决定，当 size 变量是数字时不相关 size_norm：元组或标准化的对象，可选 当变量 size 是数字时，用于缩放绘图对象的数据单元中的标准化 makers：布尔型，列表或字典，可选 决定如何绘制不同级别 style 的标志符号。设置为 True 会使用默认的标志符号，或者通过一系列标志 或者一个字典映射 style 变量的级别到 markers。设置为 False 会绘制无标志的线。 Markers 在 matplotlib 中指定 style_order：列表，可选 对于 style 变量级别表象的特定顺序，否则由 data 决定，当 style 是数字时不相关 {x,y}_bins: 元组，矩阵或函数 暂时没有什么功能 units：{long_form_var} 分组特定的样本单元。使用时，将为每个具有适当的语义的单元绘制一根单独的线， 但不会添加任何图例条目。 当不需要确切的身份时，可用于显示实验重复的分布。 目前没啥作用 estimator：pandas 方法的名称，或者可调用的方法或者是 None，可选 聚类同一个 x 上多个观察值 y，如果是 None，所有的观察值都会绘制，目前暂无功能 ci：整型或 'sd' or None,可选 与估算器聚合时绘制的置信区间的大小。 “sd”表示绘制数据的标准偏差。 设置为 None 将跳过自举。 目前无功能。 n_boot：整型，可选 自举法的数量，用于计算区间的置信度，暂无功能 alpha：浮点型 设置点的不透明度 {x,y}_jitter：布尔或者浮点型 暂无功能 legend：“brief”, “full”, or False, 可选 绘制图例的方式。如果为“brief\" 数字 hue 和 size 变量会代表一个样本，即便有不同的值 if \"full\", 每一个分组都有图例。if False 不绘制也不添加图例 ax：matplotlib 坐标轴，可选 绘制图像的坐标对象，否则使用当前坐标轴 kwargs：键值映射对 在绘制的时候其他的键会传递给 plt.scatter 返回值：ax：matplotlib 坐标轴 返回绘制所需的坐标 edgecolor 设置轮廓色： edgecolor=None 五轮廓色 请参阅官方文档 用线显示两个变量之间的关系以强调连续性。绘制带有一个分类变量的散点图，排列点以显示值的分布。 例子 绘制一个两个变量的简单散点图： import seaborn as sns; sns.set() import matplotlib.pyplot as plt tips = sns.load_dataset('tips') ax = sns.scatterplot(x='total_bill',y='tip',data=tips) 通过其他的变量分组并且用不同的颜色展示分组 ax = sns.scatterplot(x='total_bill',y='tip',hue='time',data=tips) 通过不同的颜色和标记显示分组变量： ax = sns.scatterplot(x='total_bill',y='tip', hue='time',style='time',data=tips) 不同的颜色和标志显示两个不同的分组变量： ax = sns.scatterplot(x='total_bill',y='tip', hue='day',style='time',data=tips) 用不同大小的点显示一个变量的数量： ax = sns.scatterplot(x='total_bill',y='tip', size='size',data=tips) 使用渐变的颜色显示变量的数量： ax = sns.scatterplot(x='total_bill',y='tip', hue='size', size='size',data=tips) 用一个不一样的渐变颜色映射： cmap = sns.cubehelix_palette(dark=.3,light=.8,as_cmap=True) ax = sns.scatterplot(x='total_bill',y='tip', hue='size', size='size',palette=cmap,data=tips) 改变点大小的最小值和最大值并在图例中显示所有的尺寸： cmap = sns.cubehelix_palette(dark=.3,light=.8,as_cmap=True) ax = sns.scatterplot(x='total_bill',y='tip', hue='size',size='size', sizes=(20,200),legend='full',palette=cmap,data=tips) 使用一个更小的颜色强度范围： cmap = sns.cubehelix_palette(dark=.3,light=.8,as_cmap=True) ax = sns.scatterplot(x='total_bill',y='tip',hue='size',size='size', sizes=(20,200),hue_norm=(0,7), legend='full',data=tips) 一个类别变量不同的大小，用不同的颜色： ax = sns.scatterplot(x='total_bill',y='tip',hue='day',size='smoker', palette='Set2',data=tips) 使用一些特定的标识： markers = {'Lunch':'s','Dinner':'X'} ax = sns.scatterplot(x='total_bill',y='tip',style='time', markers=markers,data=tips) 使用 matplotlib 的参数控制绘制属性： ax = sns.scatterplot(x='total_bill',y='tip', s=100,color='.2',marker='+',data=tips) 使用 data 向量代替 data frame 名字： iris = sns.load_dataset('iris') ax = sns.scatterplot(x=iris.sepal_length,y=iris.sepal_width, hue = iris.species,style=iris.species) 传递宽格式数据并根据其索引进行绘图: import numpy as np, pandas as pd; plt.close(\"all\") index = pd.date_range('1 1 2000',periods=100,freq='m',name='date') data = np.random.randn(100,4).cumsum(axis=0) wide_df = pd.DataFrame(data,index,['a','b','c','d']) print(wide_df.head()) ax = sns.scatterplot(data=wide_df) Update time： 2020-08-15 "},"Chapter7/折线图lineplot.html":{"url":"Chapter7/折线图lineplot.html","title":"折线图lineplot","keywords":"","body":"折线图lineplot seaborn.lineplot(x=None, y=None, hue=None, size=None, style=None, data=None, palette=None, hue_order=None, hue_norm=None, sizes=None, size_order=None, size_norm=None, dashes=True, markers=None, style_order=None, units=None, estimator='mean', ci=95, n_boot=1000, sort=True, err_style='band', err_kws=None, legend='brief', ax=None, **kwargs) 用不同语义分组绘制线型图 x和y之间的关系可以使用hue，size和style参数为数据的不同子集显示。这些参数控制用于识别不同子集的视觉语义。通过使用所有三种语义类型，可以独立地显示三个维度，但是这种画图样式可能难以解释并且通常是无效的。使用冗余语义（即同一变量的hue和style）有助于使图形更易于理解。 请查看指南获取更多信息。 默认情况下，图标在每个x值处汇总多个y值，并显示集中趋势的估计值和该估计值的置信区间。 参数：x,y： data或向量数据中变量的名称，可选择。 输入数据变量；必须是数字。可以直接传递数据或引用data中的列。 hue: data或向量数据中的变量名，可选。 分组变量，将生成具有不同颜色的线条的变量。可以是分类或数字，但颜色映射在后一种情况下的行为会有所不同。 size: data或向量数据中的变量名，可选。 分组变量，将生成具有不同粗细的线条的变量。可以是分类或数字，但大小映射在后一种情况下的行为会有所不同。 style: data或向量数据中的变量名，可选。 分组变量，将生成具有不同样式和/或标记的线条的变量。可以是一种数字形式，但是始终会被视为分类。 data: 数据框架。 整洁（“长形式”）数据框，其中每列是变量，每行是观察量。 palette： 调色板名称，列表或字典，可选。 用于hue变量的不同级别的颜色。应该是color_palette()可以解释的东西，或者是将色调级别映射到 matplotlib 颜色的字典。 hue_order：列表，可选。 指定hue变量级别的出现顺序，否则它们是根据数据确定的。当hue变量是数字时不相关。 hue_norm： 原则或者时归一化对象，可选。 当数值为数字时，应用于hue变量的颜色图数据单元的归一化。 如果是分类的，则不相关。 sizes：列表，字典，或者元组。可选。 确定在使用size时如何选择大小的对象。它始终可以是大小值列表或size变量与大小的字典映射级别。当size是数字时，它也可以是一个元组，指定要使用的最小和最大大小，以便在此范围内对其他值进行规范化。 size_norm：原则或者时归一化对象，可选。 当size变量是数字时，用于缩放绘图对象的数据单元中的归一化。 dashes： 布尔值，列表或字典，可选。 确定如何为style变量的不同级别绘制线条的对象。设置为True将使用默认的短划线代码，或者您可以将短划线代码列表或style变量的字典映射级别传递给短划线代码。设置为False将对所有子集使用实线。线段在 matplotlib 中指定： (segment, gap)长度的元组，或用于绘制实线的空字符串。 markers： 布尔值，列表或字典，可选。 确定如何为style变量的不同级别绘制标记的对象。 设置为“True”将使用默认标记，或者您可以传递标记列表或将style变量的字典映射到标记。 设置为“False”将绘制无标记线。 标记在 matplotlib 中指定。 style_order：列表，可选。 指定style变量级别的出现顺序，否则它们是从数据中确定的。style变量时数字不相关的。 units： {long_form_var} 对变量识别抽样单位进行分组。使用时，将为每个单元绘制一个单独的行，并使用适当的语义。但不会添加任何图里条目。当不需要确切的身份时，可用于显示实验重复的分布。 estimator：pandas 方法的名称或可调用或无，可选。 在相同的x级别上聚合y变量的多个观察值的方法。如果None，将绘制所有观察结果。 ci：整数或sd或 None。可选。 与estimator聚合时绘制的置信区间大小。sd表示绘制数据的标准偏差。设置为None将跳过 bootstrap。 n_boot：整数，可选。 用于计算置信区间的 bootstrap 数。 sort：布尔值，可选。 如果为真，则数据将按 x 与 y 变量排序，否则行将按照它们在数据集中出现的顺序连接点。 err_style: band或bars，可选。 是否用半透明误差带或离散误差棒绘制置信区间。 err_band：关键字参数字典。 用于控制误差线美观的附加参数。 kwargs传递给ax.fill_between或ax.errorbar，具体取决于err_style。 legend： brief,full,或False。可选。 如何绘制图例。如果brief，则数字hue和size变量将用均匀间隔值的样本表示。如果full，则每个组都会在图例中输入一个条目。如果为False，则不添加图例数据且不绘制图例。 ax：matplotlib 轴。可选。 将绘图绘制到的 Axes 对象，否则使用当前轴。 kwargs：关键，价值映射。 其他关键字参数在绘制时传递给plt.plot。 返回值：ax：matplotlib 轴 返回 Axes 对象，并在其上绘制绘图。 也可以看看 显示两个变量之间的关系，而不强调x变量的连续性。当两个变量时分类时，显示两个变量之间的关系。 例子 绘制单线图，其中错误带显示执行区间： >>> import seaborn as sns; sns.set() >>> import matplotlib.pyplot as plt >>> fmri = sns.load_dataset(\"fmri\") >>> ax = sns.lineplot(x=\"timepoint\", y=\"signal\", data=fmri) 按另一个变量分组并显示具有不同颜色的组： >>> ax = sns.lineplot(x=\"timepoint\", y=\"signal\", hue=\"event\", ... data=fmri) 使用颜色和线条划线显示分组变量： >>> ax = sns.lineplot(x=\"timepoint\", y=\"signal\", ... hue=\"event\", style=\"event\", data=fmri) 使用颜色和线条划线来表示两个不同的分组变量： >>> ax = sns.lineplot(x=\"timepoint\", y=\"signal\", ... hue=\"region\", style=\"event\", data=fmri) 使用标记而不是破折号来标识组： >>> ax = sns.lineplot(x=\"timepoint\", y=\"signal\", ... hue=\"event\", style=\"event\", ... markers=True, dashes=False, data=fmri) 显示错误条而不是错误带并绘制标准错误： >>> ax = sns.lineplot(x=\"timepoint\", y=\"signal\", hue=\"event\", ... err_style=\"bars\", ci=68, data=fmri) 显示实验性重复而不是聚合： >>> ax = sns.lineplot(x=\"timepoint\", y=\"signal\", hue=\"event\", ... units=\"subject\", estimator=None, lw=1, ... data=fmri.query(\"region == 'frontal'\")) 使用定量颜色映射： >>> dots = sns.load_dataset(\"dots\").query(\"align == 'dots'\") >>> ax = sns.lineplot(x=\"time\", y=\"firing_rate\", ... hue=\"coherence\", style=\"choice\", ... data=dots) 对 colormap 使用不同的归一化： >>> from matplotlib.colors import LogNorm >>> ax = sns.lineplot(x=\"time\", y=\"firing_rate\", ... hue=\"coherence\", style=\"choice\", ... hue_norm=LogNorm(), data=dots) 使用不同的调色板： >>> ax = sns.lineplot(x=\"time\", y=\"firing_rate\", ... hue=\"coherence\", style=\"choice\", ... palette=\"ch:2.5,.25\", data=dots) 使用特定颜色值，将 hue 变量视为分类： >>> palette = sns.color_palette(\"mako_r\", 6) >>> ax = sns.lineplot(x=\"time\", y=\"firing_rate\", ... hue=\"coherence\", style=\"choice\", ... palette=palette, data=dots) 使用定量变量更改线条的宽度： >>> ax = sns.lineplot(x=\"time\", y=\"firing_rate\", ... size=\"coherence\", hue=\"choice\", ... legend=\"full\", data=dots) 更改用于规范化 size 变量的线宽范围： >>> ax = sns.lineplot(x=\"time\", y=\"firing_rate\", ... size=\"coherence\", hue=\"choice\", ... sizes=(.25, 2.5), data=dots) DataFrame 绘制： >>> import numpy as np, pandas as pd; plt.close(\"all\") >>> index = pd.date_range(\"1 1 2000\", periods=100, ... freq=\"m\", name=\"date\") >>> data = np.random.randn(100, 4).cumsum(axis=0) >>> wide_df = pd.DataFrame(data, index, [\"a\", \"b\", \"c\", \"d\"]) >>> ax = sns.lineplot(data=wide_df) 系列列表中绘制： >>> list_data = [wide_df.loc[:\"2005\", \"a\"], wide_df.loc[\"2003\":, \"b\"]] >>> ax = sns.lineplot(data=list_data) 绘制单个系列，将 kwargs 传递给plt.plot： >>> ax = sns.lineplot(data=wide_df[\"a\"], color=\"coral\", label=\"line\") 在数据集中出现的点处绘制线条： >>> x, y = np.random.randn(2, 5000).cumsum(axis=1) >>> ax = sns.lineplot(x=x, y=y, sort=False, lw=1) Update time： 2020-05-23 "},"Chapter7/分类图catplot.html":{"url":"Chapter7/分类图catplot.html","title":"分类图catplot","keywords":"","body":"分类图catplot seaborn.catplot(x=None, y=None, hue=None, data=None, row=None, col=None, col_wrap=None, estimator=, ci=95, n_boot=1000, units=None, order=None, hue_order=None, row_order=None, col_order=None, kind='strip', height=5, aspect=1, orient=None, color=None, palette=None, legend=True, legend_out=True, sharex=True, sharey=True, margin_titles=False, facet_kws=None, **kwargs) seaborn.catplot 是一个将分类图绘制到FacetGrid上图级别接口。 这个函数可以访问多个轴级功能，这些轴级功能通过不同的可视化图表展示数字和一个或多个分类变量的关系。kind 参数可以选择的轴级基础函数有： 分类散点图: stripplot() (with kind=\"strip\"; the default) swarmplot() (with kind=\"swarm\") 分类分布图: boxplot() (with kind=\"box\") violinplot() (with kind=\"violin\") boxenplot() (with kind=\"boxen\") 分类估计图: pointplot() (with kind=\"point\") barplot() (with kind=\"bar\") countplot() (with kind=\"count\") 与直接使用轴级函数不同, 数据必须在长格式DataFrame中传递，并通过将字符串传递给 x, y, hue, 等指定的变量. 绘图后，返回带有绘图的 FacetGrid，可以直接用于调整绘图细节或添加其他图层。 参数：x, y, hue： data names 中的变量名称 用于绘制长格式数据的输入。查看解释示例 data：DataFrame 用于绘图的长形（整洁）数据集。每列应对应一个变量，每行应对应一个观察。 row, col：data 中的变量名称, 可选 分类变量将决定网格的分面。 col_wrap：int, 可选 以此宽度“包裹”列变量，以便列面跨越多行。 与行方面不兼容。 estimator：可调用的映射向量 -> 标量，可选 在每个分类箱内估计的统计函数。 ci：float或“sd”或None，可选 在估计值附近绘制置信区间的大小。如果是“sd”，则跳过自举(bootstrapping)并绘制观察的标准偏差。None,如果为None，则不执行自举，并且不会绘制错误条。 n_boot：int，可选 计算置信区间时使用的引导程序迭代次数。 units：数据或矢量数据中变量的名称,可选 采样单元的标识符，用于执行多级引导程序并考虑重复测量设计。 order, hue_order：字符串列表，可选 命令绘制分类级别，否则从数据对象推断级别。 row_order, col_order：字符串列表，可选 命令组织网格的行和/或列，否则从数据对象推断命令。 kind：字符串，可选 要绘制的绘图类型（对应于分类绘图功能的名称。选项包括：“点”，“条形”，“条形”，“群”，“框”，“小提琴”或“盒子”。 height：标量，可选 每个刻面的高度（以英寸为单位）。另见： aspect。 aspect：标量，可选 每个面的纵横比，因此aspect * height给出每个面的宽度，单位为英寸。 orient：“v” | “h”, 可选 图的方向（垂直或水平）。这通常是从输入变量的dtype推断出来的，但可用于指定“分类”变量何时是数字或何时绘制宽格式数据。 color：matplotlib颜色，可选 所有元素的颜色，或渐变调色板的种子。 palette：调色板名称，列表或字典，可选 用于色调变量的不同级别的颜色。应该是 color_palette(), 可以解释的东西，或者是将色调级别映射到matplotlib颜色的字典。 legend：bool, 可选 如果为 True 并且存在hue变量，则在图上绘制图例。t. legend_out：bool, 可选 如果为True，则图形尺寸将被扩展，图例将绘制在中间右侧的图形之外。 share{x,y}：bool, ‘col’, 或 ‘row’ 可选 如果为true，则facet将跨行跨越列和/或x轴共享y轴。 margin_titles：bool, 可选 如果为True，则行变量的标题将绘制在最后一列的右侧。此选项是实验性的，可能无法在所有情况下使用。 facet_kws：dict, 可选 传递给FacetGrid的其他关键字参数的字典。 kwargs：key, value 配对 其他关键字参数将传递给基础绘图函数。 返回值：g：FacetGrid 返回FacetGrid对象及其上的绘图以进一步调整。 例子 绘制单个构面以使用FacetGrid图例放置： sns.set(style=\"ticks\") exercise = pd.read_csv(\"exercise.csv\") g = sns.catplot(x=\"time\", y=\"pulse\", hue=\"kind\", data=exercise) 使用不同的绘图类型可视化相同的数据： g = sns.catplot(x=\"time\", y=\"pulse\", hue=\"kind\", data=exercise, kind=\"violin\") 沿列的方向显示第三个分类变量： g = sns.catplot(x=\"time\", y=\"pulse\", hue=\"kind\", col=\"diet\", data=exercise) 使用不同的高度和宽高比： g = sns.catplot(x=\"time\", y=\"pulse\", hue=\"kind\", col=\"diet\", data=exercise, height=5, aspect=.8) 创建许多列构面并将它们包装到网格的行中： g = sns.catplot(\"alive\", col=\"deck\", col_wrap=4, data=titanic[titanic.deck.notnull()], kind=\"count\", height=2.5, aspect=.8) 水平绘图并将其他关键字参数传递给绘图函数： >>> g = sns.catplot(x=\"age\", y=\"embark_town\", ... hue=\"sex\", row=\"class\", ... data=titanic[titanic.embark_town.notnull()], ... orient=\"h\", height=2, aspect=3, palette=\"Set3\", ... kind=\"violin\", dodge=True, cut=0, bw=.2) 使用返回的FacetGrid 上的方法来调整演示文稿： g = sns.catplot(x=\"who\", y=\"survived\", col=\"class\", data=titanic, saturation=.5, kind=\"bar\", ci=None, aspect=.6) g.set_axis_labels(\"\", \"Survival Rate\") g.set_xticklabels([\"Men\", \"Women\", \"Children\"]) g.set_titles(\"{col_name} {col_var}\") g.set(ylim=(0, 1)) g.despine(left=True) Update time： 2020-05-23 "},"Chapter7/seaborn.stripplot.html":{"url":"Chapter7/seaborn.stripplot.html","title":"seaborn.stripplot","keywords":"","body":"seaborn.stripplot seaborn.stripplot(x=None, y=None, hue=None, data=None, order=None, hue_order=None, jitter=True, dodge=False, orient=None, color=None, palette=None, size=5, edgecolor='gray', linewidth=0, ax=None, **kwargs) 绘制一个散点图，其中一个变量是分类。 条形图可以单独绘制，但如果您想要显示所有观察结果以及底层分布的某些表示，它也是一个盒子或小提琴图的良好补充。 输入数据可以以多种格式传递，包括： 表示为列表，numpy 数组或 pandas Series 对象的数据向量直接传递给x，y和hue参数 在这种情况下，x，y和hue变量将决定数据的绘制方式。 “wide-form” DataFrame, 用于绘制每个数字列。 一个数组或向量列表。 在大多数情况下，可以使用 numpy 或 Python 对象，但最好使用 pandas 对象，因为关联的名称将用于注释轴。另外，您可以使用分组变量的分类类型来控制绘图元素的顺序。 此函数始终将其中一个变量视为分类，并在相关轴上的序数位置（0,1，... n）处绘制数据，即使数据具有数字或日期类型也是如此。 有关更多信息，请参阅教程。 参数：x, y, hue： 数据或矢量数据中的变量名称，可选 用于绘制长格式数据的输入。查看解释示例。 data：DataFrame, 数组, 数组列表, 可选 用于绘图的数据集。如果 x 和 y 不存在，则将其解释为宽格式。否则预计它将是长格式的。 order, hue_order：字符串列表，可选 命令绘制分类级别，否则从数据对象推断级别。 jitter：float, True/1 是特殊的，可选 要应用的抖动量（仅沿分类轴）。 当您有许多点并且它们重叠时，这可能很有用，因此更容易看到分布。您可以指定抖动量（均匀随机变量支持的宽度的一半），或者仅使用True作为良好的默认值 dodge：bool, 可选 使用 hue 嵌套时，将其设置为 True 将沿着分类轴分离不同色调级别的条带。否则，每个级别的点将相互叠加。 orient：“v” | “h”, 可选 图的方向（垂直或水平）。这通常是从输入变量的 dtype 推断出来的，但可用于指定“分类”变量何时是数字或何时绘制宽格式数据。 color：matplotlib 颜色，可选 所有元素的颜色，或渐变调色板的种子。 palette：调色板名称，列表或字典，可选 用于色调变量的不同级别的颜色。应该是 color_palette(), 可以解释的东西，或者是将色调级别映射到 matplotlib 颜色的字典。 size：float, 可选 标记的直径，以磅为单位。（虽然 plt.scatter 用于绘制点，但这里的 size 参数采用“普通”标记大小而不是大小^ 2，如 plt.scatter 。 edgecolor：matplotlib 颜色，“灰色”是特殊的，可选的 每个点周围线条的颜色。如果传递\"灰色\"，则亮度由用于点体的调色板决定。 linewidth：float, 可选 构图元素的灰线宽度。 ax：matplotlib 轴，可选 返回 Axes 对象，并在其上绘制绘图。 返回值：ax：matplotlib 轴 返回 Axes 对象，并在其上绘制绘图。 也可参看 分类散点图，其中点不重叠。可以与其他图一起使用来显示每个观察结果。带有类似 API 的传统盒须图。箱形图和核密度估计的组合。 例子 绘制单个水平条形图： >>> import seaborn as sns >>> sns.set(style=\"whitegrid\") >>> tips = sns.load_dataset(\"tips\") >>> ax = sns.stripplot(x=tips[\"total_bill\"]) 通过分类变量对条形图进行分组： >>> ax = sns.stripplot(x=\"day\", y=\"total_bill\", data=tips) 添加抖动以显示值的分布： >>> ax = sns.stripplot(x=\"day\", y=\"total_bill\", data=tips, jitter=True) 使用较少量的抖动： >>> ax = sns.stripplot(x=\"day\", y=\"total_bill\", data=tips, jitter=0.05) 画水平条形图： >>> ax = sns.stripplot(x=\"total_bill\", y=\"day\", data=tips, ... jitter=True) 围绕要点绘制轮廓： >>> ax = sns.stripplot(x=\"total_bill\", y=\"day\", data=tips, ... jitter=True, linewidth=1) 将条带嵌套在第二个分类变量中： >>> ax = sns.stripplot(x=\"sex\", y=\"total_bill\", hue=\"day\", ... data=tips, jitter=True) 在主要分类轴上的不同位置绘制 hue 变量的每个级别： >>> ax = sns.stripplot(x=\"day\", y=\"total_bill\", hue=\"smoker\", ... data=tips, jitter=True, ... palette=\"Set2\", dodge=True) 通过传递显式顺序来控制条带顺序： >>> ax = sns.stripplot(x=\"time\", y=\"tip\", data=tips, ... order=[\"Dinner\", \"Lunch\"]) 绘制具有大点和不同美感的条带： >>> ax = sns.stripplot(\"day\", \"total_bill\", \"smoker\", data=tips, ... palette=\"Set2\", size=20, marker=\"D\", ... edgecolor=\"gray\", alpha=.25) 在箱形图上绘制观察条带： >>> ax = sns.boxplot(x=\"tip\", y=\"day\", data=tips, whis=np.inf) >>> ax = sns.stripplot(x=\"tip\", y=\"day\", data=tips, ... jitter=True, color=\".3\") 在小提琴的顶部绘制观察条带： >>> ax = sns.violinplot(x=\"day\", y=\"total_bill\", data=tips, ... inner=None, color=\".8\") >>> ax = sns.stripplot(x=\"day\", y=\"total_bill\", data=tips, jitter=True) 使用 catplot() 组合stripplot()和FacetGrid。这允许在其他分类变量中进行分组。使用catplot()比直接使用FacetGrid更安全，因为它确保了跨方面的变量顺序的同步 >>> g = sns.catplot(x=\"sex\", y=\"total_bill\", ... hue=\"smoker\", col=\"time\", ... data=tips, kind=\"strip\", ... jitter=True, ... height=4, aspect=.7); Update time： 2020-05-23 "},"Chapter7/seaborn.swarmplot.html":{"url":"Chapter7/seaborn.swarmplot.html","title":"seaborn.swarmplot","keywords":"","body":"seaborn.swarmplot seaborn.swarmplot(x=None, y=None, hue=None, data=None, order=None, hue_order=None, dodge=False, orient=None, color=None, palette=None, size=5, edgecolor='gray', linewidth=0, ax=None, **kwargs) 绘制具有非重叠点的分类散点图。 此功能类似于 stripplot(),，但调整点（仅沿分类轴），以便它们不重叠。 这样可以更好地表示值的分布，但不能很好地扩展到大量观察值。这种情节有时被称为“诅咒” 一个群体图可以单独绘制，但如果你想要显示所有观察结果以及底层分布的一些表示，它也是一个盒子或小提琴图的良好补充。 正确排列点需要在数据和点坐标之间进行精确转换。这意味着必须在绘制绘图之前设置非默认轴限制。 输入数据可以以多种格式传递，包括： 表示为列表，numpy arrays 或 pandas Series objects 直接传递给x，y和/或hue参数。 “长格式” DataFrame, x，y和hue变量将决定数据的绘制方式 “宽格式”DataFrame，用于绘制每个数字列。 一个数组或向量列表。 在大多数情况下，可以使用 numpy 或 Python 对象，但最好使用 pandas 对象，因为关联的名称将用于注释轴。此外，您可以使用分类类型来分组变量来控制绘图元素的顺序。 此函数始终将其中一个变量视为分类，并在相关轴上的序数位置（0,1，... n）处绘制数据，即使数据具有数字或日期类型也是如此 有关更多信息，请参阅教程。 参数：x, y, hue：数据或矢量数据中的变量名称，可选 用于绘制长格式数据的输入。查看解释示例。 data：DataFrame, array, or 或数组列表, 可选 用于绘图的数据集。 如果 x 和 y 是不存在的, 会被解释成 wide-form. 否则会被解释成 long-form. order, hue_order：字符串列表，可选 命令绘制分类级别，否则从数据对象推断级别。 dodge：布尔，可选 使用hue嵌套时，将其设置为True将沿着分类轴分离不同色调级别的条带。 否则，每个级别的点将绘制在一个群中。 orient：“v” | “h”, 可选 图的方向（垂直或水平）。这通常是从输入变量的 dtype 推断出来的，但可用于指定“分类”变量何时是数字或何时绘制宽格式数据。 color：matplotlib color, 可选 所有元素的颜色，或渐变调色板的种子。 palette：调色板名称, list, or dict, 可选 用于hue变量的不同级别的颜色。应该是color_palette(),可以解释的东西，或者是将色调级别映射到 matplotlib 颜色的字典。 size：float, 可选 标记的直径，以点为单位。 (尽管plt.scatter用于绘制点，但此处的size参数采用“普通”标记大小而不是大小^ 2，如plt.scatter。 edgecolor：matplotlib color, “灰色”是特殊的，可选 每个点周围线条的颜色。如果传递\"gray\"，则亮度由用于点体的调色板决定。 linewidth：float, 可选 构图元素的灰线宽度。 ax：matplotlib Axes, 可选 Axes 对象将绘图绘制到，否则使用当前轴。 返回值：ax：matplotlib Axes 返回 Axes 对象，并在其上绘制绘图。 参看 带有类似 API 的传统盒须图。框图和核密度估计的组合。散点图，其中一个变量是分类的。可以与其他图一起使用以显示每个观察结果。使用类组合分类图：FacetGrid。 例 绘制单个水平群图： >>> import seaborn as sns >>> sns.set(style=\"whitegrid\") >>> tips = sns.load_dataset(\"tips\") >>> ax = sns.swarmplot(x=tips[\"total_bill\"]) 通过分类变量对群组进行分组： >>> ax = sns.swarmplot(x=\"day\", y=\"total_bill\", data=tips) 绘制水平群： >>> ax = sns.swarmplot(x=\"total_bill\", y=\"day\", data=tips) 使用第二个分类变量为点着色： >>> ax = sns.swarmplot(x=\"day\", y=\"total_bill\", hue=\"sex\", data=tips) 沿着分类轴拆分 hue 变量的每个级别： >>> ax = sns.swarmplot(x=\"day\", y=\"total_bill\", hue=\"smoker\", ... data=tips, palette=\"Set2\", dodge=True) 通过传递显式顺序来控制 swarm 顺序： >>> ax = sns.swarmplot(x=\"time\", y=\"tip\", data=tips, ... order=[\"Dinner\", \"Lunch\"]) 绘制使用更大的点 >>> ax = sns.swarmplot(x=\"time\", y=\"tip\", data=tips, size=6) 在箱形图上绘制大量观察结果： >>> ax = sns.boxplot(x=\"tip\", y=\"day\", data=tips, whis=np.inf) >>> ax = sns.swarmplot(x=\"tip\", y=\"day\", data=tips, color=\".2\") 在小提琴图的顶部画出大量的观察结果： >>> ax = sns.violinplot(x=\"day\", y=\"total_bill\", data=tips, inner=None) >>> ax = sns.swarmplot(x=\"day\", y=\"total_bill\", data=tips, ... color=\"white\", edgecolor=\"gray\") 使用catplot() 去组合 swarmplot() 和 FacetGrid. 这允许在其他分类变量中进行分组。 使用 catplot() 比直接使用 FacetGrid 更安全,因为它确保了跨 facet 的变量顺序的同步 >>> g = sns.catplot(x=\"sex\", y=\"total_bill\", ... hue=\"smoker\", col=\"time\", ... data=tips, kind=\"swarm\", ... height=4, aspect=.7); Update time： 2020-05-23 "},"Chapter7/箱线图.html":{"url":"Chapter7/箱线图.html","title":"箱线图","keywords":"","body":"箱线图 seaborn.boxplot(x=None, y=None, hue=None, data=None, order=None, hue_order=None, orient=None, color=None, palette=None, saturation=0.75, width=0.8, dodge=True, fliersize=5, linewidth=None, whis=1.5, notch=False, ax=None, **kwargs ) seaborn.boxplot 接口的作用是绘制箱形图以展现与类别相关的数据分布状况。 箱形图（或盒须图）以一种利于变量之间比较或不同分类变量层次之间比较的方式来展示定量数据的分布。图中矩形框显示数据集的上下四分位数，而矩形框中延伸出的线段（触须）则用于显示其余数据的分布位置，剩下超过上下四分位间距的数据点则被视为“异常值”。 输入数据可以通过多种格式传入，包括： 格式为列表，numpy数组或pandas Series对象的数据向量可以直接传递给x，y和hue参数。 对于长格式的DataFrame，x，y，和hue参数会决定如何绘制数据。 对于宽格式的DataFrame，每一列数值列都会被绘制。 一个数组或向量的列表。 参数：x, y, hue：数据或向量数据中的变量名称，可选 用于绘制长格式数据的输入。查看样例以进一步理解。 data：DataFrame，数组，数组列表，可选 用于绘图的数据集。如果x和y都缺失，那么数据将被视为宽格式。否则数据被视为长格式。 order, hue_order：字符串列表，可选 控制分类变量（对应的条形图）的绘制顺序，若缺失则从数据中推断分类变量的顺序。 orient：“v” | “h”，可选 控制绘图的方向（垂直或水平）。这通常是从输入变量的dtype推断出来的，但是当“分类”变量为数值型或绘制宽格式数据时可用于指定绘图的方向。 color：matplotlib颜色，可选 所有元素的颜色，或渐变调色板的种子颜色。 palette：调色板名称，列表或字典，可选 用于hue变量的不同级别的颜色。可以从 color_palette() 得到一些解释，或者将色调级别映射到matplotlib颜色的字典。 saturation：float，可选 控制用于绘制颜色的原始饱和度的比例。通常大幅填充在轻微不饱和的颜色下看起来更好，如果您希望绘图颜色与输入颜色规格完美匹配可将其设置为1。 width：float，可选 不使用色调嵌套时完整元素的宽度，或主要分组变量一个级别的所有元素的宽度。 dodge：bool，可选 使用色调嵌套时，元素是否应沿分类轴移动。 fliersize：float，可选 用于表示异常值观察的标记的大小。 linewidth：float，可选 构图元素的灰线宽度。 whis：float，可选 控制在超过高低四分位数时IQR的比例，因此需要延长绘制的触须线段。超出此范围的点将被识别为异常值。 notch：boolean，可选 是否使矩形框“凹陷”以指示中位数的置信区间。还有其他几个参数可以控制凹槽的绘制方式；参见 plt.boxplot 以查看关于此问题的更多帮助信息。 ax：matplotlib轴，可选 绘图时使用的Axes轴对象，否则使用当前Axes轴对象。 kwargs：键，值映射 其他在绘图时传给 plt.boxplot 的参数。 返回值：ax：matplotlib轴 返回Axes对轴象，并在其上绘制绘图。 示例 import pandas as pd import seaborn as sns sns.set(style=\"whitegrid\") tips = pd.read_csv(\"tips.csv\") ax = sns.boxplot(x=tips[\"total_bill\"]) 根据分类变量分组绘制一个纵向的箱型图： ax = sns.boxplot(x=\"day\", y=\"total_bill\", data=tips) 根据2个分类变量嵌套分组绘制一个箱型图： ax = sns.boxplot(x=\"day\", y=\"total_bill\", hue=\"smoker\", data=tips, palette=\"Set3\") 当一些数据为空时根据嵌套分组绘制一个箱型图： ax = sns.boxplot(x=\"day\", y=\"total_bill\", hue=\"time\", data=tips, linewidth=2.5) 通过显式传入参数指定顺序控制箱型图的显示顺序： ax = sns.boxplot(x=\"time\", y=\"tip\", data=tips, order=[\"Dinner\", \"Lunch\"]) 针对DataFrame里每一个数值型变量绘制箱型图： iris = pd.read_csv(\"iris.csv\") ax = sns.boxplot(data=iris, orient=\"h\", palette=\"Set2\") 使用 hue 参数无需改变箱型图的位置或宽度： tips[\"weekend\"] = tips[\"day\"].isin([\"Sat\", \"Sun\"]) ax = sns.boxplot(x=\"day\", y=\"total_bill\", hue=\"weekend\", data=tips, dodge=False) 使用 swarmplot() 展示箱型图顶部的数据点： ax = sns.boxplot(x=\"day\", y=\"total_bill\", data=tips) ax = sns.swarmplot(x=\"day\", y=\"total_bill\", data=tips, color=\".25\") 把 catplot() 与 pointplot() 以及 FacetGrid 结合起来使用。这允许您通过额外的分类变量进行分组。使用 catplot() 比直接使用 FacetGrid 更为安全，因为它保证了不同切面上变量同步的顺序： g = sns.catplot(x=\"sex\", y=\"total_bill\", hue=\"smoker\", col=\"time\", data=tips, kind=\"box\", height=4, aspect=.7) Update time： 2020-05-23 "},"Chapter7/seaborn.violinplot.html":{"url":"Chapter7/seaborn.violinplot.html","title":"seaborn.violinplot","keywords":"","body":"seaborn.violinplot seaborn.violinplot(x=None, y=None, hue=None, data=None, order=None, hue_order=None, bw='scott', cut=2, scale='area', scale_hue=True, gridsize=100, width=0.8, inner='box', split=False, dodge=True, orient=None, linewidth=None, color=None, palette=None, saturation=0.75, ax=None, **kwargs) 结合箱型图与核密度估计绘图。 小提琴图的功能与箱型图类似。 它显示了一个（或多个）分类变量多个属性上的定量数据的分布，从而可以比较这些分布。与箱形图不同，其中所有绘图单元都与实际数据点对应，小提琴图描述了基础数据分布的核密度估计。 小提琴图可以是一种单次显示多个数据分布的有效且有吸引力的方式，但请记住，估计过程受样本大小的影响，相对较小样本的小提琴可能看起来非常平滑，这种平滑具有误导性。 输入数据可以通过多种格式传入，包括： 格式为列表，numpy 数组或 pandas Series 对象的数据向量可以直接传递给x，y和hue参数。 对于长格式的 DataFrame，x，y，和hue参数会决定如何绘制数据。 对于宽格式的 DataFrame，每一列数值列都会被绘制。 一个数组或向量的列表。 在大多数情况下，可以使用 numpy 或 Python 对象，但更推荐使用 pandas 对象，因为与数据关联的列名/行名可以用于标注横轴/纵轴的名称。此外，您可以使用分类类型对变量进行分组以控制绘图元素的顺序。 此函数始终将其中一个变量视为分类，并在相关轴上的序数位置(0,1，... n)处绘制数据，即使数据属于数值类型或日期类型也是如此。 更多信息请参阅 tutorial。 参数：x, y, hue：数据或向量数据中的变量名称，可选 用于绘制长格式数据的输入。查看样例以进一步理解。 data：DataFrame，数组，数组列表，可选 用于绘图的数据集。如果x和y都缺失，那么数据将被视为宽格式。否则数据被视为长格式。 order, hue_order：字符串列表，可选 控制分类变量（对应的条形图）的绘制顺序，若缺失则从数据中推断分类变量的顺序。 bw：{‘scott’, ‘silverman’, float}，可选 内置变量值或浮点数的比例因子都用来计算核密度的带宽。实际的核大小由比例因子乘以每个分箱内数据的标准差确定。 cut：float，可选 以带宽大小为单位的距离，以控制小提琴图外壳延伸超过内部极端数据点的密度。设置为 0 以将小提琴图范围限制在观察数据的范围内。（例如，在 ggplot 中具有与 trim=True 相同的效果） scale：{“area”, “count”, “width”}，可选 该方法用于缩放每张小提琴图的宽度。若为 area ，每张小提琴图具有相同的面积。若为 count ，小提琴的宽度会根据分箱中观察点的数量进行缩放。若为 width ，每张小提琴图具有相同的宽度。 scale_hue：bool，可选 当使用色调参数 hue 变量绘制嵌套小提琴图时，该参数决定缩放比例是在主要分组变量（scale_hue=True）的每个级别内还是在图上的所有小提琴图（scale_hue=False）内计算出来的。 gridsize：int，可选 用于计算核密度估计的离散网格中的数据点数目。 width：float，可选 不使用色调嵌套时的完整元素的宽度，或主要分组变量的一个级别的所有元素的宽度。 inner：{“box”, “quartile”, “point”, “stick”, None}，可选 控制小提琴图内部数据点的表示。若为box，则绘制一个微型箱型图。若为quartiles，则显示四分位数线。若为point或stick，则显示具体数据点或数据线。使用None则绘制不加修饰的小提琴图。 split：bool，可选 当使用带有两种颜色的变量时，将split设置为 True 则会为每种颜色绘制对应半边小提琴。从而可以更容易直接的比较分布。 dodge：bool，可选 使用色调嵌套时，元素是否应沿分类轴移动。 orient：“v” | “h”，可选 控制绘图的方向（垂直或水平）。这通常是从输入变量的 dtype 推断出来的，但是当“分类”变量为数值型或绘制宽格式数据时可用于指定绘图的方向。 linewidth：float，可选 构图元素的灰线宽度。 color：matplotlib 颜色，可选 所有元素的颜色，或渐变调色板的种子颜色。 palette：调色板名称，列表或字典，可选 用于hue变量的不同级别的颜色。可以从 color_palette() 得到一些解释，或者将色调级别映射到 matplotlib 颜色的字典。 saturation：float，可选 控制用于绘制颜色的原始饱和度的比例。通常大幅填充在轻微不饱和的颜色下看起来更好，如果您希望绘图颜色与输入颜色规格完美匹配可将其设置为1。 ax：matplotlib 轴，可选 绘图时使用的 Axes 轴对象，否则使用当前 Axes 轴对象。 返回值：ax：matplotlib 轴 返回 Axes 对轴象，并在其上绘制绘图。 亦可参见 一个传统的箱型图具有类似的 API。当一个变量是分类变量的散点图。可以与其他图表结合使用以展示各自的观测结果。分类散点图的特点是其中数据点互不重叠。可以与其他图表结合使用以展示各自的观测结果。 示例 绘制一个单独的横向小提琴图： >>> import seaborn as sns >>> sns.set(style=\"whitegrid\") >>> tips = sns.load_dataset(\"tips\") >>> ax = sns.violinplot(x=tips[\"total_bill\"]) 根据分类变量分组绘制一个纵向的小提琴图： >>> ax = sns.violinplot(x=\"day\", y=\"total_bill\", data=tips) 根据 2 个分类变量嵌套分组绘制一个小提琴图： >>> ax = sns.violinplot(x=\"day\", y=\"total_bill\", hue=\"smoker\", ... data=tips, palette=\"muted\") 绘制分割的小提琴图以比较不同的色调变量： >>> ax = sns.violinplot(x=\"day\", y=\"total_bill\", hue=\"smoker\", ... data=tips, palette=\"muted\", split=True) 通过显式传入参数指定顺序控制小提琴图的显示顺序： >>> ax = sns.violinplot(x=\"time\", y=\"tip\", data=tips, ... order=[\"Dinner\", \"Lunch\"]) 将小提琴宽度缩放为每个分箱中观察到的数据点数目： >>> ax = sns.violinplot(x=\"day\", y=\"total_bill\", hue=\"sex\", ... data=tips, palette=\"Set2\", split=True, ... scale=\"count\") 将四分位数绘制为水平线,迷你箱型图： >>> ax = sns.violinplot(x=\"day\", y=\"total_bill\", hue=\"sex\", ... data=tips, palette=\"Set2\", split=True, ... scale=\"count\", inner=\"quartile\") 用小提琴图内部的横线显示每个观察到的数据点： >>> ax = sns.violinplot(x=\"day\", y=\"total_bill\", hue=\"sex\", ... data=tips, palette=\"Set2\", split=True, ... scale=\"count\", inner=\"stick\") 根据所有分箱的数据点数目对密度进行缩放： >>> ax = sns.violinplot(x=\"day\", y=\"total_bill\", hue=\"sex\", ... data=tips, palette=\"Set2\", split=True, ... scale=\"count\", inner=\"stick\", scale_hue=False) 使用窄带宽来减少平滑量： >>> ax = sns.violinplot(x=\"day\", y=\"total_bill\", hue=\"sex\", ... data=tips, palette=\"Set2\", split=True, ... scale=\"count\", inner=\"stick\", ... scale_hue=False, bw=.2) 绘制横向小提琴图： >>> planets = sns.load_dataset(\"planets\") >>> ax = sns.violinplot(x=\"orbital_period\", y=\"method\", ... data=planets[planets.orbital_period 使用 hue 而不改变小提琴图的位置或宽度： >>> tips[\"weekend\"] = tips[\"day\"].isin([\"Sat\", \"Sun\"]) >>> ax = sns.violinplot(x=\"day\", y=\"total_bill\", hue=\"weekend\", ... data=tips, dodge=False) 把 catplot() 与 violinplot() 以及 FacetGrid 结合起来使用。这允许您通过额外的分类变量进行分组。使用 catplot() 比直接使用 FacetGrid 更为安全，因为它保证了不同切面上变量同步的顺序： >>> g = sns.catplot(x=\"sex\", y=\"total_bill\", ... hue=\"smoker\", col=\"time\", ... data=tips, kind=\"violin\", split=True, ... height=4, aspect=.7); Update time： 2020-05-23 "},"Chapter7/seaborn.boxenplot.html":{"url":"Chapter7/seaborn.boxenplot.html","title":"seaborn.boxenplot","keywords":"","body":"seaborn.boxenplot seaborn.boxenplot(x=None, y=None, hue=None, data=None, order=None, hue_order=None, orient=None, color=None, palette=None, saturation=0.75, width=0.8, dodge=True, k_depth='proportion', linewidth=None, scale='exponential', outlier_prop=None, ax=None, **kwargs) 为更大的数据集绘制增强的箱型图。 这种风格的绘图最初被命名为“信值图”，因为它显示了大量被定义为“置信区间”的分位数。它类似于绘制分布的非参数表示的箱形图，其中所有特征对应于实际观察的数值点。通过绘制更多分位数，它提供了有关分布形状的更多信息，特别是尾部数据的分布。欲了解更详细的解释，您可以阅读介绍该绘图的论文： https://vita.had.co.nz/papers/letter-value-plot.html 输入数据可以通过多种格式传入，包括： 格式为列表，numpy 数组或 pandas Series 对象的数据向量可以直接传递给x，y和hue参数。 对于长格式的 DataFrame，x，y，和hue参数会决定如何绘制数据。 对于宽格式的 DataFrame，每一列数值列都会被绘制。 一个数组或向量的列表。 在大多数情况下，可以使用 numpy 或 Python 对象，但更推荐使用 pandas 对象，因为与数据关联的列名/行名可以用于标注横轴/纵轴的名称。此外，您可以使用分类类型对变量进行分组以控制绘图元素的顺序。 此函数始终将其中一个变量视为分类，并在相关轴上的序数位置(0,1，... n)处绘制数据，即使数据属于数值类型或日期类型也是如此。 更多信息请参阅 教程。 参数：x, y, hue：data或向量数据中的变量名称，可选 用于绘制长格式数据的输入。查看样例以进一步理解。 data：DataFrame，数组，数组列表，可选 用于绘图的数据集。如果x和y都缺失，那么数据将被视为宽格式。否则数据被视为长格式。 order, hue_order：字符串列表，可选 控制分类变量（对应的条形图）的绘制顺序，若缺失则从数据中推断分类变量的顺序。 orient：“v” | “h”，可选 控制绘图的方向（垂直或水平）。这通常是从输入变量的 dtype 推断出来的，但是当“分类”变量为数值型或绘制宽格式数据时可用于指定绘图的方向。 color：matplotlib 颜色，可选 所有元素的颜色，或渐变调色板的种子颜色。 palette：调色板名称，列表或字典，可选 用于hue变量的不同级别的颜色。可以从 color_palette() 得到一些解释，或者将色调级别映射到 matplotlib 颜色的字典。 saturation：float，可选 控制用于绘制颜色的原始饱和度的比例。通常大幅填充在轻微不饱和的颜色下看起来更好，如果您希望绘图颜色与输入颜色规格完美匹配可将其设置为1。 width：float，可选 不使用色调嵌套时完整元素的宽度，或主要分组变量一个级别的所有元素的宽度。 dodge：bool，可选 使用色调嵌套时，元素是否应沿分类轴移动。 k_depth：“proportion” | “tukey” | “trustworthy”，可选 通过增大百分比的粒度控制绘制的盒形图数目。所有方法都在 Wickham 的论文中有详细描述。每个参数代表利用不同的统计特性对异常值的数量做出不同的假设。 linewidth：float，可选 构图元素的灰线宽度。 scale：“linear” | “exponential” | “area” 用于控制增强箱型图宽度的方法。所有参数都会给显示效果造成影响。 “linear” 通过恒定的线性因子减小宽度，“exponential” 使用未覆盖的数据的比例调整宽度， “area” 与所覆盖的数据的百分比成比例。 outlier_prop：float，可选 被认为是异常值的数据比例。与 k_depth 结合使用以确定要绘制的百分位数。默认值为 0.007 作为异常值的比例。该参数取值应在[0,1]范围内。 ax：matplotlib 轴，可选 绘图时使用的 Axes 轴对象，否则使用当前 Axes 轴对象。 kwargs：键，值映射 其他在绘制时传递给plt.plot和plt.scatter参数。 返回值：ax：matplotlib 轴 返回 Axes 对轴象，并在其上绘制绘图。 亦可参见 boxplot 和核密度估计的结合。一个传统的箱型图具有类似的 API。 示例 绘制一个独立的横向增强箱型图： >>> import seaborn as sns >>> sns.set(style=\"whitegrid\") >>> tips = sns.load_dataset(\"tips\") >>> ax = sns.boxenplot(x=tips[\"total_bill\"]) 根据分类变量分组绘制一个纵向的增强箱型图： >>> ax = sns.boxenplot(x=\"day\", y=\"total_bill\", data=tips) 根据 2 个分类变量嵌套分组绘制一个增强箱型图： >>> ax = sns.boxenplot(x=\"day\", y=\"total_bill\", hue=\"smoker\", ... data=tips, palette=\"Set3\") 当一些数据为空时根据嵌套分组绘制一个增强箱型图： >>> ax = sns.boxenplot(x=\"day\", y=\"total_bill\", hue=\"time\", ... data=tips, linewidth=2.5) 通过显式传入参数指定顺序控制箱型图的显示顺序： >>> ax = sns.boxenplot(x=\"time\", y=\"tip\", data=tips, ... order=[\"Dinner\", \"Lunch\"]) 针对 DataFrame 里每一个数值型变量绘制增强箱型图： >>> iris = sns.load_dataset(\"iris\") >>> ax = sns.boxenplot(data=iris, orient=\"h\", palette=\"Set2\") 使用 stripplot() 显示箱型图顶部的数据点： >>> ax = sns.boxenplot(x=\"day\", y=\"total_bill\", data=tips) >>> ax = sns.stripplot(x=\"day\", y=\"total_bill\", data=tips, ... size=4, jitter=True, color=\"gray\") 将 catplot() to combine boxenplot() 以及 FacetGrid 结合起来使用。这允许您通过额外的分类变量进行分组。使用 catplot() 比直接使用 FacetGrid 更为安全，因为它保证了不同切面上变量同步的顺序： >>> g = sns.catplot(x=\"sex\", y=\"total_bill\", ... hue=\"smoker\", col=\"time\", ... data=tips, kind=\"boxen\", ... height=4, aspect=.7); Update time： 2020-05-23 "},"Chapter7/seaborn.barplot.html":{"url":"Chapter7/seaborn.barplot.html","title":"seaborn.barplot","keywords":"","body":"seaborn.barplot seaborn.barplot(x=None, y=None, hue=None, data=None, order=None, hue_order=None, estimator=, ci=95, n_boot=1000, units=None, orient=None, color=None, palette=None, saturation=0.75, errcolor='.26', errwidth=None, capsize=None, dodge=True, ax=None, **kwargs) 条形图以矩形条的方式展示数据的点估值和置信区间 条形图用每个矩形的高度来表示数值变量的集中趋势的估计值，并提供误差条来显示估计值得不确定度。条形图的纵轴是从零开始的，这对于 0 值是有意义的情况是非常好的。 对于数据集中的 0 值没有实际意义的情况，散点图可以让您专注于一个或多个分类变量之间的差异。 要注意的是，条形图只显示平均值（或者其他的估计值），但是在大部分情况下，展示数值在不同分类变量上的分布会更有用。如果要表示出数据的分布，用箱型图或者小提琴图会更恰当。 输入数据的格式可以不同，包括： 以列表，numpy array 或者 pandas 中的 Series object 表示的向量。这些向量可以直接传入 x, y, 以及 hue 参数。 长表, x 值，y 值和色相变量决定了数据是如何绘制的。 宽表，每个列的数值都会被绘制出来. 数组或者列表的向量。 大多数情况下，您可以使用 numpy 的对象或者 python 的对象，但是用 pandas 对象更好，因为相关的列名会被标注在图标上。 另外，为了控制绘图元素 您也可以可以用分类类型来组合不同的变量。 这个函数始终把一个变量当做分类变量，即使这个数据是数值类型或者日期类型，并且按照序数顺序绘制在相关的轴上。 详情请看教程。 参数：x, y, hue：data 中的变量名词或者向量, optional 用于绘制 long-form 数据的变量名称. data：DataFrame, 数组, 数组列表, optional 用于绘图的数据集。如果数据集有 x 和 y，数据集会被认为是 long-form，否则会被认为是 wide-form。 order, hue_order：字符串列表, optional 绘制类别变量的顺序，如果没有，则从数据对象中推断绘图顺序。 estimator：映射向量 -> 标量, optional 统计函数用于估计每个分类纸条中的值。. ci：float or “sd” or None, optional 估计值周围的置信区间大小。如果输入的是 “sd”（标准差），会跳过 bootstrapping 的过程，只绘制数据的标准差。 如果输入是的是None, 不会执行 botstrapping，而且错误条也不会绘制。 n_boot：int, optional 计算置信区间需要的 Boostrap 迭代次数。 units：name of variable in data or vector data, optional 采样单元的标识符，用于执行多级 bootstrap 并解释重复测量设计。 orient：“v” | “h”, optional 绘图的方向（垂直或水平）。这通常是从输入变量的数据类型推断出来的，但是可以用来指定“分类”变量是数字还是宽格式数据。 color：matplotlib color, optional 作用于所有元素的颜色，或者渐变色的种子。 palette：palette name, list, or dict, optional 不同级别的 hue 变量的颜色。 颜色要能被 [color_palette()]解释(seaborn.color_palette.html#seaborn.color_palette \"seaborn.color_palette\"), 或者一个能映射到 matplotlib 颜色的字典。 saturation：float, optional 原始饱和度的绘制颜色比例。 大色块通常看起来略带不饱和色，但看起来更好，但是如果您希望绘图颜色与输入颜色规格完全匹配，则将其设置为“ 1”. errcolor：matplotlib color 表示置信区间的线的颜色。 errwidth：float, optional 误差条的线的厚度。 capsize：float, optional 误差条端部的宽度。 dodge : 布尔型, optional 使用色相嵌套时，是否应沿分类轴移动元素。 ax：matplotlib Axes, optional 指定一个 Axes 用于绘图，如果不指定，则使用当前的 Axes。 kwargs：key, value mappings 其他的关键词参数在绘图时通过 plt.bar 传入。 返回值：ax：matplotlib Axes 返回有图表绘制的 Axes 对象。 See also 显示每个分类 bin 中的观察计数。使用散点图图示符显示点估计和置信区间。将分类图与类相结合:FacetGrid. Examples 绘制一组按类别变量分组的垂直条形图： >>> import seaborn as sns >>> sns.set(style=\"whitegrid\") >>> tips = sns.load_dataset(\"tips\") >>> ax = sns.barplot(x=\"day\", y=\"total_bill\", data=tips) 绘制一组由两个变量嵌套分组的垂直条形图： >>> ax = sns.barplot(x=\"day\", y=\"total_bill\", hue=\"sex\", data=tips) 绘制一组水平条形图： >>> ax = sns.barplot(x=\"tip\", y=\"day\", data=tips) 通过传入一个显式的顺序来控制条柱的顺序： >>> ax = sns.barplot(x=\"time\", y=\"tip\", data=tips, ... order=[\"Dinner\", \"Lunch\"]) 用中值来评估数据的集中趋势： >>> from numpy import median >>> ax = sns.barplot(x=\"day\", y=\"tip\", data=tips, estimator=median) 用误差条显示平均值的标准误差： >>> ax = sns.barplot(x=\"day\", y=\"tip\", data=tips, ci=68) 展示数据的标准差： >>> ax = sns.barplot(x=\"day\", y=\"tip\", data=tips, ci=\"sd\") 给误差条增加“端点”： >>> ax = sns.barplot(x=\"day\", y=\"tip\", data=tips, capsize=.2) 使用一个不同的调色盘来绘制图案： >>> ax = sns.barplot(\"size\", y=\"total_bill\", data=tips, ... palette=\"Blues_d\") 在不改变条柱的位置或者宽度的前提下，使用 hue : >>> tips[\"weekend\"] = tips[\"day\"].isin([\"Sat\", \"Sun\"]) >>> ax = sns.barplot(x=\"day\", y=\"total_bill\", hue=\"weekend\", ... data=tips, dodge=False) 用同一种颜色绘制所有条柱： >>> ax = sns.barplot(\"size\", y=\"total_bill\", data=tips, ... color=\"salmon\", saturation=.5) 用 plt.bar 关键字参数进一步改变图表的样式： >>> ax = sns.barplot(\"day\", \"total_bill\", data=tips, ... linewidth=2.5, facecolor=(1, 1, 1, 0), ... errcolor=\".2\", edgecolor=\".2\") 使用 catplot() 来结合 barplot() 和 FacetGrid. 这允许数据根据额外的类别变量分组。使用 catplot() 比直接使用 FacetGrid 更安全, 因为它可以确保变量在不同的 facet 之间保持同步: >>> g = sns.catplot(x=\"sex\", y=\"total_bill\", ... hue=\"smoker\", col=\"time\", ... data=tips, kind=\"bar\", ... height=4, aspect=.7); Update time： 2020-05-23 "},"Chapter7/seaborn.countplot.html":{"url":"Chapter7/seaborn.countplot.html","title":"seaborn.countplot","keywords":"","body":"seaborn.countplot seaborn.countplot(x=None, y=None, hue=None, data=None, order=None, hue_order=None, orient=None, color=None, palette=None, saturation=0.75, dodge=True, ax=None, **kwargs) seaborn.countplot 使用条形图显示每个类别中观测值的数量。 这个函数可以被认为是针对类别变量的直方图。基本的 API 和选项与barplot()完全相同，因此可以对比学习。 可以通过多种格式传入数据，包括： 通过列表、numpy 数组、或者 pandas Series 对象表示的向量数据，数据直接传给x, y, 和/或hue参数。 长格式的 DataFrame，此时会通过x, y以及hue变量决定如何绘制数据。 宽格式的 DataFrame，此时每个数值型的 column 都会被绘制。 数组或者列表形式的向量 在绝大多数情况下，数据格式都可以使用 numpy 或者 Python 对象，但是推荐使用 pandas 对象，因为 pandas 对象中相关的名称会被用于注释坐标轴。此外，可以通过设置分组变量为使用 Categorical 类型来控制绘制元素的顺序。 这个函数总会将变量作为类别变量进行处理，按顺序(0, 1, ... n)在相应坐标轴绘制数据，即使数据为数值或者日期类型。 更多信息参考tutorial. 参数：x, y, hue: data或者向量数据中的变量名，可选 用于绘制长格式数据的输入。查看解释示例 data：DataFrame, 数组，或者包含数组的列表，可选 用于绘制的数据集。如果x和y不存在，那么会将数据按宽格式进行处理，否则应当为长格式。 order, hue_order：包含字符串的列表，可选 类别层级绘制的顺序，否则层级会从数据对象中推测。 orient: “v” | “h”, 可选 绘制的朝向（竖直或者水平）。通过从输入变量的 dtype 进行推断。当类别变量是数值型或者绘制宽格式数据时，可以进行指定。 color: matplotlib 颜色，可选 所有元素的颜色，或者渐变调色盘的种子。 palette: 调色盘名称，列表或字典，可选 用于hue变量的不同级别的颜色。应当是color_palette()可以解释的东西，或者将色调级别映射到 matplotlib 颜色的字典。 saturation: float, 可选 在原有饱和度的比例下绘制颜色。大片的图块通常在略微不饱和的颜色下看起来更好，而如果想要绘制的颜色与输入颜色规格完全匹配，应当设置此值为1。 dodge: bool, 可选 当使用色调嵌套时，决定是否沿着类别轴对元素进行移位。 ax: matplotlib 轴，可选 绘制图像的轴对象，不指定时使用当前轴。 kwargs: 键值映射 其他关键字参数会被传递给plt.bar. 返回值：ax: matplotlib 轴 返回带有绘图的轴对象。 另请参阅 barplot(): 使用条形图显示点估计和置信区间。 factorplot(): 结合类别图与FacetGrid类。 示例 显示单个类别变量的计数值： >>> import seaborn as sns >>> sns.set(style=\"darkgrid\") >>> titanic = sns.load_dataset(\"titanic\") >>> ax = sns.countplot(x=\"class\", data=titanic) 显示两个类别变量的计数值： >>> ax = sns.countplot(x=\"class\", hue=\"who\", data=titanic) 水平绘制条形图： >>> ax = sns.countplot(y=\"class\", hue=\"who\", data=titanic) 使用不同的颜色色盘： >>> ax = sns.countplot(x=\"who\", data=titanic, palette=\"Set3\") 使用plt.bar的关键字参数获得不同的显示效果： >>> ax = sns.countplot(x=\"who\", data=titanic, ... facecolor=(0, 0, 0, 0), ... linewidth=5, ... edgecolor=sns.color_palette(\"dark\", 3)) 使用catplot()实现结合countplot()以及FacetGrid的效果。这样做可以在额外的类别变量中进行分组。使用catplot()比直接使用FacetGrid更加安全，因为这样做可以确保跨分面的变量顺序同步： >>> g = sns.catplot(x=\"class\", hue=\"who\", col=\"survived\", ... data=titanic, kind=\"count\", ... height=4, aspect=.7); Update time： 2020-05-23 "},"Chapter7/seaborn.jointplot.html":{"url":"Chapter7/seaborn.jointplot.html","title":"seaborn.jointplot","keywords":"","body":"seaborn.jointplot seaborn.jointplot(x, y, data=None, kind='scatter', stat_func=None, color=None, height=6, ratio=5, space=0.2, dropna=True, xlim=None, ylim=None, joint_kws=None, marginal_kws=None, annot_kws=None, **kwargs) 绘制两个变量的双变量及单变量图。 这个函数提供调用JointGrid类的便捷接口，以及一些封装好的绘图类型。这是一个轻量级的封装，如果需要更多的灵活性，应当直接使用JointGrid. 参数：x, y：strings 或者 vectors data中的数据或者变量名。 data：DataFrame, 可选 当x和y为变量名时的 DataFrame. kind：{ “scatter” | “reg” | “resid” | “kde” | “hex” }, 可选 绘制图像的类型。 stat_func：可调用的，或者 None, 可选 已过时 color：matplotlib 颜色, 可选 用于绘制元素的颜色。 height：numeric, 可选 图像的尺寸（方形）。 ratio：numeric, 可选 中心轴的高度与侧边轴高度的比例 space：numeric, 可选 中心和侧边轴的间隔大小 dropna：bool, 可选 如果为 True, 移除x和y中的缺失值。 {x, y}lim：two-tuples, 可选 绘制前设置轴的范围。 {joint, marginal, annot}_kws：dicts, 可选 额外的关键字参数。 kwargs：键值对 额外的关键字参数会被传给绘制中心轴图像的函数，取代joint_kws字典中的项。 返回值：grid：JointGrid JointGrid对象. 参考 绘制图像的 Grid 类。如果需要更多的灵活性，可以直接使用 Grid 类。 示例 绘制带有侧边直方图的散点图: >>> import numpy as np, pandas as pd; np.random.seed(0) >>> import seaborn as sns; sns.set(style=\"white\", color_codes=True) >>> tips = sns.load_dataset(\"tips\") >>> g = sns.jointplot(x=\"total_bill\", y=\"tip\", data=tips) 添加回归线及核密度拟合: >>> g = sns.jointplot(\"total_bill\", \"tip\", data=tips, kind=\"reg\") 将散点图替换为六角形箱体图: >>> g = sns.jointplot(\"total_bill\", \"tip\", data=tips, kind=\"hex\") 将散点图和直方图替换为密度估计，并且将侧边轴与中心轴对齐: >>> iris = sns.load_dataset(\"iris\") >>> g = sns.jointplot(\"sepal_width\", \"petal_length\", data=iris, ... kind=\"kde\", space=0, color=\"g\") 绘制散点图，添加中心密度估计: >>> g = (sns.jointplot(\"sepal_length\", \"sepal_width\", ... data=iris, color=\"k\") ... .plot_joint(sns.kdeplot, zorder=0, n_levels=6)) 不适用 Pandas, 直接传输向量，随后给轴命名: >>> x, y = np.random.randn(2, 300) >>> g = (sns.jointplot(x, y, kind=\"hex\") ... .set_axis_labels(\"x\", \"y\")) 绘制侧边图空间更大的图像: >>> g = sns.jointplot(\"total_bill\", \"tip\", data=tips, ... height=5, ratio=3, color=\"g\") 传递关键字参数给后续绘制函数: >>> g = sns.jointplot(\"petal_length\", \"sepal_length\", data=iris, ... marginal_kws=dict(bins=15, rug=True), ... annot_kws=dict(stat=\"r\"), ... s=40, edgecolor=\"w\", linewidth=1) Update time： 2020-05-23 "},"Chapter7/seaborn.pairplot.html":{"url":"Chapter7/seaborn.pairplot.html","title":"seaborn.pairplot","keywords":"","body":"seaborn.pairplot seaborn.pairplot(data, hue=None, hue_order=None, palette=None, vars=None, x_vars=None, y_vars=None, kind='scatter', diag_kind='auto', markers=None, height=2.5, aspect=1, dropna=True, plot_kws=None, diag_kws=None, grid_kws=None, size=None) 绘制数据集中的成对关系 默认情况下，此函数将创建一个 Axes 网络，以便data中的每个变量将在 y 轴上共享一行，并在 x 轴上共享一列。对角轴的处理方式并不同，以此绘制一个图表来显示该列中变量的数据的单变量分布。 还可以显示变量的子集或在行和列上绘制不同的变量。 这是PairGrid的高级界面，旨在简化一些常见的样式。如果你需要更多的灵活性，你应该直接使用PairGrid。 参数：data：数据框架 整洁（长形式）数据框，其中每列是变量，每行是观察量。 hue：字符串（变量名），可选。 data中的变量将绘图方面映射到不同的颜色。 hue_order：字符串列表。 命令调色板中的色调变量的级别。 palette：字典或 seaborn 调色板。 用于映射hue变量的颜色集。如果是字典，关键字应该是hue变量中的值。 vars：变量名列表，可选。 要使用的data中的变量，否则每一列使用数字的数据类型。 {x, y}_vars：变量名列表，可选。 data中的变量分别用于图的行和列；即制作非方形图。 kind：{‘scatter’, ‘reg’}, 可选。 一种非等同关系(非对角线)的图类型 diag_kind：{‘auto’, ‘hist’, ‘kde’}, 可选 对角线子图的一种图形。默认值取决于是否使用hue。 markers：单个 matplotlit 标记代码或列表，可选 要么是用于所有数据点的标记，要么是长度和色调变量中的级别数相同的标记列表，这样不同颜色的点也会有不同的散点图标记。 height：标量，可选。 每个刻面的高度（以英寸为单位） aspect：标量，可选。 Aspect*height 给出每个刻面的宽度（以英寸为单位） dropna：布尔值，可选。 在绘图之前删除数据中的缺失值。 {plot, diag, grid}_kws：字典，可选。 关键字参数的字典。 返回值：grid：PairGrid 返回底层的PairGrid实例以进一步调整。 也可以看看 子图网络可以更灵活地绘制成对关系。 范例 绘制联合关系地散点图和单变量分布的直方图： >>> import seaborn as sns; sns.set(style=\"ticks\", color_codes=True) >>> iris = sns.load_dataset(\"iris\") >>> g = sns.pairplot(iris) 通过绘图元素的颜色显示分类变量的不同级别： >>> g = sns.pairplot(iris, hue=\"species\") 使用不同的调色板： >>> g = sns.pairplot(iris, hue=\"species\", palette=\"husl\") 为hue变量的每个级别使用不同的标记： >>> g = sns.pairplot(iris, hue=\"species\", markers=[\"o\", \"s\", \"D\"]) 绘制变量的子集： >>> g = sns.pairplot(iris, vars=[\"sepal_width\", \"sepal_length\"]) 绘制更大的图： >>> g = sns.pairplot(iris, height=3, ... vars=[\"sepal_width\", \"sepal_length\"]) 在行和列中绘制不同的变量： >>> g = sns.pairplot(iris, ... x_vars=[\"sepal_width\", \"sepal_length\"], ... y_vars=[\"petal_width\", \"petal_length\"]) 对单变量图使用核密度估计： >>> g = sns.pairplot(iris, diag_kind=\"kde\") 将线性回归模型拟合到散点图： >>> g = sns.pairplot(iris, kind=\"reg\") 将关键字参数传递给底层函数（直接使用PairGrid可能更容易） >>> g = sns.pairplot(iris, diag_kind=\"kde\", markers=\"+\", ... plot_kws=dict(s=50, edgecolor=\"b\", linewidth=1), ... diag_kws=dict(shade=True)) Update time： 2020-05-23 "},"Chapter7/seaborn.distplot.html":{"url":"Chapter7/seaborn.distplot.html","title":"seaborn.distplot","keywords":"","body":"seaborn.distplot seaborn.distplot(a, bins=None, hist=True, kde=True, rug=False, fit=None, hist_kws=None, kde_kws=None, rug_kws=None, fit_kws=None, color=None, vertical=False, norm_hist=False, axlabel=None, label=None, ax=None) 灵活绘制单变量观测值分布图。 该函数结合了 matplotlib 中的 hist函数（自动计算一个默认的合适的 bin 大小）、seaborn 的kdeplot()和rugplot()函数。它还可以拟合scipy.stats分布并在数据上绘制估计的 PDF（概率分布函数）。 参数：a：Series、1 维数组或者列表。 观察数据。如果是具有name属性的 Series 对象，则该名称将用于标记数据轴。 bins：matplotlib hist()的参数，或 None。可选参数。 直方图 bins（柱）的数目，若填 None，则默认使用 Freedman-Diaconis 规则指定柱的数目。 hist：布尔值，可选参数。 是否绘制（标准化）直方图。 kde：布尔值，可选参数。 是否绘制高斯核密度估计图。 rug：布尔值，可选参数。 是否在横轴上绘制观测值竖线。 fit：随机变量对象，可选参数。 一个带有fit方法的对象，返回一个元组，该元组可以传递给pdf方法一个位置参数，该位置参数遵循一个值的网格用于评估 pdf。 {hist, kde, rug, fit}_kws：字典，可选参数。 底层绘图函数的关键字参数。 color：matplotlib color，可选参数。 可以绘制除了拟合曲线之外所有内容的颜色。 vertical：布尔值，可选参数。 如果为 True，则观测值在 y 轴显示。 norm_hist：布尔值，可选参数。 如果为 True，则直方图的高度显示密度而不是计数。如果绘制 KDE 图或拟合密度，则默认为 True。 axlabel：字符串，False 或者 None，可选参数。 横轴的名称。如果为 None，将尝试从 a.name 获取它；如果为 False，则不设置标签。 label：字符串，可选参数。 图形相关组成部分的图例标签。 ax：matplotlib axis，可选参数。 若提供该参数，则在参数设定的轴上绘图。 返回值：ax：matplotlib Axes 返回 Axes 对象以及用于进一步调整的绘图。 另请参见 kdeplot 显示具有核密度估计图的单变量或双变量分布。 rugplot 绘制小的垂直线以显示分布中的每个观测值。 范例 显示具有核密度估计的默认图和使用参考规则自动确定 bin 大小的直方图： >>> import seaborn as sns, numpy as np >>> sns.set(); np.random.seed(0) >>> x = np.random.randn(100) >>> ax = sns.distplot(x) 使用 Pandas 对象获取信息轴标签： >>> import pandas as pd >>> x = pd.Series(x, name=\"x variable\") >>> ax = sns.distplot(x) 使用核密度估计和小的垂直线绘制分布图： >>> ax = sns.distplot(x, rug=True, hist=False) 使用直方图和最大似然高斯分布拟合绘制分布图： >>> from scipy.stats import norm >>> ax = sns.distplot(x, fit=norm, kde=False) 在垂直轴上绘制分布图： >>> ax = sns.distplot(x, vertical=True) 更改所有绘图元素的颜色： >>> sns.set_color_codes() >>> ax = sns.distplot(x, color=\"y\") 将特定参数传递给基础绘图函数： >>> ax = sns.distplot(x, rug=True, rug_kws={\"color\": \"g\"}, ... kde_kws={\"color\": \"k\", \"lw\": 3, \"label\": \"KDE\"}, ... hist_kws={\"histtype\": \"step\", \"linewidth\": 3, ... \"alpha\": 1, \"color\": \"g\"}) Update time： 2020-05-23 "},"Chapter7/seaborn.kdeplot.html":{"url":"Chapter7/seaborn.kdeplot.html","title":"seaborn.kdeplot","keywords":"","body":"seaborn.kdeplot seaborn.kdeplot(data, data2=None, shade=False, vertical=False, kernel='gau', bw='scott', gridsize=100, cut=3, clip=None, legend=True, cumulative=False, shade_lowest=True, cbar=False, cbar_ax=None, cbar_kws=None, ax=None, **kwargs) 拟合并绘制单变量或双变量核密度估计图。 参数： data：一维阵列 输入数据 data2：一维阵列，可选。 第二输入数据。如果存在，将估计双变量 KDE。 shade：布尔值，可选参数。 如果为 True，则在 KDE 曲线下方的区域中增加阴影（或者在数据为双变量时使用填充的轮廓绘制）。 vertical：布尔值，可选参数。 如果为 True，密度图将显示在 x 轴。 kernel：{‘gau’ | ‘cos’ | ‘biw’ | ‘epa’ | ‘tri’ | ‘triw’ }，可选参数 要拟合的核的形状，双变量 KDE 只能使用高斯核。 bw：{‘scott’ | ‘silverman’ | scalar | pair of scalars }，可选参数 用于确定双变量图的每个维的核大小、标量因子或标量的参考方法的名称。需要注意的是底层的计算库对此参数有不同的交互：statsmodels直接使用它，而scipy将其视为数据标准差的缩放因子。 gridsize：整型数据，可选参数。 评估网格中的离散点数。 cut：标量，可选参数。 绘制估计值以从极端数据点切割* bw。 clip：一对标量，可选参数。 用于拟合 KDE 图的数据点的上下限值。可以为双变量图提供一对（上，下）边界。 legend：布尔值，可选参数。 如果为 True，为绘制的图像添加图例或者标记坐标轴。 cumulative：布尔值，可选参数。 如果为 True，则绘制 kde 估计图的累积分布。 shade_lowest：布尔值，可选参数。 如果为 True，则屏蔽双变量 KDE 图的最低轮廓。绘制单变量图或“shade = False”时无影响。当你想要在同一轴上绘制多个密度时，可将此参数设置为“False”。 cbar：布尔值，可选参数。 如果为 True 并绘制双变量 KDE 图，为绘制的图像添加颜色条。 cbar_ax：matplotlib axes，可选参数。 用于绘制颜色条的坐标轴，若为空，就在主轴绘制颜色条。 cbar_kws：字典，可选参数。 fig.colorbar（）的关键字参数。 ax：matplotlib axes，可选参数。 要绘图的坐标轴，若为空，则使用当前轴。 kwargs：键值对 其他传递给plt.plot（）或plt.contour {f}的关键字参数，具体取决于是绘制单变量还是双变量图。 返回值：ax：matplotlib Axes 绘图的坐标轴。 另请参见 distplot 灵活绘制单变量观测值分布图。 jointplot 绘制一个具有双变量和边缘分布的联合数据集。 范例 绘制一个简单的单变量分布： >>> import numpy as np; np.random.seed(10) >>> import seaborn as sns; sns.set(color_codes=True) >>> mean, cov = [0, 2], [(1, .5), (.5, 1)] >>> x, y = np.random.multivariate_normal(mean, cov, size=50).T >>> ax = sns.kdeplot(x) 在密度曲线下使用不同的颜色着色： >>> ax = sns.kdeplot(x, shade=True, color=\"r\") 绘制一个双变量分布： >>> ax = sns.kdeplot(x, y) 使用填充轮廓： >>> ax = sns.kdeplot(x, y, shade=True) 使用更多的轮廓级别和不同的调色板： >>> ax = sns.kdeplot(x, y, n_levels=30, cmap=\"Purples_d\") 使用窄带宽： >>> ax = sns.kdeplot(x, bw=.15) 在纵轴上绘制密度分布： >>> ax = sns.kdeplot(y, vertical=True) 将密度曲线限制在数据范围内: >>> ax = sns.kdeplot(x, cut=0) 为轮廓添加一个颜色条: >>> ax = sns.kdeplot(x, y, cbar=True) 为双变量密度图绘制两个阴影： >>> iris = sns.load_dataset(\"iris\") >>> setosa = iris.loc[iris.species == \"setosa\"] >>> virginica = iris.loc[iris.species == \"virginica\"] >>> ax = sns.kdeplot(setosa.sepal_width, setosa.sepal_length, ... cmap=\"Reds\", shade=True, shade_lowest=False) >>> ax = sns.kdeplot(virginica.sepal_width, virginica.sepal_length, ... cmap=\"Blues\", shade=True, shade_lowest=False) Update time： 2020-05-23 "},"Chapter7/seaborn.lmplot.html":{"url":"Chapter7/seaborn.lmplot.html","title":"seaborn.lmplot","keywords":"","body":"seaborn.lmplot seaborn.lmplot(x, y, data, hue=None, col=None, row=None, palette=None, col_wrap=None, height=5, aspect=1, markers='o', sharex=True, sharey=True, hue_order=None, col_order=None, row_order=None, legend=True, legend_out=True, x_estimator=None, x_bins=None, x_ci='ci', scatter=True, fit_reg=True, ci=95, n_boot=1000, units=None, order=1, logistic=False, lowess=False, robust=False, logx=False, x_partial=None, y_partial=None, truncate=False, x_jitter=None, y_jitter=None, scatter_kws=None, line_kws=None, size=None) 在 FacetGrid 对象上绘制数据和回归模型。 这个函数结合了 regplot() 和 FacetGrid。 它预期作为一个能够将回归模型运用在数据集处于不同条件下的子数据集的方便的接口 在考虑如何将变量分配到不同方面时，一般规则是使用 hue 进行最重要的比较，然后使用 col 和 row。 但是，请始终考虑您的特定数据集以及您正在创建的可视化目标。 估算回归模型有许多互斥的选项。 有关详细信息，请参阅 tutorial 。 此函数的参数涵盖了 FacetGrid中的大多数选项，尽管这样，偶尔还是会出现您需要直接使用该类和 regplot() 的情况。 参数：x, y：字符串，可选 输入变量; 这些应该是data中的列名。 data：DataFrame Tidy (“long-form”)格式的 DataFrame，其中每列为一个变量，每行为一个观测样本。 hue, col, row：字符串 定义数据子集的变量，将在网格中的不同构面上绘制。 请参阅* _order参数以控制此变量的级别顺序。 palette： 调色板名称，列表或字典，可选 用于hue变量的不同级别的颜色。 应该是 color_palette()可以解释的东西，或者是将色调级别映射到 matplotlib 颜色的字典。 col_wrap：整数，可选 以此宽度“包裹”列变量，以便列分面（facet）跨越多行。 与row 分面（facet）不兼容。 height： 标量，可选 每个分面（facet）的高度（以英寸为单位）。 另见：aspect。 aspect：标量，可选 每个分面（facet）的纵横比，因此aspect * height给出每个分面（facet）的宽度，单位为英寸。 markers：matplotlib 标记代码或标记代码列表，可选 散点图的标记。如果是列表，列表中的每个标记将用于hue变量的每个级别。 share{x,y}：布尔值，‘col’,或 ‘row’ ，可选 如果为 true，则分面（facet）之间将跨列共享 y 轴和/或跨行共享 x 轴。 {hue,col,row}_order：列表，可选 分面变量的级别顺序。在默认情况下，这将是级别在“data”中出现的顺序，或者，如果变量是 pandas 的分类类别变量，则为类别的顺序。 legend：布尔值，可选 如果为“True”并且有一个hue变量，则添加一个图例。 legend_out：布尔值，可选 如果为“True”，图形尺寸将被扩展，图例将被绘制在图像中部右侧之外。 x_estimator：可调用的映射向量->标量，可选 将此函数应用于x的每个唯一值并绘制结果的估计值。当x是离散变量时，这是十分有用的。如果给出x_ci，则该估计将被引导并且将绘制置信区间。 x_bins：整数或向量，可选 将x变量加入离散区间，然后估计中心趋势和置信区间。 此分箱仅影响散点图的绘制方式; 回归仍然适合原始数据。该参数被解释为均匀大小（不必要间隔）的箱的数量或箱中心的位置。使用此参数时，它意味着x_estimator的默认值为numpy.mean。 x_ci：“ci”。“sd”， 在[0,100]间的整数或 None，可选 绘制“x”离散值的集中趋势时使用的置信区间的大小。 如果为“ci”，遵循ci参数的值。 如果是“sd”，则跳过 bootstrapping 并显示每个 bin 中观察值的标准偏差。 scatter：布尔值，可选 如果为 True，则绘制带有基础观测值（或x_estimator 值）的散点图。 fit_reg：布尔值，可选 如果为 True，则估计并绘制与 x 和 y 变量相关的回归模型。 ci：在[0,100]间的整数或 None，可选 回归估计的置信区间的大小。这将使用回归线周围的半透明带绘制。 使用自助法（bootstrap）估计置信区间; 对于大型数据集，建议通过将此参数设置为 None 来避免该计算。 n_boot：整数，可选 用于估计ci的自助法（bootstrap）重采样数。 默认值试图在时间和稳定性之间找到平衡; 你可能希望为“最终”版本的图像增加此值。 units：data中的变量名，可选 如果x和y观察结果嵌套在采样单元中，则可以在此处指定。在通过对所有的单元和观察样本（在单元内）执行重新采样的多级自助法（multilevel bootstrap）来计算置信区间时将考虑这一点。 否则，这不会影响估计或绘制回归的方式。 order：整数，可选 如果order大于 1，使用numpy.polyfit来估计多项式回归。 logistic：布尔值，可选 如果为“True”，则假设y是二元变量并使用statsmodels来估计逻辑回归模型。 请注意，这比线性回归的计算密集程度要大得多，因此您可能希望减少引导程序重新采样（n_boot）的数量或将 ci设置为“无”。 lowess：布尔值，可选 如果为“True”，则使用statsmodels来估计非参数 lowess 模型（局部加权线性回归）。 请注意，目前无法为此类模型绘制置信区间。 robust：布尔值，可选 如果为“True”，则使用statsmodels来估计稳健回归。 这将削弱异常值。 请注意，这比标准线性回归的计算密集程度要大得多，因此您可能希望减少引导程序重新采样（n_boot）的数量或将 ci设置为“无”。 logx：布尔值，可选 如果为 True，则估计形式 y~log（x）的线性回归，但在输入空间中绘制散点图和回归模型。 请注意，x必须为正才能正常工作。 {x,y}_partial： data中的字符串或矩阵 混淆（Confounding）变量以在绘图之前退回x或y变量。 truncate：布尔值，可选 默认情况下，绘制回归线以在绘制散点图后填充 x 轴限制。 如果truncate是True，它将改为受到数据本身限制的限制。 {x,y}_jitter：浮点数，可选 将此大小的均匀随机噪声添加到“x”或“y”变量中。 在拟合回归之后，噪声被添加到数据的副本中，并且仅影响散点图的外观。 在绘制采用离散值的变量时，这会很有用。 {scatter,line}_kws：字典 传递给plt.scatter和plt.plot的附加关键字参数。 也可以查看 绘制数据和条件模型 fit.Subplot 网格用于绘制条件关系。合并 regplot() 和 PairGrid （与kind =“reg”一起使用时）。 注意 regplot() 与 lmplot() 函数是紧密关联的，但是前者是一个坐标轴级别的函数，而后者则是一个联合了regplot() 与 FacetGrid的图像级别的函数。 示例 这些例子集中在基本的回归模型图上，以展示各种方面的选项; 请参阅 regplot() 文档，以演示绘制数据和模型的其他选项。 还有其他一些如何使用 FacetGrid 文档中的返回对象操作绘图的示例。 绘制两个变量之间的简单线性关系： >>> import seaborn as sns; sns.set(color_codes=True) >>> tips = sns.load_dataset(\"tips\") >>> g = sns.lmplot(x=\"total_bill\", y=\"tip\", data=tips) 条件在第三个变量上并绘制不同颜色的水平： >>> g = sns.lmplot(x=\"total_bill\", y=\"tip\", hue=\"smoker\", data=tips) 使用不同的标记和颜色，以便绘图更容易再现为黑白： >>> g = sns.lmplot(x=\"total_bill\", y=\"tip\", hue=\"smoker\", data=tips, ... markers=[\"o\", \"x\"]) 使用不同的调色板： >>> g = sns.lmplot(x=\"total_bill\", y=\"tip\", hue=\"smoker\", data=tips, ... palette=\"Set1\") 使用字典将hue级别映射到颜色： >>> g = sns.lmplot(x=\"total_bill\", y=\"tip\", hue=\"smoker\", data=tips, ... palette=dict(Yes=\"g\", No=\"m\")) 绘制不同列中第三个变量的级别： >>> g = sns.lmplot(x=\"total_bill\", y=\"tip\", col=\"smoker\", data=tips) 更改构面的高度和纵横比： >>> g = sns.lmplot(x=\"size\", y=\"total_bill\", hue=\"day\", col=\"day\", ... data=tips, height=6, aspect=.4, x_jitter=.1) 将列变量的级别换行为多行： >>> g = sns.lmplot(x=\"total_bill\", y=\"tip\", col=\"day\", hue=\"day\", ... data=tips, col_wrap=2, height=3) 两个变量上的条件形成一个完整的网格： >>> g = sns.lmplot(x=\"total_bill\", y=\"tip\", row=\"sex\", col=\"time\", ... data=tips, height=3) 在返回的 FacetGrid 实例上使用方法来进一步调整图像： >>> g = sns.lmplot(x=\"total_bill\", y=\"tip\", row=\"sex\", col=\"time\", ... data=tips, height=3) >>> g = (g.set_axis_labels(\"Total bill (US Dollars)\", \"Tip\") ... .set(xlim=(0, 60), ylim=(0, 12), ... xticks=[10, 30, 50], yticks=[2, 6, 10]) ... .fig.subplots_adjust(wspace=.02)) Update time： 2020-05-23 "},"Chapter7/seaborn.regplot.html":{"url":"Chapter7/seaborn.regplot.html","title":"seaborn.regplott","keywords":"","body":"seaborn.regplott seaborn.regplot(x, y, data=None, x_estimator=None, x_bins=None, x_ci='ci', scatter=True, fit_reg=True, ci=95, n_boot=1000, units=None, order=1, logistic=False, lowess=False, robust=False, logx=False, x_partial=None, y_partial=None, truncate=False, dropna=True, x_jitter=None, y_jitter=None, label=None, color=None, marker='o', scatter_kws=None, line_kws=None, ax=None) 绘制数据和线性回归模型拟合。 估算回归模型有许多互斥的选项。查看这个教程 来了解更多的信息。 参数：x，y：字符串，序列（series）或者是向量数组（vector array） 输入变量。 如果是字符串，应该与data中的列名相对应。 使用 pandas 对象时，轴将被 Series 的名字标记。 data：DataFrame Tidy (“long-form”)格式的 DataFrame，其中每列为一个变量，每行为一个观测样本。 x_estimator：可调用的映射向量 ->标量，可选 将此函数应用于x的每个唯一值并绘制结果的估计值。当x是离散变量时，这是十分有用的。如果给出x_ci，则该估计将被引导并且将绘制置信区间。 x_bins：整数或向量，可选 将x变量加入离散区间，然后估计中心趋势和置信区间。 此分箱仅影响散点图的绘制方式; 回归仍然适合原始数据。该参数被解释为均匀大小（不必要间隔）的箱的数量或箱中心的位置。使用此参数时，它意味着x_estimator的默认值为numpy.mean。 x_ci：\"ci\"，'sd'，位于 [0, 100]之间的整数或 None，可选 绘制“x”离散值的集中趋势时使用的置信区间的大小。 如果为“ci”，遵循ci参数的值。 如果是“sd”，则跳过 bootstrapping 并显示每个 bin 中观察值的标准偏差。 scatter：布尔值，可选 如果为 True，则绘制带有基础观测值（或x_estimator 值）的散点图。 fit_reg：布尔值，可选 如果为 True，则估计并绘制与 x 和 y 变量相关的回归模型。 ci：位于 [0, 100]之间的整数或 None，可选 回归估计的置信区间的大小。这将使用回归线周围的半透明带绘制。 使用自助法（bootstrap）估计置信区间; 对于大型数据集，建议通过将此参数设置为 None 来避免该计算。 n_boot：整数，可选 用于估计ci的自助法（bootstrap）重采样数。 默认值试图在时间和稳定性之间找到平衡; 你可能希望为“最终”版本的图像增加此值。 units： data,中的变量名，可选 如果x和y观察结果嵌套在采样单元中，则可以在此处指定。在通过对所有的单元和观察样本（在单元内）执行重新采样的多级自助法（multilevel bootstrap）来计算置信区间时将考虑这一点。 否则，这不会影响估计或绘制回归的方式。 order：整数，可选 如果order大于 1，使用numpy.polyfit来估计多项式回归。 logistic：布尔值，可选 如果为“True”，则假设y是二元变量并使用statsmodels来估计逻辑回归模型。 请注意，这比线性回归的计算密集程度要大得多，因此您可能希望减少引导程序重新采样（n_boot）的数量或将 ci设置为“无”。 lowess：布尔值，可选 如果为“True”，则使用statsmodels来估计非参数 lowess 模型（局部加权线性回归）。 请注意，目前无法为此类模型绘制置信区间。 robust：布尔值，可选 如果为“True”，则使用statsmodels来估计稳健回归。 这将削弱异常值。 请注意，这比标准线性回归的计算密集程度要大得多，因此您可能希望减少引导程序重新采样（n_boot）的数量或将 ci设置为“无”。 logx：布尔值，可选 如果为 True，则估计形式 y~log（x）的线性回归，但在输入空间中绘制散点图和回归模型。 请注意，x必须为正才能正常工作。 {x,y}_partial： data 中的字符串或矩阵 混淆（Confounding）变量以在绘图之前退回x或y变量。 truncate：布尔值，可选 默认情况下，绘制回归线以在绘制散点图后填充 x 轴限制。 如果truncate是True，它将改为受到数据本身限制的限制。 {x,y}_jitter：浮点数，可选 将此大小的均匀随机噪声添加到“x”或“y”变量中。 在拟合回归之后，噪声被添加到数据的副本中，并且仅影响散点图的外观。 在绘制采用离散值的变量时，这会很有用。 label：字符串 要应用于散点图或回归线（如果scatter为'False`）的标签，以便在图例中使用。 color：matplotlib 颜色 适用于所有绘图元素的颜色; 将被scatter_kws或line_kws中传递的颜色取代。 marker：matplotlib 标记代码或标记代码列表，可选 散点图的标记。 {scatter,line}_kws：字典 传递给plt.scatter和plt.plot的附加关键字参数。 ax：matplotlib Axes 对象，可选 绘制到指定轴对象，否则在当前轴对象上绘图。 返回值：ax：matplotlib Axes 对象 包含了图像的 Axes 对象。 也可以看看 结合 regplot() 和 FacetGrid 来绘制数据集中的多个线性关系。 结合 regplot() 和 JointGrid （与kind=\"reg\"一起使用时）。结合 regplot() 和 PairGrid （当用于kind =“reg”）。绘制线性回归模型的残差。 注意 regplot() 和 lmplot() 函数密切相关，但是前者是坐标轴级别的函数，而后者是结合了regplot() 和 FacetGrid的图像级别的函数。 通过 jointplot() 和 pairplot() 函数来组合 regplot() 和 JointGrid 或 PairGrid 是十分容易的，虽然这些函数不直接接受所有 regplot()的参数。 例子 绘制 DataFrame 中两个变量之间的关系： >>> import seaborn as sns; sns.set(color_codes=True) >>> tips = sns.load_dataset(\"tips\") >>> ax = sns.regplot(x=\"total_bill\", y=\"tip\", data=tips) 利用两个定义为 numpy 数组的变量进行绘图; 使用不同的颜色： >>> import numpy as np; np.random.seed(8) >>> mean, cov = [4, 6], [(1.5, .7), (.7, 1)] >>> x, y = np.random.multivariate_normal(mean, cov, 80).T >>> ax = sns.regplot(x=x, y=y, color=\"g\") 利用两个定义为 pandas Series 的变量来进行绘图; 使用不同的标记： >>> import pandas as pd >>> x, y = pd.Series(x, name=\"x_var\"), pd.Series(y, name=\"y_var\") >>> ax = sns.regplot(x=x, y=y, marker=\"+\") 使用 68％置信区间，该区间对应于估计的标准误差： >>> ax = sns.regplot(x=x, y=y, ci=68) 使用离散的x变量进行绘图并添加一些抖动： >>> ax = sns.regplot(x=\"size\", y=\"total_bill\", data=tips, x_jitter=.1) 绘制一个离散的x变量，显示唯一值的均值和置信区间： >>> ax = sns.regplot(x=\"size\", y=\"total_bill\", data=tips, ... x_estimator=np.mean) 将连续的变量划分为分离的区间并进行绘图： >>> ax = sns.regplot(x=x, y=y, x_bins=4) 拟合高阶多项式回归并截断模型预测： >>> ans = sns.load_dataset(\"anscombe\") >>> ax = sns.regplot(x=\"x\", y=\"y\", data=ans.loc[ans.dataset == \"II\"], ... scatter_kws={\"s\": 80}, ... order=2, ci=None, truncate=True) 拟合稳健回归并且不绘制置信区间： >>> ax = sns.regplot(x=\"x\", y=\"y\", data=ans.loc[ans.dataset == \"III\"], ... scatter_kws={\"s\": 80}, ... robust=True, ci=None) 对数据运用逻辑回归; 抖动 y 变量并使用较少的 bootstrap 迭代： >>> tips[\"big_tip\"] = (tips.tip / tips.total_bill) > .175 >>> ax = sns.regplot(x=\"total_bill\", y=\"big_tip\", data=tips, ... logistic=True, n_boot=500, y_jitter=.03) 使用 log(x) 拟合回归模型并截断模型预测： >>> ax = sns.regplot(x=\"size\", y=\"total_bill\", data=tips, ... x_estimator=np.mean, logx=True, truncate=True) Update time： 2020-05-23 "},"Chapter7/seaborn.residplot.html":{"url":"Chapter7/seaborn.residplot.html","title":"seaborn.residplot","keywords":"","body":"seaborn.residplot seaborn.residplot(x, y, data=None, lowess=False, x_partial=None, y_partial=None, order=1, robust=False, dropna=True, label=None, color=None, scatter_kws=None, line_kws=None, ax=None) 绘制线性回归的残差。 此函数将在 x 上回归 y（可能作为鲁棒或多项式回归），然后绘制残差的散点图。 你可以选择将局部加权回归散点平滑法（LOWESS）拟合到残差图，这有助于确定残差是否存在结构。 参数：x： 向量或字符串 预测变量数据中的数据或列名称。 y：向量或字符串 响应变量的数据中的数据或列名称。 data：DataFrame, 可选 如果 x 和 y 是列名，则指定使用的 DataFrame lowess： 布尔值, 可选 将局部加权回归散点平滑法（LOWESS）应用到残差散点图中。 {x, y}_partial：矩阵或字符串，可选 具有与 x 相同的第一维的矩阵或数据中的列名称。这些变量被视为有误的，并在绘制之前从 x 或 y 变量中删除。 order：整数，可选 计算残差时拟合多项式的阶数。 robust：布尔值，可选 在计算残差时拟合稳健的线性回归。 dropna：布尔值，可选 如果为 True，则在拟合和绘图时忽略缺少的数据。 label：字符串，可选 将在任何图的图例中使用的标签。 color：matplotlib 颜色，可选 用于绘图的所有元素的颜色。 {scatter, line}_kws： 字典，可选 用于绘制图像的组件而传递给 scatter() 和 plot() 的其他关键字参数。 ax：matplotlib 轴，可选 绘制到指定轴对象，否则在当前轴对象上绘图，如果轴不存在则创建一个新轴。 返回值：ax：matplotlib Axes 对象 带有回归图像的轴对象 也可以看看 regplot 绘制一个简单的线性回归模型 jointplot 边际分布。 Update time： 2020-05-23 "},"Chapter7/seaborn.heatmap.html":{"url":"Chapter7/seaborn.heatmap.html","title":"seaborn.heatmap","keywords":"","body":"seaborn.heatmap seaborn.heatmap(data, vmin=None, vmax=None, cmap=None, center=None, robust=False, annot=None, fmt='.2g', annot_kws=None, linewidths=0, linecolor='white', cbar=True, cbar_kws=None, cbar_ax=None, square=False, xticklabels='auto', yticklabels='auto', mask=None, ax=None, **kwargs) 将矩形数据绘制为颜色编码矩阵。 这是一个坐标轴级的函数，如果没有提供给ax参数，它会将热力图绘制到当前活动的轴中。除非cbar为 False 或为cbar_ax提供单独的 Axes，否则将使用此轴空间的一部分绘制颜色图。 参数：data：矩形数据集 可以强制转换为 ndarray 格式数据的 2 维数据集。如果提供了 Pandas DataFrame 数据，索引/列信息将用于标记列和行。 vmin, vmax：浮点型数据，可选参数。 用于锚定色彩映射的值，否则它们是从数据和其他关键字参数推断出来的。 cmap：matplotlib 颜色条名称或者对象，或者是颜色列表，可选参数。 从数据值到颜色空间的映射。 如果没有提供，默认值将取决于是否设置了“center”。 center：浮点数，可选参数。 绘制有色数据时将色彩映射居中的值。 如果没有指定，则使用此参数将更改默认的cmap。 robust：布尔值，可选参数。 如果是 True，并且vmin或vmax为空，则使用稳健分位数而不是极值来计算色彩映射范围。 annot:布尔值或者矩形数据，可选参数。 如果为 True，则在每个热力图单元格中写入数据值。 如果数组的形状与data相同，则使用它来代替原始数据注释热力图。 fmt：字符串，可选参数。 添加注释时要使用的字符串格式代码。 annot_kws：字典或者键值对，可选参数。 当annot为 True 时，ax.text的关键字参数。 linewidths：浮点数，可选参数。 划分每个单元格的行的宽度。 linecolor：颜色，可选参数 划分每个单元的线条的颜色。 cbar：布尔值，可选参数。 描述是否绘制颜色条。 cbar_kws：字典或者键值对，可选参数。 fig.colorbar的关键字参数。 cbar_ax：matplotlib Axes，可选参数。 用于绘制颜色条的轴，否则从主轴获取。 square：布尔值，可选参数。 如果为 True，则将坐标轴方向设置为“equal”，以使每个单元格为方形。 xticklabels, yticklabels：“auto”，布尔值，类列表值，或者整形数值，可选参数。 如果为 True，则绘制数据框的列名称。如果为 False，则不绘制列名称。如果是列表，则将这些替代标签绘制为 xticklabels。如果是整数，则使用列名称，但仅绘制每个 n 标签。如果是“auto”，将尝试密集绘制不重叠的标签。 mask：布尔数组或者 DataFrame 数据，可选参数。 如果为空值，数据将不会显示在mask为 True 的单元格中。 具有缺失值的单元格将自动被屏蔽。 ax：matplotlib Axes，可选参数。 绘制图的坐标轴，否则使用当前活动的坐标轴。 kwargs：其他关键字参数。 所有其他关键字参数都传递给ax.pcolormesh。 返回值：ax：matplotlib Axes 热力图的轴对象。 另请参见 clustermap 使用分层聚类绘制矩阵以排列行和列。 范例 为 numpy 数组绘制热力图： >>> import numpy as np; np.random.seed(0) >>> import seaborn as sns; sns.set() >>> uniform_data = np.random.rand(10, 12) >>> ax = sns.heatmap(uniform_data) 更改默认的 colormap 范围： >>> ax = sns.heatmap(uniform_data, vmin=0, vmax=1) 使用发散色图绘制以 0 为中心的数据的热力图： >>> normal_data = np.random.randn(10, 12) >>> ax = sns.heatmap(normal_data, center=0) 使用特定的行和列标签绘制 dataframe： >>> flights = sns.load_dataset(\"flights\") >>> flights = flights.pivot(\"month\", \"year\", \"passengers\") >>> ax = sns.heatmap(flights) 使用整数格式的数字值注释每个小单元格： >>> ax = sns.heatmap(flights, annot=True, fmt=\"d\") 在每个单元格之间添加线： >>> ax = sns.heatmap(flights, linewidths=.5) 使用不同的 colormap： >>> ax = sns.heatmap(flights, cmap=\"YlGnBu\") 将 colormap 置于特定值的中心： >>> ax = sns.heatmap(flights, center=flights.loc[\"January\", 1955]) 绘制每个其他列标签，而不绘制行标签： >>> data = np.random.randn(50, 20) >>> ax = sns.heatmap(data, xticklabels=2, yticklabels=False) 不绘制颜色条： >>> ax = sns.heatmap(flights, cbar=False) 在不同的坐标轴方向绘制颜色条： >>> grid_kws = {\"height_ratios\": (.9, .05), \"hspace\": .3} >>> f, (ax, cbar_ax) = plt.subplots(2, gridspec_kw=grid_kws) >>> ax = sns.heatmap(flights, ax=ax, ... cbar_ax=cbar_ax, ... cbar_kws={\"orientation\": \"horizontal\"}) 使用遮罩绘制矩阵中的一部分 >>> corr = np.corrcoef(np.random.randn(10, 200)) >>> mask = np.zeros_like(corr) >>> mask[np.triu_indices_from(mask)] = True >>> with sns.axes_style(\"white\"): ... ax = sns.heatmap(corr, mask=mask, vmax=.3, square=True) Update time： 2020-05-23 "},"Chapter7/seaborn.FacetGrid.html":{"url":"Chapter7/seaborn.FacetGrid.html","title":"seaborn.FacetGrid","keywords":"","body":"seaborn.FacetGrid class seaborn.FacetGrid(data, row=None, col=None, hue=None, col_wrap=None, sharex=True, sharey=True, height=3, aspect=1, palette=None, row_order=None, col_order=None, hue_order=None, hue_kws=None, dropna=True, legend_out=True, despine=True, margin_titles=False, xlim=None, ylim=None, subplot_kws=None, gridspec_kws=None, size=None) 用于绘制条件关系的多图网格。 __init__(data, row=None, col=None, hue=None, col_wrap=None, sharex=True, sharey=True, height=3, aspect=1, palette=None, row_order=None, col_order=None, hue_order=None, hue_kws=None, dropna=True, legend_out=True, despine=True, margin_titles=False, xlim=None, ylim=None, subplot_kws=None, gridspec_kws=None, size=None) 初始化 matplotlib 画布和 FacetGrid 对象。 该类将数据集映射到由行和列组成的网格中的多个轴上，这些轴与数据集中变量的级别对应。它产生的图通常被称为“lattice”，“trellis”或“small-multiple”图形。 它还可以用hue参数表示第三个变量的级别，该参数绘制不同颜色的不同数据子集。它使用颜色来解析第三维度上的元素，但是只绘制相互重叠的子集，并且不会像接受“hue”的坐标轴级函数那样为特定的可视化定制“hue”参数。 当使用从数据集推断语义映射的 seaborn 函数时，必须注意在各个方面之间同步这些映射。在大多数情况下，使用图形级函数（例如relplot()或catplot()）比直接使用FacetGrid更好。 基本工作流程是使用数据集和用于构造网格的变量初始化 FacetGrid 对象。然后，通过调用FacetGrid.map()或FacetGrid.map_dataframe()，可以将一个或多个绘图函数应用于每个子集。最后，可以使用其他方法调整绘图，以执行更改轴标签、使用不同刻度或添加图例等操作。有关详细信息，请参阅下面的详细代码示例。 更多相关信息请参阅教程。 参数：data：DataFrame 数据。 整洁的（“长形式”）dataframe 数据，其中每一列是一个变量，每一行是一个观察实例。 row, col, hue：字符串。 定义数据子集的变量，这些变量将在网格的不同方面绘制。请参阅*_order参数以控制此变量的级别顺序。 col_wrap：整形数值，可选参数。 以此参数值来限制网格的列维度，以便列面跨越多行。与row面不兼容。 share{x,y}：布尔值，'col' 或 'row'可选 如果为 true，则跨列共享 y 轴或者跨行共享 x 轴。 height：标量，可选参数。 每个图片的高度设定（以英寸为单位）。另见：aspect aspect：标量，可选参数。 每个图片的纵横比，因此 aspect * height 给出每个图片的宽度，单位为英寸。 palette：调色板名称，列表或字典，可选参数。 用于色调变量的不同级别的颜色。应为color_palette()可以解释的参数，或者是将色调级别映射到 matplotlib 颜色的字典。 {row,col,hue}_order：列表，可选参数。 对所给命令级别进行排序。默认情况下，这将是在数据中显示的级别，或者，如果变量是 pandas 分类，则为类别顺序。 hue_kws：参数-列表值的映射字典 插入到绘图调用中的其他关键字参数，使得其他绘图属性在色调变量的级别上有所不同（例如散点图中的标记）。 legend_out：布尔值，可选参数。 如果为 True，则图形尺寸将被扩展，图例将绘制在中间右侧的图形之外。 despine：布尔值，可选参数。 从图中移除顶部和右侧边缘框架。 margin_titles：布尔值，可选参数。 如果为 True，则行变量的标题将绘制在最后一列的右侧。此选项是实验性的，可能无法在所有情况下使用。 {x, y}lim：元组，可选参数。 每个图片上每个轴的限制（仅当 share {x，y}为 True 时才相关）。 subplot_kws：字典，可选参数。 传递给 matplotlib subplot（s）方法的关键字参数字典。 gridspec_kws：字典，可选参数。 传递给 matplotlib 的gridspec模块（通过plt.subplots）的关键字参数字典。需要 matplotlib> = 1.4，如果col_wrap不是None，则忽略它。 另请参见 用于绘制成对关系的子图网格。 relplot 结合关系图和FacetGrid。 catplot 结合分类图和FacetGrid。 lmplot 结合回归图和FacetGrid。 范例 使用 tips 数据集初始化 2x2 网格图： >>> import seaborn as sns; sns.set(style=\"ticks\", color_codes=True) >>> tips = sns.load_dataset(\"tips\") >>> g = sns.FacetGrid(tips, col=\"time\", row=\"smoker\") 在每个子图绘制一个单变量图： >>> import matplotlib.pyplot as plt >>> g = sns.FacetGrid(tips, col=\"time\", row=\"smoker\") >>> g = g.map(plt.hist, \"total_bill\") （注意，没有必要重新捕获返回的变量;它是相同的对象，但在示例中这样做使得处理 doctests 更加方便）。 将其他关键字参数传递给映射函数： >>> import numpy as np >>> bins = np.arange(0, 65, 5) >>> g = sns.FacetGrid(tips, col=\"time\", row=\"smoker\") >>> g = g.map(plt.hist, \"total_bill\", bins=bins, color=\"r\") 在每个子图绘制一个双变量函数： >>> g = sns.FacetGrid(tips, col=\"time\", row=\"smoker\") >>> g = g.map(plt.scatter, \"total_bill\", \"tip\", edgecolor=\"w\") 将其中一个变量分配给绘图元素的颜色： >>> g = sns.FacetGrid(tips, col=\"time\", hue=\"smoker\") >>> g = (g.map(plt.scatter, \"total_bill\", \"tip\", edgecolor=\"w\") ... .add_legend()) 更改每个子图的高度和纵横比： >>> g = sns.FacetGrid(tips, col=\"day\", height=4, aspect=.5) >>> g = g.map(plt.hist, \"total_bill\", bins=bins) https://raw.githubusercontent.com/HG1227/image/master/img_tuchuang/20200512101819.jpg\" 指定绘图元素的顺序： >>> g = sns.FacetGrid(tips, col=\"smoker\", col_order=[\"Yes\", \"No\"]) >>> g = g.map(plt.hist, \"total_bill\", bins=bins, color=\"m\") 使用不同的调色板： >>> kws = dict(s=50, linewidth=.5, edgecolor=\"w\") >>> g = sns.FacetGrid(tips, col=\"sex\", hue=\"time\", palette=\"Set1\", ... hue_order=[\"Dinner\", \"Lunch\"]) >>> g = (g.map(plt.scatter, \"total_bill\", \"tip\", **kws) ... .add_legend()) 使用字典将色调级别映射到颜色： >>> pal = dict(Lunch=\"seagreen\", Dinner=\"gray\") >>> g = sns.FacetGrid(tips, col=\"sex\", hue=\"time\", palette=pal, ... hue_order=[\"Dinner\", \"Lunch\"]) >>> g = (g.map(plt.scatter, \"total_bill\", \"tip\", **kws) ... .add_legend()) 另外，为色调级别使用不同的标记： >>> g = sns.FacetGrid(tips, col=\"sex\", hue=\"time\", palette=pal, ... hue_order=[\"Dinner\", \"Lunch\"], ... hue_kws=dict(marker=[\"^\", \"v\"])) >>> g = (g.map(plt.scatter, \"total_bill\", \"tip\", **kws) ... .add_legend()) 将包含多个级别的列变量“换行”到行中： >>> att = sns.load_dataset(\"attention\") >>> g = sns.FacetGrid(att, col=\"subject\", col_wrap=5, height=1.5) >>> g = g.map(plt.plot, \"solutions\", \"score\", marker=\".\") 定义一个自定义双变量函数来映射到网格： >>> from scipy import stats >>> def qqplot(x, y, **kwargs): ... _, xr = stats.probplot(x, fit=False) ... _, yr = stats.probplot(y, fit=False) ... plt.scatter(xr, yr, **kwargs) >>> g = sns.FacetGrid(tips, col=\"smoker\", hue=\"sex\") >>> g = (g.map(qqplot, \"total_bill\", \"tip\", **kws) ... .add_legend()) 定义一个使用DataFrame对象的自定义函数，并接受列名作为位置变量： >>> import pandas as pd >>> df = pd.DataFrame( ... data=np.random.randn(90, 4), ... columns=pd.Series(list(\"ABCD\"), name=\"walk\"), ... index=pd.date_range(\"2015-01-01\", \"2015-03-31\", ... name=\"date\")) >>> df = df.cumsum(axis=0).stack().reset_index(name=\"val\") >>> def dateplot(x, y, **kwargs): ... ax = plt.gca() ... data = kwargs.pop(\"data\") ... data.plot(x=x, y=y, ax=ax, grid=False, **kwargs) >>> g = sns.FacetGrid(df, col=\"walk\", col_wrap=2, height=3.5) >>> g = g.map_dataframe(dateplot, \"date\", \"val\") 绘图后使用不同的轴标签： >>> g = sns.FacetGrid(tips, col=\"smoker\", row=\"sex\") >>> g = (g.map(plt.scatter, \"total_bill\", \"tip\", color=\"g\", **kws) ... .set_axis_labels(\"Total bill (US Dollars)\", \"Tip\")) 设置每个子图共享的其他属性： >>> g = sns.FacetGrid(tips, col=\"smoker\", row=\"sex\") >>> g = (g.map(plt.scatter, \"total_bill\", \"tip\", color=\"r\", **kws) ... .set(xlim=(0, 60), ylim=(0, 12), ... xticks=[10, 30, 50], yticks=[2, 6, 10])) 为子图标题使用不同的模板： >>> g = sns.FacetGrid(tips, col=\"size\", col_wrap=3) >>> g = (g.map(plt.hist, \"tip\", bins=np.arange(0, 13), color=\"c\") ... .set_titles(\"{col_name} diners\")) 收紧每个子图: >>> g = sns.FacetGrid(tips, col=\"smoker\", row=\"sex\", ... margin_titles=True) >>> g = (g.map(plt.scatter, \"total_bill\", \"tip\", color=\"m\", **kws) ... .set(xlim=(0, 60), ylim=(0, 12), ... xticks=[10, 30, 50], yticks=[2, 6, 10]) ... .fig.subplots_adjust(wspace=.05, hspace=.05)) 方法 | __init__(data[, row, col, hue, col_wrap, …]) | 初始化 matplotlib 画布和 FacetGrid 对象。 | | add_legend([legend_data, title, label_order]) | 绘制一个图例，可能将其放在轴外并调整图形大小。| | despine(**kwargs) | 从子图中移除轴的边缘框架。 | | facet_axis(row_i, col_j) | 使这些索引识别的轴处于活动状态并返回。 | | facet_data() | 用于每个子图的名称索引和数据子集的生成器。 | | map(func, args, *kwargs) | 将绘图功能应用于每个子图的数据子集。 | | map_dataframe(func, args, *kwargs) | 像.map一样，但是将 args 作为字符串传递并在 kwargs 中插入数据。 | | savefig(args, *kwargs) | 保存图片。 | | set(**kwargs) | 在每个子图集坐标轴上设置属性。| | set_axis_labels([x_var, y_var]) | 在网格的左列和底行设置轴标签。 | | set_titles([template, row_template, …]) | 在每个子图上方或网格边缘绘制标题。 | | set_xlabels([label]) | 在网格的底行标记 x 轴。 | | set_xticklabels([labels, step]) | 在网格的底行设置 x 轴刻度标签。 | | set_ylabels([label]) | 在网格的左列标记 y 轴。 | | set_yticklabels([labels]) | 在网格的左列上设置 y 轴刻度标签。 | 属性 | ax | 轻松访问单个坐标轴。 | Update time： 2020-05-23 "},"Chapter7/seaborn.PairGrid.html":{"url":"Chapter7/seaborn.PairGrid.html","title":"seaborn.PairGrid","keywords":"","body":"seaborn.PairGrid class seaborn.PairGrid(data, hue=None, hue_order=None, palette=None, hue_kws=None, vars=None, x_vars=None, y_vars=None, diag_sharey=True, height=2.5, aspect=1, despine=True, dropna=True, size=None) 用于绘制数据集中成对关系的子图网格。 此类将数据集中的每个变量映射到多个轴的网格中的列和行。可以使用不同的轴级绘图函数来绘制上三角和下三角的双变量图，并且对角线上可以显示每个变量的边际分布。 它还可以通过hue参数用不同颜色绘制不同的数据子集来表示附加级别的条件化。这使用颜色来解析第三维的元素，但只是在彼此之上绘制子集，并且不会像接受hue的轴级函数那样为特定可视化定制hue参数。 参考教程获取更多信息。 __init__(data, hue=None, hue_order=None, palette=None, hue_kws=None, vars=None, x_vars=None, y_vars=None, diag_sharey=True, height=2.5, aspect=1, despine=True, dropna=True, size=None) 初始化绘图和 PairGrid 对象。 参数：data：DataFrame 格式 整洁（长形式）数据框，其中每列是一个变量，每行是一个观察。 hue：字符串 （变量名）, 可选 data中的变量，将绘图的不同面映射为不同的颜色。 hue_order：字符串列表 调色板中色调变量的等级顺序 palette：字典或者 seaborn 调色板 用于映射hue变量的颜色集.如果是一个字典，键应为hue变量中的值。 hue_kws：参数字典 -> 值列表映射 其它的关键字参数，通过插入到绘图调用中使得其它的绘图属性在色调变量的不同水平上变化（例如散点图中的标记）。 vars：变量名列表, 可选 使用data中的变量，否则使用一个数值型数据类型的每一列。 {x, y}_vars：变量名列表，可选 将data中的变量分别用于图的行和列，即制作非方形图。 height：标量，可选 每个刻面的高度（以英寸为单位）。 aspect：标量，可选 aspect 和 height 的乘积得出每个刻面的宽度（以英寸为单位）。 despine：布尔值，可选 从图中移除顶部和右侧脊柱。 dropna：布尔值，可选 在绘图之前删除数据中的缺失值。 另见 轻松绘制PairGrid的常用用法。用于绘制条件关系的子图网格。 例子 为每个成对关系绘制一个散点图： >>> import matplotlib.pyplot as plt >>> import seaborn as sns; sns.set() >>> iris = sns.load_dataset(\"iris\") >>> g = sns.PairGrid(iris) >>> g = g.map(plt.scatter) 在对角线上显示单变量分布： >>> g = sns.PairGrid(iris) >>> g = g.map_diag(plt.hist) >>> g = g.map_offdiag(plt.scatter) (实际上没有必要每次都获取返回值，因为它是同一个对象，但它使得更容易处理文档测试)。 使用分类变量对点进行着色： >>> g = sns.PairGrid(iris, hue=\"species\") >>> g = g.map_diag(plt.hist) >>> g = g.map_offdiag(plt.scatter) >>> g = g.add_legend() 使用不同的样式显示多个直方图： >>> g = sns.PairGrid(iris, hue=\"species\") >>> g = g.map_diag(plt.hist, histtype=\"step\", linewidth=3) >>> g = g.map_offdiag(plt.scatter) >>> g = g.add_legend() 绘制变量的子集 >>> g = sns.PairGrid(iris, vars=[\"sepal_length\", \"sepal_width\"]) >>> g = g.map(plt.scatter) 将其它关键字参数传给函数。 >>> g = sns.PairGrid(iris) >>> g = g.map_diag(plt.hist, edgecolor=\"w\") >>> g = g.map_offdiag(plt.scatter, edgecolor=\"w\", s=40) 对行和列使用不同的变量： >>> g = sns.PairGrid(iris, ... x_vars=[\"sepal_length\", \"sepal_width\"], ... y_vars=[\"petal_length\", \"petal_width\"]) >>> g = g.map(plt.scatter) 在上三角和下三角使用不同的函数： >>> g = sns.PairGrid(iris) >>> g = g.map_upper(plt.scatter) >>> g = g.map_lower(sns.kdeplot, cmap=\"Blues_d\") >>> g = g.map_diag(sns.kdeplot, lw=3, legend=False) 为每个分类级别使用不同的颜色和标记： >>> g = sns.PairGrid(iris, hue=\"species\", palette=\"Set2\", ... hue_kws={\"marker\": [\"o\", \"s\", \"D\"]}) >>> g = g.map(plt.scatter, linewidths=1, edgecolor=\"w\", s=40) >>> g = g.add_legend() 方法 | __init__(data[, hue, hue_order, palette, …]) | 初始化绘图和 PairGrid 对象。 | | add_legend([legend_data, title, label_order]) | 绘制一个图例，可能将其放在轴外并调整图形大小。 | | map(func, kwargs) | 在每一个子图上用相同的函数绘制。 | | map_diag(func, kwargs) | 在每个对角线子图上用一个单变量函数绘制。 | | map_lower(func, kwargs) | 在下三角子图上用一个双变量函数绘制。| | map_offdiag(func, kwargs) | 在非对角线子图上用一个双变量函数绘制。 | | map_upper(func, kwargs) | 在上三角子图上用一个双变量函数绘制。| | savefig(*args, kwargs) | 保存图。 | | set(**kwargs) | 在每个子图轴上设置属性。 | Update time： 2020-05-23 "},"Chapter7/seaborn.JointGrid.html":{"url":"Chapter7/seaborn.JointGrid.html","title":"seaborn.JointGrid","keywords":"","body":"seaborn.JointGrid class seaborn.JointGrid(x, y, data=None, height=6, ratio=5, space=0.2, dropna=True, xlim=None, ylim=None, size=None) 用于绘制具有边际单变量图的双变量图的网格。 __init__(x, y, data=None, height=6, ratio=5, space=0.2, dropna=True, xlim=None, ylim=None, size=None) 设置子图的网格。 参数：x, y：字符串或向量 在 data中的数据或变量名 data：DataFrame, 可选 当 x and y 是变量名的时候为 DataFrame。 height：数字 图中每一条边的大小（以英寸为单位） ratio：数字 联合轴大小与边缘轴高度的比率。 space：数字，可选 联合轴和边缘轴之间的空间 dropna：bool, 可选 如果为 True，则删除 x 和 y中缺少的观察结果。 {x, y}lim：二元组，可选 在绘图之前设置轴限制。 也可以看看 用于绘制具有多种不同默认绘图类型的双变量图的高级界面。 例子： 初始化图形，但不在其上绘制任何图形： >>> import seaborn as sns; sns.set(style=\"ticks\", color_codes=True) >>> tips = sns.load_dataset(\"tips\") >>> g = sns.JointGrid(x=\"total_bill\", y=\"tip\", data=tips) 使用默认参数添加绘图： >>> g = sns.JointGrid(x=\"total_bill\", y=\"tip\", data=tips) >>> g = g.plot(sns.regplot, sns.distplot) 分别绘制联合分布图和边缘直方图，这可以以更精细的级别控制其他参数： >>> import matplotlib.pyplot as plt >>> g = sns.JointGrid(x=\"total_bill\", y=\"tip\", data=tips) >>> g = g.plot_joint(plt.scatter, color=\".5\", edgecolor=\"white\") >>> g = g.plot_marginals(sns.distplot, kde=False, color=\".5\") 分别绘制两个边缘直方图： >>> import numpy as np >>> g = sns.JointGrid(x=\"total_bill\", y=\"tip\", data=tips) >>> g = g.plot_joint(plt.scatter, color=\"m\", edgecolor=\"white\") >>> _ = g.ax_marg_x.hist(tips[\"total_bill\"], color=\"b\", alpha=.6, ... bins=np.arange(0, 60, 5)) >>> _ = g.ax_marg_y.hist(tips[\"tip\"], color=\"r\", alpha=.6, ... orientation=\"horizontal\", ... bins=np.arange(0, 12, 1)) 添加注释，其中包含总结双变量关系的统计信息： >>> from scipy import stats >>> g = sns.JointGrid(x=\"total_bill\", y=\"tip\", data=tips) >>> g = g.plot_joint(plt.scatter, ... color=\"g\", s=40, edgecolor=\"white\") >>> g = g.plot_marginals(sns.distplot, kde=False, color=\"g\") >>> g = g.annotate(stats.pearsonr) 使用自定义的函数和注释格式 >>> g = sns.JointGrid(x=\"total_bill\", y=\"tip\", data=tips) >>> g = g.plot_joint(plt.scatter, ... color=\"g\", s=40, edgecolor=\"white\") >>> g = g.plot_marginals(sns.distplot, kde=False, color=\"g\") >>> rsquare = lambda a, b: stats.pearsonr(a, b)[0] ** 2 >>> g = g.annotate(rsquare, template=\"{stat}: {val:.2f}\", ... stat=\"$R^2$\", loc=\"upper left\", fontsize=12) 移除联合轴和边缘轴之间的空间： >>> g = sns.JointGrid(x=\"total_bill\", y=\"tip\", data=tips, space=0) >>> g = g.plot_joint(sns.kdeplot, cmap=\"Blues_d\") >>> g = g.plot_marginals(sns.kdeplot, shade=True) 绘制具有相对较大边缘轴的较小图： >>> g = sns.JointGrid(x=\"total_bill\", y=\"tip\", data=tips, ... height=5, ratio=2) >>> g = g.plot_joint(sns.kdeplot, cmap=\"Reds_d\") >>> g = g.plot_marginals(sns.kdeplot, color=\"r\", shade=True) 设置轴的限制： >>> g = sns.JointGrid(x=\"total_bill\", y=\"tip\", data=tips, ... xlim=(0, 50), ylim=(0, 8)) >>> g = g.plot_joint(sns.kdeplot, cmap=\"Purples_d\") >>> g = g.plot_marginals(sns.kdeplot, color=\"m\", shade=True) 方法 __init__(x, y[, data, height, ratio, space, …]) | 设置子图的网格设置子图的网格。 annotate(func[, template, stat, loc]) | 用关于关系的统计数据来标注绘图。 plot(joint_func, marginal_func[, annot_func]) | 绘制完整绘图的快捷方式。 plot_joint(func, **kwargs) | 绘制 x 和 y的双变量图。 plot_marginals(func, **kwargs) | 分别绘制 x 和 y 的单变量图。 savefig(args, *kwargs) | 封装 figure.savefig 默认为紧边界框。 set_axis_labels([xlabel, ylabel]) |在双变量轴上设置轴标签。 Update time： 2020-05-23 "},"Chapter7/seaborn.set.html":{"url":"Chapter7/seaborn.set.html","title":"seaborn.set","keywords":"","body":"seaborn.set seaborn.set(context='notebook', style='darkgrid', palette='deep', font='sans-serif', font_scale=1, color_codes=True, rc=None) 一步设定自定义图表参数。 每个参数可以被直接或者间接设定，参见下方的引用参数以获取更多信息。 参数：context：字符串或者字典 绘图上下文参数，参见plotting_context() style：字符串或者字典 坐标轴样式参数，参见axes_style() palette：字符串或者序列 调色板，参见color_palette() font：字符串 字体，参见 matplotlib 字体管理 font_scale：浮点数，可选的 独立缩放因子，以独立缩放字体元素的大小。 color_codes：布尔值 如果为真并且调色板是一个 seaborn 调色板，重新映射速记颜色代码（比如，\"b\"，\"g\"，\"r\"，等等）到调色板上的颜色。 rc：字典或者 None rc 参数字典映射以覆盖以上参数。 Update time： 2020-05-23 "},"Chapter7/seaborn.axes_style.html":{"url":"Chapter7/seaborn.axes_style.html","title":"seaborn.axes_style","keywords":"","body":"seaborn.axes_style seaborn.axes_style(style=None,rc=None) 返回一个参数数组作为图表的自定义风格。 它会影响诸如坐标轴的颜色，是否默认启用网格，和其他自定义元素。 这个函数返回一个对象，该对象可以在 with 语句中使用以临时改变样式参数。 参数：style：字典,None,或者{darkgrid, whitegrid, dark, white, ticks}其中一个。 一个参数字典或者一个预配置集的名称。 rc：字典，可选的 给定参数映射以覆盖预先设定的（默认的）seaborn 样式参数字典 参见 给一个 seaborn 主题设定 matplotlib 参数，返回一个参数字典，以缩放图标元素并可以定义图表的调色板。 例子： >>> st = axes_style(\"whitegrid\") >>> set_style(\"ticks\", {\"xtick.major.size\": 8, \"ytick.major.size\": 8}) >>> import matplotlib.pyplot as plt >>> with axes_style(\"white\"): ... f, ax = plt.subplots() ... ax.plot(x, y) Update time： 2020-05-23 "},"Chapter7/seaborn.set_style.html":{"url":"Chapter7/seaborn.set_style.html","title":"seaborn.set_style","keywords":"","body":"seaborn.set_style seaborn.set_style(style=None, rc=None) 设定图表的自定义风格。 它会影响诸如坐标轴的颜色，网格默认是否开启和其他自定义元素。 参数：style：字典,None,或者{darkgrid, whitegrid, dark, white, ticks}其中一个。 一个参数字典或者一个预配置集的名称。 rc：字典，可选 一个字典映射去覆盖 seaborn 样式字典中的预设值。这仅仅会更新那些被认为是样式定义一部分的参数。 参见 返回一个参数字典或者使用 with 语句以临时设置 style.set 的参数来缩放图表的元素或者设定图表的默认调色板。 例子： >>> set_style(\"whitegrid\") >>> set_style(\"ticks\", {\"xtick.major.size\": 8, \"ytick.major.size\": 8}) Update time： 2020-05-23 "},"Chapter7/seaborn.plotting_context.html":{"url":"Chapter7/seaborn.plotting_context.html","title":"seaborn.plotting_context","keywords":"","body":"seaborn.plotting_context seaborn.plotting_context(context=None, font_scale=1, rc=None) 以 dict 形式返回参数，用以缩放图形的元素。 这些参数可以影响诸如标签大小，线条和绘图的其他元素，但不会影响整体样式。基础文本时\"notebook\"，和其他文本\"paper\"，\"talk\"和\"poster\"，它们分别是 0.8，1.3 和 1.6 的 notebook 参数版本。 该函数返回一个对象，该对象可以在with语句中使用，临时改变文本参数。 参数：context：dict, None 或者是{paper, notebook, talk, poster}其中一个 参数集或者是预设集合的名字 font_scale：浮点数，可选 单独的缩放因子可以独立缩放字体元素大小 rc：dict，可选 参数映射以覆盖预设的 seaborn 的文本字典中的值。这只更新被视为文本定义的一部分的参数。 也可参见 设置 matplotlib 参数以调整绘图元素返回定义图形样式的参数的 dict，定义绘图的调色板。 示例： >>> c = plotting_context(\"poster\") >>> c = plotting_context(\"notebook\", font_scale=1.5) >>> c = plotting_context(\"talk\", rc={\"lines.linewidth\": 2}) >>> import matplotlib.pyplot as plt >>> with plotting_context(\"paper\"): ... f, ax = plt.subplots() ... ax.plot(x, y) Update time： 2020-05-23 "},"Chapter7/seaborn.set_context.html":{"url":"Chapter7/seaborn.set_context.html","title":"seaborn.set_context","keywords":"","body":"seaborn.set_context seaborn.set_context(context=None, font_scale=1, rc=None) 设置绘图文本参数。 这些参数可以影响诸如标签大小，线条和绘图的其他元素，但不会影响整体样式。基础文本时\"notebook\"，和其他文本\"paper\"，\"talk\"和\"poster\"，它们分别是 0.8，1.3 和 1.6 的 notebook 参数版本。 参数：context：dict, None 或者是{paper, notebook, talk, poster}其中一个 参数集或者是预设集合的名字 font_scale：浮点数，可选 单独的缩放因子可以独立缩放字体元素大小 rc：dict，可选 参数映射以覆盖预设的 seaborn 的上下文字典中的值。这只更新被视为上下文定义的一部分的参数。 也可参见 返回一个 rc 参数的字典，或者在with语句中使用临时设置 context.set 图样式的默认为数字的默认调色板 示例 >>> set_context(\"paper\") >>> set_context(\"talk\", font_scale=1.4) >>> set_context(\"talk\", rc={\"lines.linewidth\": 2}) Update time： 2020-05-23 "},"Chapter7/seaborn.set_color_codes.html":{"url":"Chapter7/seaborn.set_color_codes.html","title":"seaborn.set_color_codes","keywords":"","body":"seaborn.set_color_codes seaborn.set_color_codes(palette='deep') 改变 matplotlib 颜色缩写词的解释方式。 调用此方法将改变 matplotlib 在后续图表中解释缩写词，例如\"b\"或\"g\"的方式。 参数： palette: {deep, muted, pastel, dark, bright, colorblind} 预命名的 seaborn 调色板，用作颜色的来源 参见 可以通过高级 seaborn 样式管理器设置颜色代码。也可以通过设置 matplotlib 颜色循环功能设置颜色代码。 示例： 将 matplotlib 颜色代码映射到默认的 seaborn 调色板。 >>> import matplotlib.pyplot as plt >>> import seaborn as sns; sns.set() >>> sns.set_color_codes() >>> _ = plt.plot([0, 1], color=\"r\") 使用不同的 seaborn 调色板 >>> sns.set_color_codes(\"dark\") >>> _ = plt.plot([0, 1], color=\"g\") >>> _ = plt.plot([0, 2], color=\"m\") Update time： 2020-05-23 "},"Chapter7/seaborn.set_palette.html":{"url":"Chapter7/seaborn.set_palette.html","title":"seaborn.set_palette","keywords":"","body":"seaborn.set_palette seaborn.set_palette(palette, n_colors=None, desat=None, color_codes=False) 通过 searborn 调色板设置 matplotlib 色彩循环 参数：palette：seaborn color paltte | matplotlib colormap | hls | husl 调色板参数。 应该可以被 color_palette() 函数处理。 n_colors：int 色彩循环中的颜色数量。默认数量与palette模式有关, 查看color_palette()文档了解更多内容。 desat：float 每种颜色去饱和的比例。 color_codes：bool 如果为True，并且palette是 seaborn 调色板, 则将颜色代码简写 (例如“b”, “g”, “r”等等)映射到当前调色板上。 另外 在with语句中临时设置调色板或色彩循环。设置参数以调整绘图元素的默认参数。 例子 >>> set_palette(\"Reds\") >>> set_palette(\"Set1\", 8, .75) Update time： 2020-05-23 "},"Chapter7/seaborn.color_palette.html":{"url":"Chapter7/seaborn.color_palette.html","title":"seaborn.color_palette","keywords":"","body":"seaborn.color_palette 译者：Modrisco seaborn.color_palette(palette=None, n_colors=None, desat=None) 返回一个颜色列表来定义一个调色板。 Available seaborn palette names: 有 deep, muted, bright, pastel, dark, colorblind 六种颜色模式 Other options: matplotlib Colormap 的名字、‘ch:’, ‘hls’, ‘husl’，或任一 matplotlib 接受的不同格式颜色列表。 调用此函数并设置 palette=None 会返回当前 matplotlib 色彩循环。 matplotlib 调色板的顺序可以通过在调色板名称后添加 “_r” 来倒置，同样，添加 “_d” 可以将调色板设置为深色模式。（这些选项为互斥属性，返回的颜色列表同样可以被取反） 可以在 with 语句中使用此函数来为一个或多个点临时改变调色板。 参考这篇 教程 来获取更多信息。 参数：palette：None, string, or sequence, optional 调色板或者 None 值来返回给当前调色板。如果是序列，输入颜色会被使用，可能会被循环化并降低饱和度。 n_colors：int, 可选 调色板中的颜色数。如果为 None，则默认值将取决于调色板的指定方式。已命名调色板默认有 6 种颜色，抓取当前调色板或传递颜色列表不会更改颜色数，除非作出指定。要求比调色板中存在的颜色更多的颜色会导致调色板循环化。 desat：float, 可选 每种颜色的去饱和比例。 返回值：palette：RGB 元组序列。 调色板。操作类似于列表，但可以用作上下文管理器，并具有转换为十六进制颜色代码的 as_hex 方法。 另外 设置所有的默认颜色循环。重新分配颜色代码，如 “b”、“g” 等。从 seaborn 调色板中选择颜色。 例子 不带参数的调用将返回当前默认颜色循环中的所有颜色： >>> import seaborn as sns; sns.set() >>> sns.palplot(sns.color_palette()) 显示另一个 “seaborn 调色板”，具有与默认 matplotlib 颜色循环相同的基本色调顺序，但颜色更吸引人。默认情况下，使用调色板名称进行调用将返回 6 种颜色： >>> sns.palplot(sns.color_palette(\"muted\")) 使用一个内置 matplotlib clolormap 的离散值： >>> sns.palplot(sns.color_palette(\"RdBu\", n_colors=7)) 创建自定义 cubehelix 调色板： >>> sns.palplot(sns.color_palette(\"ch:2.5,-.2,dark=.3\")) 使用一个明确的 matplotlib 调色板并降低一些饱和度： >>> sns.palplot(sns.color_palette(\"Set1\", n_colors=8, desat=.5)) 创建 “dark”（深色）matplotlib 顺序调色板变体。(当对应于有序变量的多条线或点进行着色时，如果您不希望最轻的线不可见，则可以使用此选项)： >>> sns.palplot(sns.color_palette(\"Blues_d\")) 作为上下文管理器使用： >>> import numpy as np, matplotlib.pyplot as plt >>> with sns.color_palette(\"husl\", 8): ... _ = plt.plot(np.c_[np.zeros(8), np.arange(8)].T) Update time： 2020-05-23 "},"Chapter7/seaborn.husl_palette.html":{"url":"Chapter7/seaborn.husl_palette.html","title":"seaborn.husl_palette","keywords":"","body":"seaborn.husl_palette seaborn.husl_palette(n_colors=6, h=0.01, s=0.9, l=0.65) 在 HUSL 色调空间中获得一组均匀间隔的颜色。 h, s, 和 l 值应该在 0 和 1 之间。 参数：n_colors：int 调色板中的颜色数 h：float 第一个色调 s：float 饱和度 l：float 亮度 返回值：palette：seaborn 调色板 类似列表的颜色对象的 RGB 元组。 另外 在 HSL 系统中使用等间距圆形色调创建一个调色板。 例子 使用默认参数创建一个有 10 种颜色的调色板： >>> import seaborn as sns; sns.set() >>> sns.palplot(sns.husl_palette(10)) 创建一个以不同色调值开头的 10 种颜色的调色板： >>> sns.palplot(sns.husl_palette(10, h=.5)) 创建一个比默认颜色更暗的 10 种颜色的调色板： >>> sns.palplot(sns.husl_palette(10, l=.4)) 创建 10 种颜色的调色板，其饱和度低于默认值： >>> sns.palplot(sns.husl_palette(10, s=.4)) Update time： 2020-05-23 "},"Chapter7/seaborn.hls_palette.html":{"url":"Chapter7/seaborn.hls_palette.html","title":"seaborn.hls_palette","keywords":"","body":"seaborn.hls_palette seaborn.hls_palette(n_colors=6, h=0.01, l=0.6, s=0.65) 在 HLS 色调空间中获取一组均匀间隔的颜色。 h, s, 和 l 值应该在 0 和 1 之间。 参数：n_colors：int 调色板中的颜色数 h：float 第一个色调 l：float 亮度 s：float 饱和度 返回值：palette：seaborn 调色板 类似列表的颜色对象的 RGB 元组。 另外 在 HUSL 系统中使用等间距圆形色调创建一个调色板。 例子 使用默认参数创建一个有 10 种颜色的调色板： >>> import seaborn as sns; sns.set() >>> sns.palplot(sns.hls_palette(10)) 创建一个以不同色调值开头的 10 种颜色的调色板： >>> sns.palplot(sns.hls_palette(10, h=.5)) 创建一个比默认颜色更暗的 10 种颜色的调色板： >>> sns.palplot(sns.hls_palette(10, l=.4)) 创建 10 种颜色的调色板，其饱和度低于默认值： >>> sns.palplot(sns.hls_palette(10, s=.4)) Update time： 2020-05-23 "},"Chapter7/seaborn.cubehelix_palette.html":{"url":"Chapter7/seaborn.cubehelix_palette.html","title":"seaborn.cubehelix_palette","keywords":"","body":"seaborn.cubehelix_palette seaborn.cubehelix_palette(n_colors=6, start=0, rot=0.4, gamma=1.0, hue=0.8, light=0.85, dark=0.15, reverse=False, as_cmap=False) 用 cubehelix 系统制作顺序调色板。 生成亮度呈线性减小(或增大)的 colormap。这意味着 colormap 在转换为黑白模式时(用于打印)的信息将得到保留，且对色盲友好。“cubehelix” 也可以作为基于 matplotlib 的调色板使用，但此函数使用户可以更好地控制调色板的外观，并且具有一组不同的默认值。 除了使用这个函数，还可以在 seaborn 中使用字符串速记生成 cubehelix 调色板。 请参见下面的示例。 参数：n_colors：int 调色板中的颜色数。 start：float, 0 第一个色调。 rot：float 围绕调色板范围内的色相控制盘旋转。 gamma：float 0 Gamma 系数用以强调较深 (Gamma 1) 的颜色。 hue：float, 0 颜色的饱和度。 dark：float 0 调色板中最暗颜色的强度。 light：float 0 调色板中最浅颜色的强度。 reverse：bool 如果为 True 值，则调色板将从暗到亮。 as_cmap：bool 如果为 True 值，则返回 matplotlib colormap 而不是颜色列表。 返回值：palette or cmap：seaborn 调色板或者 matplotlib colormap 类似列表的颜色对象的 RGB 元组，或者可以将连续值映射到颜色的 colormap 对象，具体取决于 as_cmap 参数的值。 另外 启动交互式小部件以调整 cubehelix 调色板参数。创建具有暗低值的连续调色板。创建具有亮低值的连续调色板。 参考 Green, D. A. (2011). “一种用于显示天文强度图像的配色方案”. Bulletin of the Astromical Society of India, Vol. 39, p. 289-295. 例子 生成默认调色板： >>> import seaborn as sns; sns.set() >>> sns.palplot(sns.cubehelix_palette()) 从相同的起始位置向后旋转： >>> sns.palplot(sns.cubehelix_palette(rot=-.4)) 使用不同的起点和较短的旋转： >>> sns.palplot(sns.cubehelix_palette(start=2.8, rot=.1)) 反转亮度渐变方向： >>> sns.palplot(sns.cubehelix_palette(reverse=True)) 生成一个 colormap 对象： >>> from numpy import arange >>> x = arange(25).reshape(5, 5) >>> cmap = sns.cubehelix_palette(as_cmap=True) >>> ax = sns.heatmap(x, cmap=cmap) 使用完整的亮度范围： >>> cmap = sns.cubehelix_palette(dark=0, light=1, as_cmap=True) >>> ax = sns.heatmap(x, cmap=cmap) 使用 color_palette() 函数接口： >>> sns.palplot(sns.color_palette(\"ch:2,r=.2,l=.6\")) Update time： 2020-05-23 "},"Chapter7/seaborn.dark_palette.html":{"url":"Chapter7/seaborn.dark_palette.html","title":"seaborn.dark_palette","keywords":"","body":"seaborn.dark_palette seaborn.dark_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb') 制作一个混合深色和 color 模式的顺序调色板。 这种调色板适用于数据集的范围从相对低值(不感兴趣)到相对高值(很感兴趣)时。 可以通过多种方式指定 color 参数，包括用于在 matplotlib 中定义颜色的所有选项，以及由 seborn 处理的其他几个颜色空间。也可以使用 XKCD color survey 中的颜色名字数据库。 如果您在使用 IPython notebook，您还可以通过 choose_dark_palette() 函数交互式选择调色板。 参数：color：高值的基色 十六进制、RGB 元组或者颜色名字。 n_colors：int, 可选 调色板中的颜色数。 reverse：bool, 可选 如果为 True 值，则反转混合的方向。 as_cmap：bool, optional 如果为 True 值，则返回 matplotlib colormap 而不是列表。 input：{‘rgb’, ‘hls’, ‘husl’, xkcd’} 用于解释输入颜色的颜色空间。前三个选项适用于元组输入，后者适用于字符串输入。 返回值：palette or cmap：seaborn color palette or matplotlib colormap 类似列表的颜色对象的 RGB 元组，或者可以将连续值映射到颜色的 colormap 对象，具体取决于 as_cmap 参数的值。 另外 创建具有暗低值的连续调色板。创建有两种颜色的发散调色板。 例子 从一个 HTML 颜色生成一个调色板： >>> import seaborn as sns; sns.set() >>> sns.palplot(sns.dark_palette(\"purple\")) 生成亮度降低的调色板： >>> sns.palplot(sns.dark_palette(\"seagreen\", reverse=True)) 从 HUSL 空间种子生成选项板： >>> sns.palplot(sns.dark_palette((260, 75, 60), input=\"husl\")) 生成一个 colormap 对象： >>> from numpy import arange >>> x = arange(25).reshape(5, 5) >>> cmap = sns.dark_palette(\"#2ecc71\", as_cmap=True) >>> ax = sns.heatmap(x, cmap=cmap) Update time： 2020-05-23 "},"Chapter7/seaborn.light_palette.html":{"url":"Chapter7/seaborn.light_palette.html","title":"seaborn.light_palette","keywords":"","body":"seaborn.light_palette seaborn.light_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb') 制作一个混合浅色和 color 模式的顺序调色板。 这种调色板适用于数据集的范围从相对低值(不感兴趣)到相对高值(很感兴趣)时。 可以通过多种方式指定 color 参数，包括用于在 matplotlib 中定义颜色的所有选项，以及由 seborn 处理的其他几个颜色空间。也可以使用 XKCD color survey 中的颜色名字数据库。 如果您在使用 IPython notebook，您还可以通过 choose_light_palette() 函数交互式选择调色板。 参数：color：高值的基色 十六进制、input 中的元组或者颜色名字。 n_colors：int, 可选 调色板中的颜色数。 reverse：bool, 可选 如果为 True 值，则反转混合的方向。 as_cmap：bool, 可选 如果为 True 值，则返回 matplotlib colormap 而不是列表。 input：{‘rgb’, ‘hls’, ‘husl’, xkcd’} 用于解释输入颜色的颜色空间。前三个选项适用于元组输入，后者适用于字符串输入。 返回值：palette or cmap：seaborn color palette or matplotlib colormap 类似列表的颜色对象的 RGB 元组，或者可以将连续值映射到颜色的 colormap 对象，具体取决于 as_cmap 参数的值。 另外 创建具有暗低值的连续调色板。创建有两种颜色的发散调色板。 例子 从一个 HTML 颜色生成一个调色板： >>> import seaborn as sns; sns.set() >>> sns.palplot(sns.light_palette(\"purple\")) 生成亮度降低的调色板： >>> sns.palplot(sns.light_palette(\"seagreen\", reverse=True)) 从 HUSL 空间种子生成选项板： >>> sns.palplot(sns.light_palette((260, 75, 60), input=\"husl\")) 生成一个 colormap 对象： >>> from numpy import arange >>> x = arange(25).reshape(5, 5) >>> cmap = sns.light_palette(\"#2ecc71\", as_cmap=True) >>> ax = sns.heatmap(x, cmap=cmap) Update time： 2020-05-23 "},"Chapter7/seaborn.diverging_palette.html":{"url":"Chapter7/seaborn.diverging_palette.html","title":"seaborn.diverging_palette","keywords":"","body":"seaborn.diverging_palette seaborn.diverging_palette(h_neg, h_pos, s=75, l=50, sep=10, n=6, center='light', as_cmap=False) 在两个 HUSL 颜色直接建立一个发散调色板。 如果您在使用 IPython notebook，您还可以通过 choose_diverging_palette() 函数交互式选择调色板。 参数：h_neg, h_pos：float in [0, 359] 图的正负范围的锚定色调 s：[0, 100] 范围内的浮点数，可选 图的两个范围的锚定饱和度 l：[0, 100] 范围内的浮点数，可选 图的两个范围的锚定亮度 n：int，可选 调色板中的颜色数（如果为 not，返回一个 colormap） center：{“light”, “dark”}, 可选 调色板中心为亮或暗 as_cmap：bool, 可选 如果为 true，返回一个 matplotlib colormap 而不是一个颜色列表。 返回值：palette or cmap：seaborn color palette or matplotlib colormap 类似列表的颜色对象的 RGB 元组，或者可以将连续值映射到颜色的 colormap 对象，具体取决于 as_cmap 参数的值。 另外 创建具有暗值的连续调色板。创建具有亮值的连续调色板。 例子 生成一个蓝-白-红调色板： >>> import seaborn as sns; sns.set() >>> sns.palplot(sns.diverging_palette(240, 10, n=9)) 生成一个更亮的绿-白-紫调色板： >>> sns.palplot(sns.diverging_palette(150, 275, s=80, l=55, n=9)) 生成一个蓝-黑-红调色板: >>> sns.palplot(sns.diverging_palette(250, 15, s=75, l=40, ... n=9, center=\"dark\")) 生成一个 colormap 对象: >>> from numpy import arange >>> x = arange(25).reshape(5, 5) >>> cmap = sns.diverging_palette(220, 20, sep=20, as_cmap=True) >>> ax = sns.heatmap(x, cmap=cmap) Update time： 2020-05-23 "},"Chapter7/seaborn.mpl_palette.html":{"url":"Chapter7/seaborn.mpl_palette.html","title":"seaborn.mpl_palette","keywords":"","body":"seaborn.mpl_palette seaborn.mpl_palette(name, n_colors=6) 从一个 matplotlib 调色板中返回离散颜色。 请注意，这会正确处理定性的 colorbrewer 调色板，但如果您要求的颜色多于特定的定性调色板，提供的颜色将会比您预期的少。相反，使用 color_palette() 函数请求一个定性 colorbrewer 调色板将会返回预期数目的颜色，但是是循环型的。 如果您在使用 IPython notebook，您还可以通过 choose_colorbrewer_palette() 函数交互式选择调色板。 参数：name：string 调色板名字，应该是一个被命名的 matplotlib colormap。 n_colors：int 调色板中离散颜色的个数。 返回值：palette or cmap：seaborn 调色板或者 matplotlib colormap 类似列表的颜色对象的 RGB 元组，或者可以将连续值映射到颜色的 colormap 对象，具体取决于 as_cmap 参数的值。 例子 生成一个含有 8 种颜色的定性 colorbrewer 调色板： >>> import seaborn as sns; sns.set() >>> sns.palplot(sns.mpl_palette(\"Set2\", 8)) 生成一个连续的 colorbrewer 调色板： >>> sns.palplot(sns.mpl_palette(\"Blues\")) 生成一个发散调色板： >>> sns.palplot(sns.mpl_palette(\"seismic\", 8)) 生成一个 “dark” 顺序调色板： >>> sns.palplot(sns.mpl_palette(\"GnBu_d\")) Update time： 2020-05-23 "},"Chapter7/seaborn.despine.html":{"url":"Chapter7/seaborn.despine.html","title":"seaborn.despine","keywords":"","body":"seaborn.despine seaborn.despine(fig=None, ax=None, top=True, right=True, left=False, bottom=False, offset=None, trim=False) 从图中移除顶部和右侧脊柱。 fig : matplotlib 值, 可选 去除所有轴脊柱，默认使用当前数值。 ax : matplotlib 轴, 可选 去除特定的轴脊柱。 top, right, left, bottom : boolean, 可选 如果为 True，去除脊柱。 offset : int or dict, 可选 绝对距离（以磅为单位）应将脊椎移离轴线（负值向内移动脊柱）。 单个值适用于所有脊柱; 字典可用于设置每侧的偏移值。 trim : bool, 可选 如果为 True，则将脊柱限制为每个非去除脊柱的轴上的最小和最大主刻度。 返回值：None | | --- | --- | Update time： 2020-05-23 "}}